/*
EchoLisp
usage library
(C) G.Brougnard, Jacques Tramu, 2015
*/
var _USAGE = [
"(<b>- </b>a b c â€¦)",
"(<b>- </b>a)",
"(<b>? </b>symbol)",
"(<b>* </b>a b c â€¦)",
"(<b>/ </b>a b c â€¦)",
"(<b>/ </b>a b)",
"(<b>/ </b>a)",
"(<b>// </b>a b)",
"(<b>// </b>a b)",
"(<b>&gt; </b>x y)",
"(<b>&gt;= </b>x y)",
"(<b>&lt; </b>x y)",
"(<b>&lt;= </b>x y)",
"(<b>+ </b>a b c ...)",
"(<b>= </b>x y)",
"(<b>1- </b>x)",
"(<b>1+ </b>x)",
"(<b>*= </b>var-id value)  ; (set! var-id (* var-id value))",
"(<b>/= </b>var-id value)  ; (set! var-id (/ var-id value))",
"(<b>//= </b>var-id value)  ; (set! var-id (// var-id value))",
"(<b>+= </b>var-id value)  ; (set! var-id (+ var-id value))",
"(<b>-= </b>var-id value)  ; (set! var-id (- var-id value))",
"(<b>++ </b>var-id )  ; (set! var-id (+ var-id 1))",
"(<b>-- </b>var-id )  ; (set! var-id (- var-id 1))",
"(<b>-> </b> x f g h .. )  ; pipelines first",
"(<b>->> </b> x f g h ..)  ; pipelines last",
"(<b>abs </b>x)",
"(<b>acos </b>x)",
"(<b>add1 </b>x)",
"(<b>alist? </b>object)",
"(<b>and </b>e<sub>1</sub> e<sub>2</sub> â€¦)",
"(<b>angle </b>z)",
"(<b>Anp </b>n p)",
"(<b>any </b> predicate list [list]) âž› #t or #f",
"(<b>ap </b>â€¦)",
"(<b>append </b>list<sub>1</sub> list<sub>2</sub>  â€¦ )",
"(<b>apply </b>fun list)",
"(<b>apropos </b>regexp)",
"(<b>apropos </b>string)",
"(<b>arithmetic-shift </b>n m )",
"(<b>asin </b>x)",
"(<b>assert </b>expression message-string)",
"(<b>assert </b>expression)",
"(<b>assoc </b>key alist)",
"(<b>association-procedure </b>predicate selector)",
"(<b>assq </b>key alist)",
"(<b>assv </b>key alist)",
"(<b>at </b>[multiplier] unit-name alert-proc-id)",
"(<b>at </b>date alert-proc-id)",
"(<b>atan </b>x)",
"(<b>atan </b>y x)",
"(<b>autocomplete-delay </b>0)",
"(<b>autocomplete-delay </b>msec)",
"(<b>begin </b>expr<sub>1</sub> â€¦. expr<sub>n</sub>)",
"(<b>begin0 </b>expr<sub>1</sub> â€¦. expr<sub>n</sub>)",
"(<b>bit-count </b>n m)",
"(<b>bit-right </b>n)",
"(<b>bitwise-and </b>n m)",
"(<b>bitwise-bit-set? </b>n b)",
"(<b>bitwise-ior </b>n m )",
"(<b>bitwise-not </b>n)",
"(<b>bitwise-xor </b>n m )",
"(<b>boolean? </b>obj)",
"(<b>bound? </b>symbol)",
"(<b>box </b> value)",
"(<b>box? </b>a-box)",
"(<b>build-vector </b>length fun)",
"(<b>cache </b>function-id)",
"(<b>cache-size </b> [n]) ; default n= 16000",
"(<b>cadr </b>list)",
"(<b>car </b>list)",
"(<b>car </b>pair)",
"(<b>case </b><i> key ((datum<sub>11</sub> datum<sub>12</sub> â€¦ ) expr<sub>1</sub> â€¦last<sub>1</sub>) ((datum<sub>21</sub> datum<sub>22</sub> â€¦ ) expr<sub>2</sub> â€¦last<sub>2</sub>) (<b>else</b> else<sub>1</sub> .. last_else))", 
"(<b>cbrt </b>z)",
"(<b>cddr </b>list)",
"(<b>cdot-product </b>vector-za vector-zb)",
"(<b>cdot-product* </b>vector-za vector-zb)",
"(<b>cdr </b>list)",
"(<b>cdr </b>pair)",
"(<b>ceil </b>x)",
"(<b>change-proc </b>instance field-id old-value tentative-new-value)",
"(<b>check-expect </b>expression value)",
"(<b>circular-list </b>a b c)",
"(<b>circular? </b>list)",
"(<b>Cnp </b>n p )",
"(<b>complex </b>a b)",
"(<b>complex? </b>z)",
"(<b>compile </b>symb options-string) options: -v, -a, -f",
"(<b>compose </b>f g h â€¦) âž› &lambda;",
"(<b>conjugate </b>z)",
"(<b>cond </b>((test<sub>1</sub> expr<sub>1</sub>...last<sub>1</sub>) ... (test<sub>2</sub>  expr<sub>2</sub>...last<sub>2</sub>) [(<b>else</b> default<sub>1</sub> ...  default<sub>n</sub>)])",
"(<b>cons </b>item list<sub>1</sub>)",
"(<b>cons </b>item null)",
"(<b>cons </b>item<sub>1</sub> item<sub>2</sub>)",
"(<b>console-log </b>message object)",
"(<b>console-trace </b>message object)",
"(<b>contfract->number </b>continued-fraction [n] )",
"(<b>convergents </b>continued-fraction [n])",
"(<b>copy </b>list)",
"(<b>cos </b>z)",
"(<b>cpoly </b>z Pz Qz)",
"(<b>cpoly </b>z Pz)",
"(<b>croot </b>f zmin zmax)",
"(<b>cserie </b>f z nmax)",
"(<b>current-time-milliseconds </b>)",
"(<b>current-time</b>)",
"(<b>currrent-date</b>)",
"(curry </b> proc v<sub>1</sub> v<sub>2</sub> â€¦)",
"(<b>data-serie </b>[list|vector])",
"(<b>data-serie-get </b>x-value)",
"(<b>data-serie-x </b> serie i)",
"(<b>data-serie-y </b> serie i)",
"(<b>date </b>[multiplier] unit-name)",
"(<b>date </b>year month day hour minute seconds milliseconds)",
"(<b>date->date-string </b>date)",
"(<b>date->seconds </b>date)",
"(<b>date->string </b>date)",
"(<b>date->time-string </b>date)",
"(<b>date-add! </b>date seconds)",
"(<b>date-diff </b>date_1 date_2)",
"(<b>date-format </b>date language options-values-list)",
"(<b>date? </b>object)",

"(<b>db-verbose </b>[#f|#t])",
"(<b>db-name</b>) ",
"(<b>db-version </b>) ",
"(<b>db-stores </b>) ",
"(<b>db-make-store </b>name) ",
"(<b>db-delete-store! </b>name) ",
"(<b>db-keys </b>store  onsuccess) ",
"(<b>db-put </b>[store.]symbol)",
"(<b>db-get </b>[store.]symbol [onsuccess [onerror]]) ",
"(<b>db-get-range </b>[keyfrom|...] [keyto|...] store onsuccess onerror)",
"(<b>db-put-value </b>[key|#:auto] value store [onsuccess [onerror]])",
"(<b>db-add-value </b>[key|#:auto] value store [onsuccess [onerror]])",
"(<b>db-get-value </b>key store onsuccess [onerror])",
"(<b>db-put-values </b>imin imax [key-proc|#:auto] value-proc store [oncomplete [onerror]]) ",
"(<b>db-select </b>selector store onsuccess [onerror]) ; (define (selector key value) ...) ->#t|#f",
"(<b>db-select-count </b>selector store onsuccess [onerror]) ; (define (selector key value) ...) ->#t|#f",

	
"(<b>debug </b>option)",
"(<b>decimals </b>)",
"(<b>decimals </b>n)",
"(<b>define </b>var-id value)",
"(<b>define </b>(function-id args) expr<sub>1</sub> ...)  ; args :=  arg<sub>1</sub>  arg<sub>2</sub> ... | (arg<sub>i</sub> default) ... |  arg<sub>1</sub>  arg<sub>2</sub> ...  <b>.</b> rest",
"(<b>define-constant </b>CONSTANT-ID value)",
"(<b>define-global </b>expr value)",
'(<b>define-macro </b> name pattern template)',
'(<b>define-modifier-key </b>["ctrl"|"alt"|"cmd"|null)',
"(<b>define-syntax </b>function-id (syntax-rules keywords-list clause<sub>1</sub> ... clause<sub>n</sub>)",
"(<b>define-syntax-rule </b>pattern template)",
"(<b>define-syntax-id </b>symbol expr template)",
"(<b>define-values </b>(id id ...) (values a b ...))",
"(<b>definitions</b>)",
"(<b>delay </b>expression)",
"(<b>den </b>a/b)",
"(<b>deriv </b>f x<sub>0</sub>)",
"(<b>display </b>object css-style-string)",
"(<b>display </b>object)",
"(<b>distance </b>xa ya xb yb) ; of points (xa ya) (xb yb)",
"(<b>do </b> ((variable<sub>1</sub> init<sub>1</sub> step<sub>1</sub>) â€¦) (test final<sub>1</sub> â€¦) expr<sub>1</sub> â€¦)",
"(<b>dot-product </b>vector-a vector-b)",
"(<b>drop </b> [list|vector|string|generator] n-first-elements)",
"(<b>edit </b>function-symb)",
"(<b>empty? </b>obj)",
"(<b>!empty? </b>obj)",
"(<b>environment-bindings </b>env)",
"(<b>environment-current</b>)",
"(<b>environment-new </b>env-list)",
"(<b>environment-of </b>lambda-closure | function-id | symbol )",
"(<b>environment-parent </b>env)",
"(<b>environment? </b>obj)",
"(<b>eq? </b>obj<sub>1</sub> obj<sub>2</sub>)",
"(<b>equal? </b>obj<sub>1</sub> obj<sub>2</sub>)",
"(<b>eqv? </b>obj<sub>1</sub> obj<sub>2</sub>)",
"(<b>error </b>message-string object)",
"(<b>eval </b>expression env)",
"(<b>eval </b>expression)",
"(<b>even? </b>n)",
"(<b>every </b> predicate list [list]) âž› #t or #f",
"(<b>at-every </b>interval-msec timer-proc:1) ; (timer-proc time-msec)",
"(<b>exact? </b>x)",
"(<b>exp </b>z)",
"(<b>expt </b>z z1)",
"(<b>factor </b>a)",
"(<b>factorial </b>n)",
"(<b>file->string </b>success-proc filename)",
"(<b>file->string </b>success-proc)",
"(<b>filter </b>predicate list)",
"(<b>filter-count </b>predicate list)",
"(<b>first </b>list)",
"(<b>floor </b>x)",
"(<b>fminmax </b>f<sub>x</sub> x-range)",
"(<b>foldl </b>fun:2 acc<sub>0</sub> list) ; (fun x accumulator) -> new accumulator value",
"(<b>foldl </b>fun:3 acc<sub>0</sub> list<sub>1</sub> list<sub>2</sub>) ; (fun x y accumulator) -> new accumulator value",
"(<b>foldr </b>fun:2 acc<sub>0</sub> list)  ; (fun x accumulator) -> new accumulator value",
"(<b>foldr </b>fun:3 acc<sub>0</sub> list<sub>1</sub> list<sub>2</sub>)",


"(<b>for/acc </b>((var<sub>1</sub> range<sub>1</sub>) (var<sub>2</sub> range<sub>2</sub>) ...) expr expr ... expr<sub>n</sub>) ; accumulates expr<sub>n</sub> - acc := sum|product|list|vector|string|and|or",
"(<b>for </b>((var<sub>1</sub> range<sub>1</sub>) (var<sub>2</sub> range<sub>2</sub>) ...) expr expr ...) ; // loops - range<sub>i</sub> := number, or list, or (in-range ...), or vector, or stream, or string or table or ...",
"(<b>for* </b>((var<sub>1</sub> range<sub>1</sub>) (var<sub>2</sub> range<sub>2</sub>) ...) expr expr ...) ; range<sub>i</sub> := number, or list, or (in-range ...), or vector, or stream, or string or ...",


"(<b>for-each </b>fun:1 list)",
"(<b>for-each </b>fun:2 list list<sub>2</sub>)",
"(<b>force </b>promise)",
"(<b>forget </b>function-id)",
"(<b>format </b>format-string [val<sub>1</sub> ... ])",
"(<b>fract </b>x)",
"(<b>fractal </b>z zc n)",
"(<b>fractal-p </b>z zc p n)",
"(<b>gcd </b>a b c â€¦)",
"(<b>gensym</b>)",
"(<b>get </b>symb key)",
"(<b>getprop </b>symb key)",
"(<b>gray </b>g)",
"(<b>help </b>letter)",
"(<b>help </b>symbol)",
"(<b>html-print </b>string)",
"(<b>hsv->rgb </b>h s v)",
"(<b>identity </b>x)",
"(<b>if </b>cond t-expr f-expr)",
"(<b>imag </b>z)",
"(<b>imag-part </b>z)",
"(<b>json-import </b>JSON-string)",
"(<b>in-cycle </b> list)",
"(<b>in-naturals </b>[start])",
"(<b>in-range </b> start [end [step]])  ; sequence [start .. end[",
"(<b>in-range+ </b> start [end [step]]) ; sequence [start .. end]",
"(<b>in-range </b> start end)",
"(<b>in-range </b>end)",
"(<b>in-primes </b> start)",
"(<b>inexact? </b>x)",
"(<b>info </b>symbol description-string)",
"(<b>info </b>symbol)",
"(<b>input-expr </b> input-proc:1 prompt)",
"(<b>input-string </b> input-proc:1 prompt)",
"(<b>integer? </b>n)",
"(<b>integrate </b>f xmin xmax)",
"(<b>inverter </b>a-number)",
"(<b>iota </b>n) ;; [0 ... n [",
"(<b>iterate </b>f n)",
"(<b>js-eval </b>string)",
"(<b>json->lisp </b>jsObject)",
"(<b>json->plist </b>jsObject)",
"(<b>export-json</b> object)",
"(<b>json-get </b>jsObject key-string )",
"(<b>json-keys </b>jsObject)",
"(<b>json-put </b>jsObject key-string value)",
"(<b>json-types </b>jsObject)",
"(<b>json? </b>object)",
"(<b>lambda </b> arg expr<sub>1</sub> ...)",
"(<b>lambda </b>(args) expr<sub>1</sub> ...)  ; args :=  arg<sub>1</sub>  arg<sub>2</sub> ... | (arg<sub>i</sub> default) ... |  arg<sub>1</sub>  arg<sub>2</sub> ...  <b>.</b> rest",
"(<b>last </b>list)",
"(<b>lcm </b>a b)",
"(<b>length </b>list)",
"(<b>let </b>[proc-id] ((id<sub>1</sub> val<sub>1</sub>) ...) expr<sub>1</sub> ...)",
"(<b>let* </b>((id<sub>1</sub> val<sub>1</sub>) ...) expr<sub>1</sub> ...)",
"(<b>letrec </b>((id<sub>1</sub> val<sub>1</sub>) ...) expr<sub>1</sub> ...)",

"(<b>lib </b>library-id)",
"(<b>lib-functions </b>library-id)",
"(<b>linear </b>x xmin xmax )",
"(<b>linear </b>x xmin xmax ymin ymax)",
"(<b>lisp->json </b>object)",
"(<b>list </b>a b c  â€¦)",
"(<b>flatten </b> list)",
"(<b>group </b> list  [compare-proc:2:2])",
"(<b>group* </b> list  [compare-proc:2:2])",
"(<b>hash </b> object) â†’ in [0..2^32-1]",
"(<b>list->number  </b> list-of-digits-or-strings) ; implode",
"(<b>list->stack  </b> list stack-id)",
"(<b>list->string  </b> list)",
"(<b>list->vector </b>'(a b c ...)",
"(<b>list-index </b>needle list) ; uses equal?",
"(<b>list-ref </b>list index)",
"(<b>list-sort </b>sort-predicate list)",
"(<b>list-sort/fields </b>num-fields list)",
"(<b>list-swap! </b>list u v)",
"(<b>list-swap-ref! </b>list i j)",
"(<b>list-tail </b>list pos)",
"(<b>list? </b>obj)",
"(<b>load </b>)",
"(<b>load </b>filename)",
"(<b>load-reader-dict </b>dict-id)",
"(<b>load-words </b>table-id)",

"(<b>local-verbose </b>[#t|#f]) ",
"(<b>local-stores </b>) ",
"(<b>local-stores name-search-string</b>) ",
"(<b>local-make-store </b>store) ",
"(<b>local-delete-store! </b>store) ",
"(<b>local-symbol? </b>[store.]symbol) ",
"(<b>local-add </b>[store.]symbol) ",
"(<b>local-put </b>[store.]symbol) ",
"(<b>local-get </b>[store.]symbol) ",
"(<b>local-add-value </b>key value [store]) ; <i>key</i> := string|symbol|number | #:auto",
"(<b>local-put-value </b>key value [store]) ; <i>key</i> := string|symbol|number | #:auto",
"(<b>local-get-value </b>key [store]) ; <i>key</i> := string|symbol|number",
"(<b>local-delete </b>key store) ",
"(<b>load-package </b>store) ",

"(<b>log </b>z)",
"(<b>log10 </b>x)",
"(<b>log2 </b>x)",
"(<b>mail </b>address subject expr)",
"(<b>macro?</b> name)",
"(<b>magnitude </b>z)",
"(<b>make-json </b>key-value-list)",
"(<b>make-list </b>length object)",
"(<b>make-polar </b>rho theta)",
"(<b>make-rect </b>a b)",
"(<b>make-regexp </b>pattern-string)",
"(<b>make-set </b>from-list)",
"(<b>make-stream</b> state-proc:1 initial-state)",
"(<b>make-symbol</b> [name|string])",
"(<b>make-vector </b>length init)",
"(<b>make-vector </b>length)",
"(<b>map </b>fun:1:n list|vector|sequence ... )",
"(<b>maplist </b>fun:1 list)",
"(<b>mark </b>list tag)",
"(<b>mark-filter </b>list filter)",
"(<b>mark-filter </b>list)",
"(<b>mark-print </b>[#t | #f])",
"(<b>mark? </b>list)",
"(<b>match </b>expr (pattern body) (pattern body) ... [else body])",
"(<b>math-precision </b>value)",
"(<b>math-precision</b>)",
"(<b>max </b>x y z â€¦)",
"(<b>member </b>item list)  ; uses equal?",
"(<b>member* </b>item list) ; uses equal?",
"(<b>memq </b>item list) ; uses eq?",
"(<b>memv </b>item list) ; uses eqv?",
"(<b>meta-key </b>1-letter/digit-string replacing-string)",
"(<b>meta-keys </b>)",
"(<b>min </b>x y z â€¦)",
"(<b>modulo </b>n p)",
"(<b>nconc </b>list<sub>1</sub> list<sub>2</sub>  â€¦)",
"(<b>negative? </b>x)",
"(<b>newline</b>)",
"(<b>next-prime </b>n)",
"(<b>normal </b> x &mu;<sub>x</sub> &sigma;<sub>x</sub>)",
"(<b>normal-2 </b> x y &rho; &mu;<sub>x</sub> &sigma;<sub>x</sub> [&mu;<sub>y</sub>  [&sigma;<sub>y</sub>]])",
"(<b>norm-1 </b>vector-a vector-b)",
"(<b>norm-2 </b>vector-a vector-b)",
"(<b>norm-inf </b>vector-a vector-b )",
"(<b>norm-p </b>vector-a vector-b p )",
"(<b>not </b>#f)",
"(<b>not </b>any-other-than-#f)",
"(<b>nth-prime </b>n)",
"(<b>null? </b>obj)",
"(<b>!null? </b>obj)",
"(<b>num </b>a/b)",
"(<b>number-length </b>number [base])",
"(<b>number->contfract </b>number [n])",
"(<b>number->list </b>number) ; explode",
"(<b>number->string </b>number [base])",
"(<b>number? </b>n)",
"(<b>number? </b>obj)",
"(<b>odd? </b>n)",
"(<b>oeis </b>list-of-integers)",
"(<b>oeis </b>string)",
"(<b>open-url </b>url-string)",
"(<b>operator </b>val<sub>1</sub> â€¦ val<sub>i</sub> â€¦ val<sub>n</sub>)",
"(<b>or* </b>e<sub>1</sub> e<sub>2</sub>)",
"(<b>or </b>e<sub>1</sub> e<sub>2</sub> ..)",
"(<b>pair? </b>obj)",
"(<b>pair? </b>pair)",
"(<b>play-sound </b>sound-id)",
"(<b>plist-keys </b>symbol)",
"(<b>plot </b>f<sub>x</sub> x-range)",
"(<b>plot-animate </b>seconds)",
"(<b>plot-axis </b>x<sub>0</sub> y<sub>0</sub> [color])",
"(<b>plot-background </b>color)",
"(<b>plot-circle </b>x<sub>0</sub> y<sub>0</sub> R<sub>0</sub>)",
"(<b>plot-clear</b>)",
"(<b>plot-color </b>color)",
"(<b>plot-dots </b>data-serie string)",
"(<b>plot-fill-color </b>color)",
"(<b>plot-font </b>font)",
"(<b>plot-grid </b>x-unit y-unit [color])",
"(<b>plot-hilbert </b>rgb-fun<sub>n</sub> n-range)",
"(<b>plot-init</b>)",
"(<b>plot-line-width </b>n)",
"(<b>plot-minmax </b>)",
"(<b>plot-off</b>)",
"(<b>plot-on</b>)",
"(<b>plot-rect </b>x<sub>0</sub> y<sub>0</sub> x<sub>1</sub> y<sub>1</sub>)",
"(<b>plot-rgb </b>rgb-fun<sub>xy</sub> x-range y-range)",
"(<b>plot-size </b>[pixels])",
"(<b>plot-spiral </b>rgb-fun<sub>n</sub> n-range)",
"(<b>plot-square </b>x<sub>0</sub> y<sub>0</sub> W)",
"(<b>plot-steps </b>steps)",
"(<b>plot-text </b>string x<sub>0</sub> y<sub>0</sub> [color])",
"(<b>plot-time-serie </b>time-serie [ interval [ date-range]])",
"(<b>plot-undo </b>)",
"(<b>plot-x-minmax </b> 'auto)",
"(<b>plot-x-minmax </b>range)",
"(<b>plot-xy </b>f<sub>xy</sub> x-range y-range)",
"(<b>plot-y-minmax </b> 'auto)",
"(<b>plot-y-minmax </b>range)",
"(<b>plot-z-arg </b>f_z x-range y-range)",
"(<b>plot-z-mod </b>f_z x-range y-range)",
"(<b>polar </b>rho theta)",
"(<b>poly </b>x P Q)",
"(<b>poly </b>x P)",
"(<b>poly->html </b> var-id P  [Q] )",
"(<b>poly->string </b> var-id P Q)",
"(<b>poly->string </b> var-id P)",
"(<b>poly-add </b>P Q)",
"(<b>poly-mul </b>P Q)",
"(<b>poly-mul-k </b>P k)",
"(<b>poly-pow </b>P n)",
"(<b>pop </b>stack-id)",
"(<b>positive? </b>x)",
"(<b>powmod </b>base exp mod) âž›  base<sup>exp</sup> modulo mod",
"(<b>positive*? </b>n)",
"(<b>petty-print </b>expr [max-line-length])  or  (pp expr)",
"(<b>pp </b>expr [max-line-length])  or  (pretty-print expr)",
"(<b>prime-factors </b>n)",
"(<b>prime? </b>p)",
"(<b>primes </b>n)",
"(<b>primes-pi </b>n)",
"(<b>printer-clear </b>)",
"(<b>printer-echo </b> [#t | #f] )",
"(<b>printer-font </b>)",
"(<b>printer-font </b>font-string)",
"(<b>printer-page </b>[title-string])",
"(<b>printer-writeln </b>object<sub>1</sub> ..object<sub>i</sub> ..)",
"(<b>printf </b>format-string val<sub>1</sub> val<sub>2</sub> ... val<sub>n</sub>)",
"(<b>procedure? </b>obj)",
"(<b>product </b>f<sub>n</sub> nfrom nto)",
"(<b>promise? </b>promise)",
"(<b>push </b>stack-id value)",
"(<b>putprop </b>symb value key)",
"(<b>pythagore </b>a b)",
"(<b>quasiquote </b>template)",
"(<b>quote </b>object)",
"(<b>quotient </b>m n) ; integer divide : (floor (/ m n))",
"(<b>random </b> -1)",
"(<b>random </b> int-negative-base)",
"(<b>random </b>)",
"(<b>random </b>int-base)",
"(<b>random-prime </b>n)",
"(<b>random-seed </b>seed)",
"(<b>range </b>n m ) ;; -> [n...m[",
"(<b>range </b>n m step)",
"(<b>rational </b>a b)",
"(<b>rational? </b>q)",
"(<b>rationalize </b>x [Îµ])  ; default Îµ = 0.0001",
"(rcurry </b> proc v<sub>1</sub> v<sub>2</sub> â€¦)",
"(<b>read </b>default-value prompt-string)",
"(<b>read </b>default-value) â†’ object or #f",
"(<b>read-from-string </b>input-string)",
"(<b>read-list </b>[default-value [ prompt-string]]) â†’ list or #f",
"(<b>read-string </b>[default-value [ prompt-string]])",
"(<b>read</b>)",
"(<b>reader-dict-new </b>key-value-list)",
"(<b>reader-dict-set! </b> key #f)",
"(<b>reader-dict-set! </b>key value)",
"(<b>reader-dict</b>)",
"(<b>reader-rem-proc</b>)",
"(<b>reader-set-proc! </b>reader-procedure prompt-string)",
"(<b>reader-translate </b>[old-string|regexp] new-string|null)",
"(<b>real </b>z)",
"(<b>real-part </b>z)",
"(<b>regexp-exec </b>regexp string)",
"(<b>regexp-match </b>regexp|substring string) âž› list of matches",
"(<b>regexp-match* </b>regexp|substring string) âž› list of matches",
"(<b>remember </b>function-id [init-vector])",
"(<b>remove-local </b>symbol)",
"(<b>remprop </b>symb key)",
"(<b>require </b>lib-id | (lib-id-1 ... lib-id-n))",
"(<b>rest </b>list)",
"(<b>reverse </b> list)",
"(<b>rgb </b>r g b)",
"(<b>rgba </b>r g b a)",
"(<b>root </b>f xmin xmax)",
"(<b>round </b>x)",
"(<b>s-curve </b>x gamma)",
"(<b>save-as </b>object filename [.txh|.htm|.html]) ",
"(<b>save-package </b>store) ",
"(<b>save-reader-dict </b>dict-id)",
"(<b>second </b>list)",
"(<b>seconds->date </b>sec)",
"(<b>serie </b>f x nmax)",
"(<b>set-box! </b>a-box value)",
"(<b>set-car! </b>list<sub>1</sub> new-first)",
"(<b>set-cdr! </b>list<sub>1</sub> list<sub>2</sub>)",
"(<b>set-equal? </b>setA setB)",
"(<b>set-intersect </b>setA setB)",
"(<b>set-intersect? </b>setA setB)",
"(<b>set-product </b>setA setB)",
"(<b>set-plist! </b>symb ((key<sub>1</sub> value<sub>1</sub>) ...)",
"(<b>set-struct-id-field-id! </b>instance value)",
"(<b>set-subset? </b>setA setB)  ; B âŠ† A",
"(<b>set-substract </b>setA setB)",
"(<b>set-sym-diff </b>setA setB)",
"(<b>set-union </b>setA setB)",
"(<b>set! </b>symbol-id value)  â†’ void",
"(<b>setv! </b>symbol-id value) â†’ value",
"(<b>set!-values </b>(id id ..) (values a b ..))",
"(<b>set? </b>object)",
"(<b>shuffle </b>list)",
"(<b>sigma </b>f<sub>n</sub> nfrom nto)",
"(<b>sin </b>z)",
"(<b>smoothstep </b>x)",
"(<b>sqrt </b>z)",
"(<b>square? </b>n)",
"(<b>stack </b>stack-id)",
"(<b>stack->list </b>stack-id)",
"(<b>stack-length </b>stack-id)",
"(<b>stack-empty? </b>stack-id)",
"(<b>stack-swap </b>stack-id)",
"(<b>stack-top </b>stack-id)",
"(<b>stream->list </b>stream  limit )",
"(<b>stream->list </b>stream )",
"(<b>stream-add </b>stream_1 stream_2)",
"(<b>stream-cons </b>first-value rest-proc)",
"(<b>stream-cons </b>first-value rest-stream)",
"(<b>stream-cons </b>first-value empty-stream)",
"(<b>stream-empty? </b>object)",
"(<b>stream-filter </b>filter-proc:1 stream)",
"(<b>stream-iterate </b>stream)",
"(<b>stream-first </b>stream)",
"(<b>stream-map </b>  proc-id stream_1 stream_2)",
"(<b>stream-mul </b>stream_1 stream_2)",
"(<b>stream-ref </b>stream n)",
"(<b>stream-rest </b>stream)",
"(<b>stream? </b>object)",
"(<b>string? </b>object)",
"(<b>string </b>object)   â†’ stringifies obj" ,
"(<b>string-alphabetic? </b>string)  â†’ #t or #f",
"(<b>string->date </b>date-string)",
"(<b>string->list </b>str)",
"(<b>string->number </b>str)",
"(<b>string->url </b>string)",
"(<b>string-append </b>str1 str2 ..)",
"(<b>string-ci&gt? </b>str1 str2)",
"(<b>string-ci&gt=? </b>str1 str2)",
"(<b>string-ci&lt? </b>str1 str2)",
"(<b>string-ci&lt=? </b>str1 str2)",
"(<b>string-ci=? </b>str1 str2)",
"(<b>string-delimiter </b>)",
"(<b>string-delimiter </b>delim)",
"(<b>string-downcase </b>\"ABcD\")",
"(<b>string-first </b>str)",
"(<b>string-join </b>list [separator])",
"(<b>string-index </b>needle string)  ; -1 if needle not found",
"(<b>string-last </b>str)",
"(<b>string-split </b>  str [separator-string|regexp]) ; default sep = space",
"(<b>string-length </b>str)",

"(<b>string-match </b>str substring)",
"(<b>string-match </b>str \"/regexp/\")",
"(<b>string-match </b>str \"/regexp/\" mod)  ; mod=\"i\" : ignore case",
"(<b>string-prefix? </b>prefix string)",
"(<b>string-suffix? </b>suffix string)",

"(<b>string-pad-left </b>object length)",
"(<b>string-pad-right </b>object length)",
"(<b>string-randcase </b>\"longtemps\")",
"(<b>string-ref </b>str index)",
"(<b>string-split </b>str separator-string|regexp)",
"(<b>string-replace </b>str substring replacement-string)",
"(<b>string-replace </b>str regexp replacement-string)",
"(<b>string-replace </b>str regexp replacement-string mode)  ; mode =\"i\" : ignore case, \"g\" ,...",
"(<b>string-remove </b>str to-remove-chars)",

"(<b>string->html </b>str)",
"(<b>string-rest </b>str)",
"(<b>string-trim </b>str)",
"(<b>string-trim-left </b>str)",
"(<b>string-trim-right </b>str)",
"(<b>string-titlecase </b>\"longtemps\")",
"(<b>string-upcase </b>\"abcd\")",
"(<b>string? </b>x)",
"(<b>string&gt? </b>str1 str2)",
"(<b>string&gt=? </b>str1 str2)",
"(<b>string&lt? </b>str1 str2)",
"(<b>string&lt=? </b>str1 str2)",
"(<b>string=? </b>str1 str2)",
"(<b>struct </b> struct-id (slot-desc â€¦)  [#:tostring proc:1]) ; slot-desc := name | type:name |  (name default [#:onchange proc:3])",
"(<b>struct-id </b>field-value â€¦)",
"(<b>struct-id-field-id </b>instance)",
"(<b>struct-id? </b>obj)",
"(<b>style </b>class-id css-style)",
"(<b>style </b>class-id)",
"(<b>style </b>object css-style)",
"(<b>style </b>object)",
"(<b>style</b>)",
"(<b>sub1 </b>x)",
"(<b>sublist </b>list from to)",
"(<b>substring </b> str start end)",
"(<b>substring </b>str -start)",
"(<b>substring </b>str start)",
"(<b>subvector </b>v start [end])",
"(<b>symbol->string </b>[symb | string])",
"(<b>symbol-plist </b>symb)",
"(<b>symbol? </b>obj)",
"(<b>symset! </b>symb val)",
"(<b>take </b> [list|vector|string|stream|generator|table|hash] n-first-elements)",
"(<b>tag? </b> tag)",
"(<b>tags-new </b> (tag<sub>i</sub> â€¦)",
"(<b>tags</b>)",
"(<b>tan </b>z)",
"(<b>text-parse </b> text-string separators)",
"(<b>text-parse </b> text-string)",
"(<b>third </b>list)",
"(<b>throw </b>error-id message)",
"(<b>time </b>expression)",
"(<b>time-serie </b>[list|vector])",
"(<b>trace </b>function-id)",
"(<b>try</b> try-body (<b>catch</b> (id message) catch-body))",
"(<b>tty-background </b>color-string)",
"(<b>stdout-color </b>color-string)",
"(<b>stdout-font </b>)",
"(<b>stdout-font </b> font-id-string)",
"(<b>stdout-font-size </b>)",
"(<b>stdout-font-size </b>size-number)",
"(<b>unbox </b>a-box)",
"(<b>undefine </b>function-id)",
"(<b>unicode->string </b>char-code) ; charcode: 1028 | 0x404 | #\\u404",
"(<b>unicode->string </b>list-of-char-codes)",
"(<b>string->unicode </b>string) âž› explodes string into list of code values",
"(<b>unless </b>cond expr<sub>1</sub> â€¦ expr<sub>n</sub>)",
"(<b>unmark </b>list)",
"(<b>unquote-splicing </b>object)",
"(<b>unquote</b> object)",
"(<b>untrace </b>function-id)",
"(<b>usage </b>function-id)",
"(<b>values </b>val<sub>1</sub> â€¦ val<sub>i</sub> â€¦)",
"(<b>vector </b>a b c â€¦)",
"(<b>vector->list </b><big>V</big>)",
"(<b>vector-dup </b><big>V</big>) âž› new shallow copy",
"(<b>vector-empty? </b><big>V</big>)",
"(<b>vector-fill! </b><big>V</big> a)",
"(<b>vector-filter </b>pred <big>V</big>)",
"(<b>vector-index </b>needle <big>V</big> [start-index]) ; âž› index : <big>V</big>[index]= needle or #f",
"(<b>vector-append </b>vector<sub>1<sub> vector<sub>2<sub>) âž› new vector",
"(<b>vector-insert* </b>sorted-vector value)",
"(<b>vector-length </b><big>V</big>)",
"(<b>vector-map </b>fun <big>V</big> w ... )",
"(<b>vector-permute! </b><big>V</big> permutation-vector) ; permutes in place",
"(<b>vector-pop </b><big>V</big>)",
"(<b>vector-push </b><big>V</big> obj)",
"(<b>vector-ref </b><big>V</big> i) ; âž› <big>V</big>[i]",
"(<b>vector-remove-ref! </b><big>V</big> index) ; âž› <big>V</big>[index]",
"(<b>vector-remove* </b>sorted-vector value)",
"(<b>vector-rotate! </b><big>V</big> n) ; n in Z",
"(<b>vector-search</b> predicate:1 vector [start-index]) ; âž› index or #f",
"(<b>vector-search*</b> needle sorted-vector) ; âž› index or #f",
"(<b>vector-shift </b><big>V</big>) âž› first element",
"(<b>vector-set! </b><big>V</big> i obj)",
"(<b>vector+= </b><big>V</big> i n) ; âž› <big>V</big>[i] += n",
"(<b>vector*= </b><big>V</big> i x) ; âž› <big>V</big>[i] *= x",
"(<b>vector-sort! </b>sort-proc <big>V</big>)",
"(<b>vector-swap! </b> <big>V</big> i j)",
"(<b>vector? </b><big>V</big>)",
"(<b>version</b>)",
"(<b>when </b>cond expr<sub>1</sub> â€¦ expr<sub>n</sub>)",
"(<b>while </b>cond expr<sub>1</sub> â€¦ expr<sub>n</sub>) ; #:break cond | #:continue cond",
"(<b>wait </b> milli-seconds timer-proc:0)",
"(<b>word </b>word)",
"(<b>word-index </b>word)",
"(<b>word-new </b>word)",
"(<b>word-random </b>pattern tags)",
"(<b>word-ref </b>num)",
"(<b>word-remove-tag </b>word tag)",
"(<b>word-select </b>pattern tags limit)",
"(<b>word-set-tags! </b>word '(tag<sub>i</sub> .. tag<sub>i</sub> )",
"(<b>word-tag </b>word tag)",
"(<b>word-tag? </b>word tag)",
"(<b>word-tags </b>word)",
"(<b>word-tags? </b>word '(tag<sub>i</sub> .. tag_j ..)",
"(<b>word? </b>word)",
"(<b>write </b>object<sub>1</sub> ..object<sub>i</sub> ..)",
"(<b>writeln </b>object<sub>1</sub> ..object<sub>i</sub> ..)",
"(<b>xor </b> a b)",
"(<b>zero? </b>x)",
"(<b>!zero? </b>x)",
"(<b>preferences </b>)",

"(<b>worksheet-open </b>name)",
"(<b>worksheet-remove </b>name)",
"(<b>worksheet-save </b>name)",

"(<b>queue </b><i>queue</i>)",
"(<b>queue-empty? </b><i>queue</i>)",
"(<b>enqueue </b><i>queue value</i>)",
"(<b>queue-top </b><i>queue</i>)",
"(<b>dequeue </b><i>queue</i>)",
"(<b>queue->list </b><i>queue</i>)",
"(<b>list->queue  </b><i> list queue</i>)",

"(<b>graph? </b>obj)",
"(<b>make-graph </b>graph-label)", 
"(<b>graph-make-vertex </b>G label)",
"(<b>graph-delete-vertex </b>G u)",
"(<b>vertex-label </b>u )",
"(<b>vertex-set-label </b>u label)",
"(<b>graph-vertex-ref </b>G label)",
"(<b>graph-make-arc </b>G u v)",
"(<b>graph-delete-arc </b>G u v)",
"(<b>graph-make-edge </b>G u v)",
"(<b>graph-delete-edge </b>G u v)",
"(<b>graph-order </b>G)",
"(<b>graph-size </b>G)",
"(<b>graph-sort </b>G)",
"(<b>graph-dag-sort </b>G)",
"(<b>graph-vertex-out </b>G u)",
"(<b>graph-vertex-in </b>G u)",
"(<b>graph-vertex-outdegree </b>G u)",
"(<b>graph-vertex-indegree </b>G u)",
"(<b>graph-for-each </b>proc:1 G)",
"(<b>graph-cycle </b>G u<sub>0</sub>)",
"(<b>graph-min-path </b>G u v)",
"(<b>graph-cycle </b>G)",
"(<b>graph-print </b>G)",
"(<b>graph-print-vertex </b>G u)"
];

function __special_info (name) {
	var i, nums = _Sysfuns.length ;
	for(i=0; i < nums ;i++) 
		if(_Sysfuns[i].name === name) {
		if(_Sysfuns[i].jsfun.special) return "&#x1F440; " ;
		return "";
		}
	return "";
}

var _usage = function(self) {
	var sym = self[1][0];
	if(isQuote (sym)) sym = sym[1][0]; // the same in (ap..) 
	
	if(sym instanceof Symbol
		&& sym.fval
		&& (isLambda (sym.fval))) {
		var lambda = sym.fval ;
		var body0 = lambda[1][1][0] ;
		if (typeof body0  === "string") {
			info("ðŸ““ " + sym.name + " : " + body0, true);
			return __void;
		}}
	
	sym = nameToString(sym,"usage");
	var match = "(<b>" + sym + " " ;
	var nums = _USAGE.length, i , txt;
// exact match(es)
	for(var i = 0 ; i < nums; i++)
		if(_USAGE[i].indexOf(match) === 0) {
			txt = "ðŸ“— " + __special_info(sym) + _USAGE[i] ;
			while (i < nums && _USAGE[++i].indexOf(match) === 0) txt += ' ' +  _USAGE[i] ;
			info(txt,true); 
			return __void;
			}
// match first
	match = "(<b>" + sym ;
	for(var i = 0 ; i < nums; i++)
	if(_USAGE[i].indexOf(match) === 0) {
			info("ðŸ“™ " + _USAGE[i],true); return __void;
			}
			
// 
// match any inside
	for(var i = 0 ; i < nums; i++)
	if(_USAGE[i].indexOf(sym) !== -1) {
			info("ðŸ““ " + _USAGE[i],true); return __void;
			}
	info("ðŸ˜• Unknown: " + sym,true) ;
	return __void;
}

function boot_usage() { // all units are seconds
	define_special(new Sysfun ("us",_usage,1)) ;
 	define_special(new Sysfun ("usage",_usage,1)) ;
 	
  _LIB["usage.lib"] = true;
 }
 //  boot_usage();

