;; https://en.wikipedia.org/wiki/Legendre_symbol
;; https://en.wikipedia.org/wiki/Cipolla's_algorithm
;; http://rosettacode.org/wiki/Modular_exponentiation
;; (a | p) = a ^ ((p-1)/2)  (mod p)
;; ( a| p) = 1 -> quad residue

{{draft task}}

In computational number theory, [https://en.wikipedia.org/wiki/Cipolla's_algorithm Cipolla's algorithm] is a technique for solving an equation of the form '''x² ≡ n (mod p)''', where p is an odd prime and x ,n Є Fp = {0, 1, ... p-1}.

To apply the algorithm we need the Legendre symbol, and arithmetic in  Fp².

Legendre symbol

* The Legendre symbol ( a | p) denotes the value of  a ^ ((p-1)/2) (mod p)
* (a | p) ≡  1 if a is a square (mod p)
* (a | p) ≡  -1  if a is not a square (mod p)
* (a | p) ≡ 0 is a ≡ 0 

Arithmetic in Fp²

Let ω a symbol such as ω² is a member of Fp and not a square,  x and y members of Fp. The set Fp² is defined as {x + ω y }. Fp² is somewhat equivalent to the set of complex number, with  ω analoguous to i.  Remembering that all operations are modulo p, addition, multiplication and exponentiation in Fp² are defined as :

* (x1 + ω y1) +  (x2 + ω y2) := (x1 + x2 + ω (y1 + y2))
* (x1 + ω y1) *  (x2 + ω y2) := (x1*x2 + y1*y2*ω²) + ω (x1*y2 + x2*y1)
* (x1 + ω y1) ^ n := (x + ω y) * (x + ω y) * ... ( n times) (1)


'''Algorithm pseudo-code'''

* Input : p an odd prime, and n ≠ 0 in Fp
* Step 0. Check that n is indeed a square  : (n | p) must be ≡ 1
* Step 1. Find, by trial and error, an a > 0 such as (a² - n) is '''not''' a square : (a²-n | p) must be ≡ -1.
* Step 2.  Let  ω² = a² - n. Compute, in Fp2 :  (a + ω) ^ ((p + 1)/2) (mod p) 
* Step 3. Check that the result is  x +  0 ω .
* Step 4. Output the two positive solutions, x and p - x  (mod p).
* Step 5. Check that  x * x ≡ n (mod p)

'''Example''' from Wikipedia

<pre>
n := 10 , p := 13
Legendre(10,13) → 1         // 10 is indeed a square
a := 2                      // try
ω² := a*a - 10             // ≡ 7 ≡ -6
Legendre (ω² , 13) → -1    // ok - not square
(2 + ω) ^ 7 → 6 + 0 ω      // by modular exponentiation (1)
                            // 6 and (13 - 6) = 7 are solutions
(6 * 6) % 13 → 10           // = n . Checked.
</pre>

'''Task'''

Implement the above. 

Find solutions (if any) for 
* n = 10 p = 13
* n = 56 p = 101
* n = 8218 p = 10007
* n = 8219 p = 10007
* n =  331575 p =  1000003


'''Extra credit'''

* n     665165880     p     1000000007    
* n     881398088036     p     1000000000039    
* n  =  34035243914635549601583369544560650254325084643201     p  = 10^50 + 151   	

See also:
* [[Modular exponentiation]]


(require 'struct)
(require 'types)

;; test equality mod p
(define-syntax-rule (mod= a b p) 
	 (zero?  (% (- a b) p)))

(define (Legendre a p)  
	 (powmod a (/ (1- p) 2) p))

;; arithmetic in Fp² 
(struct Fp² ( x y ))
;; a + b
(define (Fp²-add Fp²:a Fp²:b p ω2)
	(Fp² (% (+ a.x b.x) p) (% (+ a.y b.y) p)))
;; a * b
(define (Fp²-mul Fp²:a Fp²:b p ω2) 
	(Fp² (% (+ (* a.x b.x) (* ω2 a.y b.y)) p) (% (+ (* a.x b.y) (* a.y b.x)) p)))

;; a * a	
(define (Fp²-square Fp²:a p ω2)
	(Fp² (% (+ (* a.x a.x) (* ω2 a.y a.y)) p) (%  (* 2 a.x a.y)  p)))


;; a ^ n
(define (Fp²-pow Fp²:a n p ω2)
	(cond 
	((= 0 n) (Fp² 1 0))
	((= 1 n) (Fp² a.x a.y))
	((= 2 n) (Fp²-mul a a p ω2))
	((even? n) (Fp²-square (Fp²-pow a (/ n 2) p ω2) p ω2))
	(else (Fp²-mul a (Fp²-pow a (1- n) p ω2) p ω2))))

;; x^2 ≡ n (mod p) ?
(define (Cipolla n p) 
;; check n is a square
	(unless (= 1 (Legendre n p)) (error "not a square (mod p)" (list n p)))
;; iterate until suitable 'a' found
	(define a  
		(for ((t (in-range 2 p))) ;; t = tentative a
		  #:break (= (1- p)  (Legendre (- (* t t) n) p)) => t 
		))
	(define ω2 (- (* a a) n))
	;; (writeln 'a-> a 'ω2-> ω2 'ω-> 'ω)
	;; (Fp² a 1) = a + ω
	(define r   (Fp²-pow (Fp² a 1) (/ (1+ p) 2) p ω2))
	;; (writeln 'r r)
	(define x  (Fp²-x r))
	(assert (zero? (Fp²-y r))) ;; ω has vanished ?
	(assert (mod= n (* x x) p)) ;; checking the result
	(printf "Roots of %d are (%d,%d)  (mod %d)" n  x  (% (- p x) p) p))
	
	
	
(Cipolla 10 13)
(Cipolla 56 101)
(Cipolla 8218 10007)
(Cipolla  331575   1000003)



(define (Cptest p)
	(set! p  (next-prime p))
	(define n
	(for ((a (in-range (- p (random p )) 2 -1))) #:continue (square? a) #:break (= 1 (Legendre a p)) => a))
	(writeln 'n n 'p p)
	(define-values (r1 r2) (Cipolla n p))
	(writeln 'r1 r1 'r2 r2)
	(writeln 'ck (% (* r1 r1) p) (% (* r2 r2) p)))
	

;; modular exponentiation

 (define (xpowmod base exp mod)
 (define result 1)
 (while ( !zero? exp)
 	(when (odd? exp) (set! result (% (* result base) mod)))
 	(/= exp 2)
 	(set! base (% (* base base) mod)))
 	result)
 	
(define a 2988348162058574136915891421498819466320163312926952423791023078876139)
(define b 2351399303373464486466122544523690094744975233415544072992656881240319)
(define m 1e40)

(define (tr p)
(for ((a (in-range (- p (random p )) 2 -1)) (i 20)) (write a)))

(define (tt p (r))
(for ((i 20)) 
(set! r (random p))
(writeln p r (- p r))))

<pre>
Copying the Wikipedia example

Let ω² = -6 , p = 13 ;
Compute (2 + ω)^7 

(2 + ω)^2 = 4 + 4 ω - 6 = -2 + 4 ω
(2 + ω)^4 = (-2 + 4 ω)^2 = -1 - 3 ω
(2 + ω)^6 = (-2 + 4 ω) * ( -1 - 3 ω) = 9 + 2 ω
(2 + ω)^7 = (9 + 2 ω) * (2 + ω) = 6  + 0 ω = 6 
</pre>

	