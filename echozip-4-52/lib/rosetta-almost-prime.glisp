;; http://rosettacode.org/wiki/Almost_prime

(require 'sequences)

(define (almost-prime? p k)
	(= k (length (prime-factors p))))
	
(define (almost-primes k nmax)
	(take (filter (rcurry almost-prime? k) [2 ..]) nmax))
	
(define (task (kmax 6) (nmax 10))
	(for ((k [1 .. kmax]))
		(write 'k= k '|)
		(for-each write (almost-primes k nmax))
		(writeln)))
		
		
		
(require match)
(require 'bigint)

(define-syntax-rule (: v i) (vector-ref v i))
(reader-infix ':)

;; comb/almost
(define target   (* (expt 2 497) 3 17 347)) ;; DBG 

(define cprimes (list->vector (primes 10000)))


(define (almost-next pmax k c p)
(define almost-prime #f)
(define cp 0)

		(for ((i (in-range (1- k) -1 -1)))
		
			(vector-set! c i (1+ [c : i]))
			(set! cp [cprimes : [c : i]])
			(vector-set! p i (if (> i 0) (* [ p : (1- i)] cp) cp))
			
			(when (< [p : i) pmax)
				(set! almost-prime
				(and
					(for ((j (in-range (1+ i) k)))
						(vector-set! c j [c : i])
						(vector-set! p j (*  [ p : (1- j)] cp))
						#:break (>= [p : j] pmax) => #f
						)
					[p  : (1- k)]
			
			) ;; // and
			) ;; set!
			) ;; when
			#:break almost-prime 
			) ;; // for i
		almost-prime )

(define (num-rep n k) (Cnp (1- (+ n k)) k))

(define (almost-primes k nmax)
		(define base (expt 2 k))
		(define pmax (* base nmax))
		(define c (make-vector k #0))
		(define p (build-vector k (lambda(i) (expt #2 (1+ i)))))
		
		(cons base
		(for/list 
			((almost-prime (in-producer almost-next pmax k c p )))
			almost-prime)))
			
(take (drop (list-sort < (almost-primes 500 10000)) 10000 ) 4)
		



;; comb with repetitions
;;(comb/rep '(0 1 2 3) 3)
;;[6]→ ((0 0 0) (0 0 1) (0 0 2) (0 0 3) (0 1 1) (0 1 2) (0 1 3) (0 2 2) (0 2 3) (0 3 3) (1 1 1) (1 1 2) (1 1 3) (1 2 2) (1 2 3) (1 3 3) (2 2 2) (2 2 3) (2 3 3) (3 3 3))

(combinations/rep '(iced jam plain) 2)
[6]→ ((iced iced) (iced jam) (iced plain) (jam jam) (jam plain) (plain plain))


(define (comb/rep nums k)
	(cond
	[(null? nums) null]
	[(<= k 0) null]
	[(= k 1) (map list nums)]
	[else 
		(for/fold (acc null) ((anum nums))
		(append acc
	  		(for/list ((xs (comb/rep nums (1- k))))
	  		#:continue (< (first xs) anum)
	  		(cons anum xs))))]))
	  		

(map (curry list-permute '(iced jam plain)) (comb/rep (iota 3) 2))

	