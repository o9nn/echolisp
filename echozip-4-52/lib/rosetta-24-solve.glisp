;; http://rosettacode.org/wiki/Parsing/Shunting-yard_algorithm#EchoLisp    infix to RPN
;; http://rosettacode.org/wiki/Parsing/RPN_calculator_algorithm#EchoLisp   Eval RPN

;; http://rosettacode.org/wiki/24_game/Solve

The program takes n numbers - not limited to 4 - builds the all possible legal rpn expressions according to the game rules,  and evaluates them. Time saving : 4 5 + is the same as 5 4 + . Do not generate twice. Do not generate expressions like 5 6 * + which are not legal.

<lang scheme>
;; use task [[RPN_to_infix_conversion#EchoLisp]] to print results
(define (rpn->string rpn) 
    (if (vector? rpn)
        (infix->string (rpn->infix rpn)) 
        "ðŸ˜¥ Not found"))


(string-delimiter "")
(define OPS #(*  + - // )) ;; use float division
(define-syntax-rule (commutative? op) (or (= op *) (= op +)))

;; ---------------------------------
;; calc rpn -> num value or #f if bad rpn
;; rpn is a vector of ops or numbers
;; ----------------------------------
(define (calc rpn)
(define S (stack 'S))
    (for ((token rpn))
        (if (procedure? token)
            (let [(op2 (pop S)) (op1 (pop S))]
                (if (and op1 op2)
                (push S (apply token (list op1 op2))) 
                (push S #f))) ;; not-well formed
        (push S token ))
        #:break (not (stack-top S)))
    (if (= 1 (stack-length S)) (pop S) #f))
 
;; check for legal rpn -> #f if not legal
(define (rpn? rpn)
(define S (stack 'S))
    (for ((token rpn))
        (if (procedure? token)
            (push S (and (pop S) (pop S)))
            (push S token ))
        #:break (not (stack-top S)))
    (stack-top S))
 
;; --------------------------------------
;; build-rpn : push next rpn op or number
;; dleft is number of not used digits
;; ---------------------------------------
(define count 0)

(define (build-rpn into: rpn  depth  maxdepth  digits  ops dleft target &hit )
(define cmpop #f)
    (cond 
;; tooo long
    [(> (++ count) 200_000) (set-box! &hit 'not-found)]
;; stop on first hit
    [(unbox &hit) &hit]
;; partial rpn must be legal
    [(not (rpn? rpn)) #f]
;; eval rpn if complete
    [(> depth maxdepth) 
        (when (= target (calc rpn))  (set-box! &hit rpn))]
;;  else, add a digit to rpn
    [else
    [when (< depth maxdepth)  ;; digits anywhere except last
        (for [(d digits) (i 10)] 
                #:continue (zero? d)
                (vector-set! digits i 0) ;; mark used
                (vector-set! rpn depth d)
                (build-rpn rpn (1+ depth) maxdepth  digits  ops (1- dleft)  target &hit)
                (vector-set! digits i d)) ;; mark unused        
                ] ;; add digit
;; or,  add an op
;; ops anywhere except  positions 0,1
    [when  (and (> depth 1) (<= (+ depth dleft) maxdepth));; cutter : must use all digits
    (set! cmpop
        (and (number? [rpn (1- depth)])
             (number? [rpn (- depth 2)]) 
              (> [rpn (1- depth)]  [rpn (- depth 2)])))
    
        (for [(op ops)]
            #:continue (and cmpop (commutative? op)) ;; cutter : 3 4 + ===  4 3 +
            (vector-set! rpn depth op)
            (build-rpn rpn (1+ depth) maxdepth  digits  ops dleft target &hit)
            (vector-set! rpn depth 0))] ;; add op
        ] ; add something to rpn vector
        )) ; build-rpn

;;------------------------  
;;gen24 : num random numbers
;;------------------------
(define (gen24 num maxrange)
     (->> (append (range 1 maxrange)(range 1 maxrange)) shuffle (take num)))

;;-------------------------------------------
;; try-rpn : sets starter values for build-rpn
;;-------------------------------------------
(define (try-rpn digits target)
    (set! digits (list-sort > digits)) ;; seems to accelerate things
    (define rpn (make-vector (1- (* 2 (length digits)))))
    (define &hit (box #f))
    (set! count 0)
    
    (build-rpn rpn starter-depth: 0  
        max-depth: (1- (vector-length rpn))
         (list->vector digits)
         OPS
        remaining-digits: (length digits)
        target &hit )
    (writeln  target '=   (rpn->string (unbox &hit)) 'tries= count))

;; -------------------------------
;; (task numdigits target maxrange)
;; --------------------------------
(define (task (numdigits 4) (target 24) (maxrange 10))
        (define digits (gen24 numdigits maxrange))       
        (writeln digits 'â†’ target)
        (try-rpn digits target))
</lang>         

{{out}}
<pre>
(task 4) ;; standard 24-game
(7 9 2 4)     â†’     24    
24     =     9 + 7 + 4 * 2     tries=     35    

(task 4)
(1 9 3 4)     â†’     24    
24     =     9 + (4 + 1) * 3     tries=     468   
 
(task 5 ) ;; 5 digits
(4 8 6 9 8)     â†’     24    
24     =     9 * 8 * (8 / (6 * 4))     tries=     104    

(task 5 100) ;; target = 100
(5 6 5 1 3)     â†’     100    
100     =     (6 + (5 * 3 - 1)) * 5     tries=     10688    

(task 5 (random 100))
(1 1 8 6 8)     â†’     31    
31     =     8 * (6 - 1) - (8 + 1)     tries=     45673    

(task 6 (random 100)) ;; 6 digits
(7 2 7 8 3 1)     â†’     40    
40     =     8 / (7 / (7 * (3 + 2 * 1)))     tries=     154    

(task 6 (random 1000) 100) ;; 6 numbers < 100 , target < 1000
(19 15 83 74 61 48)     â†’     739    
739     =     (83 + (74 - (61 + 48))) * 15 + 19     tries=     29336    

(task 6 (random 1000) 100) ;; 6 numbers < 100
(73 29 65 78 22 43)     â†’     1    
1     =     ðŸ˜¥ Not found     tries=     200033  

(task 7 (random 1000) 100) ;; 7 numbers < 100
(7 55 94 4 71 58 93)     â†’     705    
705     =     94 + 93 + 71 + 58 + 55 * 7 + 4     tries=     5982 

(task 6 (random -100) 10) ;; negative target
(5 9 7 3 6 3)     â†’     -54    
-54     =     9 * (7 + (6 - 5 * 3)) * 3     tries=     2576         
</pre>