
http://rosettacode.org/wiki/Sorting_algorithms/Selection_sort#Racket



;; recursive version (adapted from Racket)
(lib 'list) ;; list-delete
(define (sel-sort xs  (x0))
	(cond 
		[(null? xs) null]
		[else (set! x0 (apply min xs))
			  (cons x0 (sel-sort (list-delete xs x0)))]))

(sel-sort (shuffle (iota 13)))
    → (0 1 2 3 4 5 6 7 8 9 10 11 12)
    
;; straightforward and more efficient implementation using list-swap!
(define (sel-sort list)
		(maplist (lambda( L) 
			(first (list-swap! L (first L) (apply min L )))) list))
			
(sel-sort (shuffle (iota 13)))
    → (0 1 2 3 4 5 6 7 8 9 10 11 12)
    

;; sort an array in place
(define (sel-sort a  (amin) (imin))
	(define ilast (1- (vector-length a)))
	(for [(i ilast)]
		(set! amin [a (setv! imin i)]) ;; imin := i , amin := a[imin]
		(for [(j (in-range (1+ i) (1+ ilast)))]
			(when (< [a j] amin) (set! amin [a (setv! imin j)])))
		(vector-swap! a i imin))
		a )
	
(define a #(9 8 2 6 3 5 4))
(sel-sort a)
    → #( 2 3 4 5 6 8 9)		
