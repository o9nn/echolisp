;; brauer chains 
;; https://oeis.org/A079301
;; http://math-www.uni-paderborn.de/~aggathen/Publications/ott01.pdf

An '''addition chain'''  of length r for n is a sequence 1 = a(0) < a(1) < a(2) ... < a(r) = n , such as a(k) = a(i) + a(j) ( i < k and j < k , i may be = j) . Each member is the sum of two earlier memebers, not necessarily distincts.

A Brauer chain for n is an addition chain where a(k) = a(k-1) + a(j) with j < k. Each member uses the previous member as a summand.

We are interested in chains of minimal length l(n).

'''Task'''

For each n in {7,14,21,29,32,42,64} display in l(n), the count of Brauer chains of length l(n), an example of such a Brauser chain, the count of non-brauer chains of length l(n), an example of such a chain. (NB: counts may be 0 ).

Extra-credit: Same task for n in {47,79, 191 , 382, 12509}

'''References'''
* OEIS sequences A079301, A079302. [https://oeis.org/A079301]
* Richard K. Guy - Unsolved problems in Number Theory - C6 - Addition chains.

'''Example'''
minimal chain length  l(19) = 6
brauer-chains(19) : 31 Ex: #( 1 2 3 4 8 11 19)
non-brauer-chains(19) : 2 Ex: #( 1 2 3 6 7 12 19)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; 2^n
(define exp2 (build-vector 32 (lambda(i)(expt 2 i))))

;; counters and results
(define-values (*minlg* *counts* *chains* *calls*) '(0 null null 0))

(define (register-hit chain lg  )
(define idx (if (brauer? chain lg) 0 1))
    (when (< lg *minlg*) 
        (set! *counts* (make-vector 2 0))
        (set! *chains* (make-vector 2  ""))
        (set! *minlg* lg))
    (vector+= *counts* idx 1)
    (vector-set! *chains* idx (vector->list chain)))
 
;; is chain a brauer chain ?        
(define (brauer? chain lg)
    (for [(i (in-range 1 lg))]
        #:break (not (vector-search* (- [chain i] [chain (1- i)]) chain)) => #f
        #t))
        
;; all min chains to target n (brute force)
(define (chains n chain  lg   (a)  (top) (tops null))
(++ *calls*)
(set! top [chain  lg])
    (cond 
    [(> *calls* 2000000) #f]
    [(> lg *minlg*) #f] ;; too long
    [(= n top) (register-hit chain lg)]  ;; hit 
    [(< n top) #f] ;; too big
    [(and (< *minlg* 32) (< (* top [exp2 (- *minlg* lg)]) n)) #f] ;; too small
    [else
    (for*  ([i (in-range lg -1 -1)] [j (in-range lg (1- i) -1)])      
          (set! a (+ [chain i] [chain j]))
          #:continue (<= a top) ;; increasing sequence
          #:continue (memq a tops) ;; prevent duplicates
          (set! tops (cons a tops))
          (vector-push chain a)
          (chains n chain  (1+ lg))
          (vector-pop chain))]))
          
(define (task n (minlg 0))
    (set!-values (*minlg* *calls*) '(Infinity 0 ))
    ;(set! *counts* (make-vector 2 0))
    ;(set! *chains* (make-vector 2 null))
    ;(unless (zero? minlg) (set! *minlg* minlg))
    (chains n (make-vector 1 1) 0)
    (printf "L(%d) = %d - brauer-chains: %d  non-brauer: %d  chains: %a %a  calls:%d" 
         n *minlg* [*counts* 0] [*counts* 1] [*chains* 0] [*chains* 1]  *calls*))

(for-each task {7 14 21 29 32 42 64})

[4]â†’ task
(task 191 11)
minimal chain length(191) : 11
brauer-chains(191) : 1689 Ex: #( 1 2 4 8 16 18 34 68 86 87 105 191)
non-brauer-chains(191) : 139 Ex: #( 1 2 4 8 16 18 34 68 86 87 104 191)
call: 2000040
(task 382 11)
minimal chain length(382) : 11
brauer-chains(382) : 1693 Ex: #( 1 2 4 5 9 14 23 46 92 184 198 382)
non-brauer-chains(382) : 139 Ex: #( 1 2 4 8 16 18 34 68 86 87 104 191)
call: 1098971




    