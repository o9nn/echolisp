#|
Class of 'big' rationals a/b
a & b are big integrs
|#
(require 'bigint)

(define-class Rational null ((a :initform #0) (b :initform #1)))
(define-method tostring  (Rational) (lambda (r) (format "%d / %d" r.a r.b)))
(define-method normalize (Rational) (lambda (r) ; // divide a and b by gcd
		(let ((g (gcd r.a r.b)) (oa r.a) (ob r.b))
			(set! r.a (/ r.a g)) (set! r.b (/ r.b g))
			(when (< r.b 0) (set! r.a ( - r.a)) (set! r.b (- r.b)))
#|
			(unless  (= (* oa r.b) (* ob r.a)) 
			 		(writeln  oa ob g r.a r.b  )
			 		(error g "bad gcd"))
|#
			r)))
			
(define-method initialize (Rational) (lambda (r) (normalize r)))
(define-method add (Rational) (lambda (r n)  ; + Rational number
			(normalize (Rational (+ (* (+ #0 n) r.b) r.a) r.b))))
(define-method add (Rational Rational) (lambda (r q) ; + Rational Rational
			(normalize (Rational (+ (* r.a q.b) (* r.b q.a)) (* r.b q.b)))))
(define-method sub (Rational Rational) (lambda (r q) 
			(normalize (Rational (- (* r.a q.b) (* r.b q.a)) (* r.b q.b)))))
(define-method mul (Rational Rational) (lambda (r q) 
			(normalize (Rational  (* r.a q.a)  (* r.b q.b)))))
(define-method mul (Rational) (lambda (r n) 
			(normalize (Rational  (* r.a (+ #0 n))  r.b ))))
(define-method div (Rational Rational) (lambda (r q) 
			(normalize (Rational  (* r.a q.b)  (* r.b q.a)))))
(define-method inv (Rational) (lambda (r) 
			 (normalize (Rational r.b r.a))))


;; Bernouilli numbers
;; http://rosettacode.org/wiki/Bernoulli_numbers
(define A (make-vector 100 0))

(define (B n)
(for ((m (1+ n))) 
	(vector-set! A m (Rational #1 (+ #1 m)))
	(for ((j (in-range m 0 -1)))
	  (vector-set! A (1- j) 
	  	(mul (sub (vector-ref A (1- j)) (vector-ref A j)) j))))
	  (vector-ref A 0))





									



