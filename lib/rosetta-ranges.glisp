

;; parsing [spaces][-]digit(s)-[-]digit(s)[spaces]
(define R (make-regexp "^ *(\-?\\d+)\-(\-?\\d+) *$" ))

;; the native (range a b) is [a ... b[
;; (range+ a b) is [a ... b]
(define (range+ a b)
	(if (< a b) (range a (1+ b))
	(if (> a b) (range a (1- b) -1)
	(list a))))
	
;; in : string : "number" or "number-number"
;; out : a range = list of integer(s)
(define (do-range str) 
(define from-to (regexp-exec R str)) ;; "1-3" --> ("1" "3")
(if from-to 
    (range+ (string->number (first from-to)) (string->number (second from-to)))
    (list (string->number str))))
    
(define (ranges str)
    (apply append (map do-range (string-split str ","))))
	

(define task "-6,-3--1,3-5,7-11,14,15,17-20")
(ranges task)


;; http://rosettacode.org/wiki/Range_extraction#Common_Lisp
(define task '(0 1 2 4 6 7 8 11 12 14 15 16 17 18 19 20 21 22 23 24 25 27 28 29 30 31 32 33 35 36 37 38 39))

(define (group-range item acc)
(if
    (or (empty? acc) (!= (caar acc) (1- item)))
      (cons (cons item item) acc)
      (begin  (set-car! (car acc) item) acc)))
      
;; (foldl group-range () task)
      
(define (range->string range)
(let ((from (rest range)) (to (first range)))
		(cond
		((= from to) (format "%d " from))
		((= to (1+ from))  (format "%d, %d " from to))
		(else (format "%d-%d " from to)))))
		
(string-join (map range->string  (reverse (foldl group-range () task))) ",")



