<!DOCTYPE html>
<html>
<head>

  	<meta NAME = 'description' CONTENT = "EchoLisp Reference manual : Lisp Scheme in your browser" >
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

	<META NAME="keywords"  CONTENT="EchoLisp,reference,lisp,scheme,oulipo,environment,programming,webapp, racket,javascript,recursion,language,langage,echolalie, georges, brougnard,tramu,  cruches,zen">
	<META NAME="AUTHOR" CONTENT="www.echolalie.com Jacques Tramu">
	<META HTTP-EQUIV="CONTENT-LANGUAGE" CONTENT="fr">
	<META NAME="COPYRIGHT" CONTENT="(c) 2014,Georges Brougnard">
	<META NAME="Identifier-URL" CONTENT="http://www.echolalie.org/echolisp/">
	<META NAME="document-class" CONTENT="Published">
	<META NAME="document-rights" CONTENT="Private">
	<META HTTP-EQUIV="Ranking" CONTENT="High, TOP">
	<META NAME="Reply-to" CONTENT="echolalie@echolalie.com">
	<META NAME="robots" CONTENT="index, follow">
	<META NAME="Distribution" CONTENT="GENERAL, GLOBAL, ALL">
	<meta http-equiv="robots" CONTENT="all">
	
	<meta name="viewport" content="width=device-width, initial-scale=1 maximum-scale=1 user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
	<link type="text/css" rel = 'stylesheet' href="./css/doc.css"  media = 'screen'/>

    <title>EchoLisp functions reference</title>

<script>
var _STYLE = 7;
var _STYLE_SHEET = null ;
var _STYLES = [
		"pre i { background-color : #f0f0f0; color: Black; font-style : normal;}",
		"pre i { background-color : #e8e8e8; color : Black ;font-style : normal;}",
		"pre i { background-color : #ffffff; color : Black; font-style : italic;}",
		"pre i { background-color : #ffffff; color : Black; font-style : normal;}", // no style
		"pre i { background-color : #ffffff; color : Brown; font-style : normal;}", 
		"pre i { background-color : #ffffff; color : OrangeRed; font-style : normal;}",
		"pre i { background-color : #ffffff; color : RoyalBlue; font-style : normal;}",
		"pre i { background-color : #ffffff; color : SlateGray; font-style : normal;}",
		"pre i { background-color : #ffffff; color : #606060; font-style : normal;}",
		"pre i { background-color : #ffffff; color : LightSlateGray; font-style : normal;}",
		"pre i { background-color : #ffffff; color : SteelBlue; font-style : normal;}",
		"pre i { background-color : #ffffff; color : Teal; font-style : normal;}",
		];
function doStyle(n) {
		if(_STYLE_SHEET) {
		var sheetParent = _STYLE_SHEET.parentNode;
		sheetParent.removeChild(_STYLE_SHEET);
		}
		var numStyles = _STYLES.length - 1 ;
		_STYLE += n ; 
		if(_STYLE > numStyles) _STYLE = 0; // rotate
		if(_STYLE < 0 ) _STYLE = numStyles; // rotate
		
		_STYLE_SHEET  = document.createElement('style') ;
		_STYLE_SHEET.innerHTML = _STYLES[_STYLE];
		document.body.appendChild(_STYLE_SHEET);
}

function codeKeyPress(e) {
        if (typeof e === 'undefined' && window.event) { e = window.event; }
        if ( e.ctrlKey || e.altKey || e.metaKey) return ;
 		var key = e.charCode;
 		var label = String.fromCharCode(key) ;
 		switch(label) {
 		case "+": doStyle(1); return;
 		case "-" :doStyle(-1); return;
 		default : break;
 		}
 		var elem = document.getElementById(label);
 		if(elem) {
 				elem.scrollIntoView();
 				// window.scrollBy(0,-112);
 				}
 		}
</script>
</head>
<body>


   
<center>
<a href= "http://www.echolalie.org/echolisp"> 
<img id = "logo" class="logo"  width = "300" height = "300" src = "./images/logo.png" alt = "EchoLisp" 
title  = "EchoLisp - Click to launch, if not already none" >
</a>
</center>
    
<h1>EchoLisp Reference Manual</h1>

<span id = "tocbutton" title = "Jump to the table of contents" >
<!--a href= "#toc"><img src= "./images/toc.png" width= "32" height = "32"> </a> -->
<a href = "#toc">ğŸ“š</a>
</span>

<span id = "palette" title = "Change style for code snippets">
<span onclick= "doStyle(1)" style="cursor:pointer;font-size:24px">ï¸ğŸ¨&nbsp;</span>
</span>

<span id = "alphabutton" title = "Jump to the alphabetical list" >
<a href= "#alpha"><img src= "./images/alpha.png" width= "24" height = "24"></a>
</span>

<span id = "mail" title = "Mail to the EchoLisp team" >
<a href="mailto:echolalie@echolalie.com?subject=EchoLisp">ğŸ“­&nbsp;</a>
</span>


<h2 id = "toc"><img src= "./images/toc.png" width= "50" height = "50"> Table of contents</h2>

<ul>
<li><img src= "./images/alpha.png" width= "20" height = "20"> <a href="#alpha">Alphabetical list</a>.<small> <b>Usage: Click onto the &alpha; -alpha- letter, or hit (keyboard) the first letter you want to go to</b></small>.</li>
<br>
<li><a href="#general">General</a></li>
<li><a href="#language">Language</a></li>
<li><a href="#help">On-line help</a></li>
<li><a href="#boolean">Boolean expressions</a></li>
<li><a href="#predicates">Predicates</a></li>
<li><a href="#compare">Comparisons - equal </a></li>
<li><a href="#calculus">Calculus</li>
<ul>
<li><a href="#arithmetic">Integer numbers</a></li>
<li><a href="#rational">Rational numbers</a></li>
<li><a href="#complex">Complex numbers</a></li>
<li><a href="#maths">Math functions</a></li>
</ul>
<li><a href="#lists">Lists</a></li>
<li><a href="#functions">Functions, aka procedures</a></li>
<li><a href="#lambda">Lambda - Function definition</a></li>
<li><a href="#let">Local bindings - let </a></li>
<li><a href="#environment">Environments</a></li>
<li><a href=#closure>Closures</a></li>
<li><a href="#assignment">Assignment</a></li>
<li><a href="#maps">Mapping and folding</a></li>
<li><a href="#vectors">Vectors</a></li>
<li><a href="#strings">Strings</a></li>
<li><a href="#control">Flow control</a></li>
<ul>
<li><a href="#control">If, cond</a></li>
<li><a href="#iterations">Iterations : for</a></li>
<li><a href="#catch">Catch and throw</a></li>
</ul>
<li><a href="#read">Read operations</a></li>
<li><a href="#write">Write operations</a></li>
<li><a href="#io">Input / Output</a></li>
<ul>
<li><a href="#stdin">stdin: keyboard, meta-keys</a></li>
<li><a href="#stdout">stdout</a></li>
<li><a href="#load">Local and server files</a></li>
<li><a href="#local">Local storage - Symbols and (key value) </a></li>
<li><a href="#packages">Local storage - Packages</a></li>
</ul>
<li><a href="#reader">Lisp reader</a></li>
<li><a href="#write">Lisp writer</a></li>
<li><a href="#errors">Errors</a></li>
<li><a href="#debug">Debugging</a></li>

<li>More objects types</li>
<ul>
<li><a href="#dates">Dates</a></li>
<li><a href="#sets">Sets</a></li>
<li><a href="#stacks">Stacks</a></li>
<li><a href="#boxes">Boxes</a></li>
<li><a href="#delay">Promises</a></li>
<li><a href= "#streams">Streams</a></li>
<li><a href="#plist">Property lists - Hash</a></li>
<li><a href="#alist">Association lists</a></li>
</ul>
<li><a href="#style">CSS styles</a></li>

<br>
<li><a href="#quoting">Quoting</a></li>
<li><a href="#syntax">Syntax rules</a></li>
<br>

<li>ğŸ“–  <a href="#lib">Libraries</a>
<ul>
<li><a href="#amb.lib">Amb library</a></li>
<li><a href="#compile.lib">Compile library</a></li>
<li><a href="#list.lib">List library</a></li>
<li><a href="#hash.lib">Hash library</a></li>
<li><a href="#heap.lib">Heap library</a></li>
<li><a href="#interfacelib">Interface library</a></li>
<li><a href="#sql.lib">SQL library</a></li>
<li><a href="#struct.lib">Structure library</a></li>
<li><a href="#match">Match library</a>  ğŸ“Œ V2.22</li>
<li><a href="#gloops.lib">Gloops library</a></li>
<li><a href="#plot.lib">Plot Library</a></li>
<ul>
<li><a href="#data-series">Time/Data series</a></li>
</ul>
<li><a href="#plot-3d.lib">Plot 3D Library (&beta;)</a></li>
<li><a href="#types.lib">Types Library</a></li>
<li><a href="#vlib.lib">Typed vectors library</a></li>
<li><a href="#math.lib">Math Library</a></li>
<li><a href="#matrix.lib">Matrix Library</a></li>
<li><a href="#bigint.lib">Big integers Library</a></li>
<li><a href="#web.lib">Web Library</a></li>
<li><a href="#sequences.lib">Iterators/Sequences Library</a>  ğŸ“ŒğŸ“ŒğŸ“Œ </li>
<li><a href="#tasks.lib">Tasks library</a></li>
<li><a href="#timer.lib">Timer library</a></li>
<li><a href="#tree.lib">Tree library</a></li>
<ul>
<li><a href="#bintree.lib">Binary Trees</a></li>
</ul>
<li><a href="#graph.lib">Graph library</a></li>
<li><a href="#json.lib">JSON library</a></li>
<li><a href="#idb.lib">Indexed Data base library</a></li>
<li><a href="#words.lib">Words Library</a></li>
<li><a href="#audio.lib">Audio Library</a></li>
</ul>
<br>
<li><img src= "./images/alpha.png" width= "20" height = "20"> <a href="#alpha">Alphabetical list</a>.<small> <b>Usage: Click onto the &alpha; -alpha- icon located in the screen right margin, or hit (keyboard) the first letter you want to go to</b></small>.
</small></li>

<li><img src="./images/cmd-f-key.png" width = 40 height=30">: You may also use the find function of your browser to search for something in this help document :  Cmd-F or Ctrl-F keys.</li>


</ul>

<h2>Introduction</h2>
<p>
<a href="http://www.echolalie.org/echolisp"  title = "        CLICK to LAUNCH" target= "_blank">
EchoLisp</a> is (yet another one) implementation of Lisp, not very far from Scheme, as far as syntax and concepts are concerned. For the novice reader, it is recommended to read an introduction to Scheme or Lisp before browsing this reference manual. 
<br>
EchoLisp offers lexical scoping, tail call elimination, access to the browser local storage, a graphical library, complex numbers, large integers, a JSON library, {sets}, streams, syntax rules, background operations for complex drawings, CSS styled objects, rational numbers, good performances, a compiler, auto-completion, a notebook/worksheets interface and many more.
<br>
Last, and not the least, a complete on-line help system is available. See <b>usage</b>, <b>apropos</b> and <b>help</b> functions in the <a href="#help">help</a> chapter.
<br>
You can find code examples in the <a href="http://rosettacode.org/wiki/EchoLisp">Rosetta Code</a>  wiki.
</p>
<p> <img src="https://abs.twimg.com/emoji/v1/72x72/1f1eb-1f1f7.png" width="18" height="18" alt = "French flag" /> EchoLisp est une mise en oeuvre de Lisp, utilisant la syntaxe et les concepts de Scheme. Le lecteur novice trouvera <a href="http://kiwi.emse.fr/LANG/cours-scheme.pdf" target="_blank">ici en franÃ§ais</a> une excellente introduction Ã  Scheme, avant de naviguer dans ce manuel de rÃ©fÃ©rence.
<br>
EchoLisp fournit entre autres l'accÃ©s Ã  la mÃ©moire persistante du navigateur, une librairie graphique, le calcul sur nombres complexes ou les grands nombres , une librairie JSON, des {ensembles}, des streams, des 'rÃ¨gles de syntaxe' - macro Ã©laborÃ©es -  Ã  la Scheme, des fonctions qui travaillent en arriÃ¨re-plan, des styles CSS, des fonctions de calcul sur les fractions, de bonnes performances, la compilation de fonctions, l' auto-complÃ©tion pour faciliter la saisie.
<br>
Enfin, et non le moindre, un systÃ¨me d'aide en ligne est disponible. Voir les fonctions <b>usage</b>, <b>apropos</b> et <b>help</b>  dans le chapÃ®tre <a href="#help">help</a>.
<br>
Des exemples de code sont proposÃ©s dans le wiki <a href="http://rosettacode.org/wiki/EchoLisp">Rosetta Code</a>.
</p>

<h3>Offline operations</h3>
<p>You can run EchoLisp as an inline WebApp - URL <a href="http://www.echolalie.org/echolisp" target = "_blank" >http://www.echolalie.org/echolisp</a>, or download and decompress the <a href="http://www.echolalie.org/echolisp/echolisp.zip">echolisp.zip</a> file. Click onto the index.html file in the directory used for extraction to locally run EchoLisp.
<br>
<center>
<img src = "./images/directory.png">
</center>

<h2 id="general">General</h2>

<ul>
<li>Launch EchoLisp : <a href="http://www.echolalie.org/echolisp" target = "_blank" > <img src="./images/b4.jpg"  alt="EchoLisp" width="32" wheigh="32" title= "          CLICK to launch"></a></li>
<li>Type-in some expression, eg. <i>(+ 42 624)</i> , and press the Shift-Enter keys, or click the <span style="border : 1px solid black">â—ï¸</span> - eval - button to evaluate it.</li>
</ul> 

<h3>Worksheet</h3>
<center>
<img src = "./images/screen.png">
</center>

<p>
EchoLisp uses worksheets stored in a notebook. Worksheets have cells. Each cell has an input field - named stdin -,  an output field - named stdout -, and an optional plotter field (an HTML canvas). Functions and buttons are provided to create/open/save worksheets in the notebook (browser local storage), add/show/hide/remove cells in a worksheet.
<br>
Cells come in two flavors :
<h4> ğŸ“   : console cell : stdin is cleared after each evaluation, and results are appended into stdout. Console cells are the usual place to call and try functions with different parameters values, evaluate one-shot expressions, etc.</h4>
<h4> ğŸ“Œ  : standard cell : stdin is not cleared , and stdout is cleared before each result display. Standard cells are the usual place to input things to remember :  define functions, edit functions definitions, load files, etc.</h4>

<p>You can toggle a cell type by pressing the ğŸ“   or ğŸ“Œ  button. Cells are activated  - given focus - by clicking inside the input field, or pressing a cell button.
</p>

<h3>Worksheet buttons and functions</h3>
<h4 id='notebook'>(<b>notebook </b>) â› list of all known worksheets names</h4>
<h4 id='worksheet-open'>(<b>worksheet-open </b><i>name-string </i>) â› opens a work sheet. Same as  <span style="border : 1px solid black;color:blue">&nbsp;Open&nbsp;</span> button.</h4>
<h4 id='worksheet-save'>(<b>worksheet-save </b><i>name-string </i>) â› saves a work sheet. Same as  <span style="border : 1px solid black;color:blue">&nbsp;Save&nbsp;</span> button. Only the input fields contents are saved.</h4>
<h4 id='worksheet-remove'>(<b>worksheet-remove </b><i>name-string </i>) â› removes a work sheet from the notebook.</h4>
<br>
<h4><span style="border : 1px solid black;color:blue">&nbsp;Eval&nbsp;</span> Evaluates in sequence all the worksheet cells.</h4> 
<h4><span style="border : 1px solid black;color:blue">&nbsp;New&nbsp;</span> Opens a blank worksheet.</h4> 
<pre>
;; open a worksheet at loading time
<i>(define (preferences)
	(worksheet-open "sandbox"))</i>
</pre>


<h3>User interface</h3>
<h4 ><b>&#x23ce; Enter key</b> : new line</h4>
<h4 style="color:green"><b>&#x21E7;-&#x23ce;</b> Shift-Enter key : Evaluates input (same as â—ï¸  button) </h4>
<h4><b>ESC</b>ape key : clears a cell input & ouput areas. Same as <span style="border : 1px solid black"><b>x</b></span> button</h4>
<h4><b>&#x2326; suppr</b> : clears input area. Use <small>(suppr-key [#f|#t]) to toggle this behaviour. The default is #f : clearing disabled.</small></h4>
<br>
<h4> <span style="border : 1px solid black">â•</span> Adds a new cell</h4>
<h4> <span style="border : 1px solid black"><b>x</b></span> &nbsp;Clears the cell</h4>
<h4> <span style="border : 1px solid black">âŒ</span> Removes the cell </h4>

<br>
<h4><u>History of input expressions</u> (16 max). The following keys will "recall" input expressions : </h4>
<h4><b>&#x2196;</b> previous </h4>
<h4><b>&#x2198;</b> next</h4>
<h4><b>&#x219f;</b> first</h4>
<h4><b>&#x21a1;</b> last</h4>
<br>
<h4><u><b>&i</b> short-cut</u> â› evaluates result labelled [#i]</h4>
<pre>
<i>(+ 42 624)</i> 
            [0]â› 666
<i>1000</i>
            [1]â› 1000
<i>&1</i>
            [2]â› 1000
<i>(+ &1 &0 &1)</i>
            [3]â› 2666
<i>(* &3 &3)</i>
            [4]â› 7107556
<i>"simon "</i>
            [5]â› "simon "
<i>(string-append &5 "gallubert")</i>
            [6]â› "simon gallubert"
</pre>


<h4><u>Autocomplete</u></h4>
<p>The lisp reader procedure will try to present choices based on the first characters you type and the frequency of preferred symbols.</p>
<h4><b>&#x21e5; (Tab)</b> : Choose </h4>
<h4><b>ğŸ”½</b> : Next choice</h4>
<br>
<h4><u>Plotting</u></h4>
<br>
<h4> ğŸ“Š  : Show/hide a cell graph. <small>Requires the plot library : (lib 'plot.lib)</small> </h4>
<br>

<h4><span style="border : 1px solid black;color:blue">&nbsp;Load&nbsp;</span> button</h4>
<p>To read and eval an input file located on your disk. EchoLisp input files have the ".txt" or ".scm", or ".glisp" extension. See <a href ="./lib/todo.glisp">todo.glisp</a> for a simple application demo. On Mac OS X systems, TextWrangler is an excellent text editor to write syntax colored lisp source code. UTF-8 is the preferred encoding to use. </p>


<h2 id="help">On-line help</h2>
<h4 id='version'>(<b>version</b>) â› displays Echolisp version string  and returns the version number.
<br>
<h4 id='usage'>(<b>usage </b><i>function-id</i>) â› displays syntax and parameters types for <i>function</i> into the information text field. <i>Function-id</i> may be a native function or an user defined function with a documentation string.</h4>
<h4 id='us'>(<b>us </b><i>function-id</i>) â› short-cut for (usage ...) </h4>
<br>
<h4 id='apropos'>(<b>apropos </b><i>string</i>) â› all symbols matching string</h4>
<h4 id='apropos'>(<b>apropos </b><i>regexp</i>) â› all symbols matching regexp</h4>
<h4 id='ap'>(<b>ap </b><i>â€¦</i>) â› synonym for (apropos â€¦)</h4>
<br>
<h4 id='help'>(<b>help </b><i>symbol</i>) â› opens page (or browser tab) about symbol (*) </h4>
<h4 id='help'>(<b>help </b><i>letter</i>) â› opens alphabetical list at letter <i>letter</i> (*) </h4>
<h4 id='??'>(<b>?? </b><i>symbol</i>) â› synonym for (help symb) </h4>
<br>
<h4 id='info'>(<b>info </b><i>symbol description-string</i>) â› sets description for symbol</h4>
<h4 id='info'>(<b>info </b><i>symbol</i>) â› symbol description or #f if none.  Info strings are stored into the local data base - permanent local storage - inside the 'info' store. Use (info <i>symbol</i> null) to remove a description.</h4>
<p><small>(*) According to the browser, it may be necessary to click on the tab labelled 'EchoLisp functions reference' to activate the help page or to allow permission to open this page.</small></p>

<pre>
;; usage : procedures with syntax, and arguments types.
<i>(usage cons)</i>  â› 
	(<b>cons </b><i>item list<sub>1</sub></i>) (<b>cons </b><i>item null</i>) (<b>cons </b><i>item<sub>1</sub> item<sub>2</sub></i>)
;; (usage ...)  can look for substrings
<i>(us app)</i> â›  
	(<b>append </b><i>list<sub>1</sub> list<sub>2</sub>  â€¦ </i>)

;; apropos : list of procedures names with min-arity:max-arity
<i>(apropos vect)</i>  â› 
#(ğŸ‘€ for*/vector:2:n  ğŸ‘€ for/vector:2:n  ...  vector-sort!:2  vector:0:n  vector?:1  )
	
<i>(ap list)</i>  â› 
#(ğŸ‘€ for*/list:2:n  ğŸ‘€ for/list:2:n  alist?:1  circular-list:1:n ... vector->list:1  )

<i>(ap ".*filter$")</i> â›  #(filter:2  stream-filter:2  vector-filter:2 )

;; Opening help pages
<i>(help sin)</i>  â›   "sin:1" ; opens page (or tab) help.html#sin
<i>(help append)</i>  â›   "append:1:n" ; opens help.html#append

;; Symbol information (set by the user)
<i>(define (f x) (sin (cos (log x))))</i>  
<i>(info 'f "hairy function")</i> 
<i>(f 6)</i>  â›   -0.21741901623942123
<i>(info 'f)</i>  â›   "hairy function"
	
<i>(?? w)</i> ; try me

;; documentation string 
<i>(define (order a m)
	"multiplicative order : (order a m) â†’  n : a^n = 1 (mod m)"
	(assert (= 1 (gcd a m))...)
	
(usage order)</i>  
	â›   order : multiplicative order : (order a m) â†’  n : a^n = 1 (mod m)
</pre>

<h2 id="notation">Notations</h2>
<h4>(<b>function-id</b> <i> type<sub>1</sub> type<sub>2</sub> ...</i>)  â› result</h4>
<p>Call of function <b>function-id</b> with arguments which evaluate to values of type <i>type<sub>i</sub></i>, and evaluates to 'result'. Arguments types may be :
<ul>
<li> n : an integer</li>
<li> x : a real number</li>
<li> z : a complex number</li>
<li> q : a rational number</li>
<li> boolean : the symbols #t or #f</li>
<li> symb,symbol : a symbol</li>
<li> object-id : an identifier, i.e. a symbol</li>
<li> string : a string</li>
<li> regexp : a <a href="http://www.w3schools.com/js/js_regexp.asp">regular expression</a> string (javascript syntax)</li>
<li> list : a list of objects</li>
<li> v, vector : a vector</li>
<li> expr, expression : an expression</li>
<li> obj, object : any type among the above</li>
<li> [type<sub>1</sub> | type<sub>2</sub> | ... ] : choice between types<sub>i</sub></i></li>
<li> [ arg ] : optional argument</li>
</ul>
</p>

<h4>Naming conventions for symbols</h4>
<p>
<ul>
<li>type-from<b>-></b>type-to  denotes a conversion function between types</li>
<li>set-name-..<b>!</b>  denotes a function which modifies an object</li>
<li>type<b>?</b>  denotes a predicates which tests for <i>type</i></li>
<li>*name* denotes a global object</li>
</ul>
</p>

<pre>
;; Examples - this is a comment
;; User input (source code) style may be changed in this document. 
;; Click <span onclick= "doStyle(1)" style="cursor:pointer;font-size:24px">ï¸&nbsp;ğŸ¨&nbsp;</span>
;; Or hit the +/- keys.

<i>(here an example of user input)</i> 
   â› output ;; as computed and printed
</pre>

<h2 id= "language">Language</h2>
<h3 id = "special">Special characters</h3>
<p>
<ul>
<li> space separator, like end-of-line, tabulation</li>
<li> #  macro-character to read special objects, such as boolean, vectors, sets, keywords</li>
<li> &  macro-character , &n denotes - is bound to - the n-th top-level result</li>
<li> ( ) or [ ] lists delimiters</li>
<li> #{ }  input set delimiters</li>
<li> #| this is a multi line <br> comment |#</li>
<li> ;  introduces a comment, up to end of line</li>
<li> '  aka quote : the quote-mark prevents evaluation of the quoted object</li>
<li> .  dotted pair separator, or compound name separator</li>
<li> "  string delimiter</li>
<li> \  escape character, inside a string</li>
<li> ... ellipsis, inside a syntax pattern</li>
<li> :  reserved for types</li>
<li> _  reserved for pattern matching</li>
<li> %  reserved  for future use</li>
<li> @  reserved  for macros</li>
<li> ,  reserved  for macros</li>
<li> ->, ->> , => , ==>  reserved</li>
<li> | delimiter</li>
</ul>
</p>

<h3 id="symbolic">Symbolic expressions</h3>
<p>A symbolic expression - expression or expr for short - is either an atom or a list of zero or more expression(s).<br>
Atoms are the basic components of expressions, and may be of type symbol or identifier, number, boolean, string.
<ul>
<li> symbol name or identifier : A character (*) sequence, without spaces, not beginning nor ending with one of the special characters above, not including ':' .  Good practice : give a name like *something* to the global variables.</li>
<li> boolean : One of #t (true) or #f (false)</li>
<li> number : Optional sign [+|-] ,sequence of decimal digits. May include a . (decimal point) and be followed by a base 10 exponent e+n or e-n. Hexadecimal notation 0xhhh.. is also supported. "_" characters are ignored inside a number : 100_000_000 â› 100000000.</li>
<li> string : A character (*) sequence enclosed between quotes " . May include \c escape sequences, such as \n = new line, \" = quote.</li>
<br>
<li> identifiers ending with ":" are - up for now - ignored by the reader. They can serve as 'in-line' comments , eg. to give the type or meaning of a function argument. <small>(define (output-list: family-add input-list: family member-to-add: human) ...)</small> </li>
</ul>
</p>
<p><small>(*) May include Unicode characters, as supported by your browser</small>
</p>
<h4 id="gensym">(<b>gensym</b>)  â› generates a fresh new internal symbol, distinct from all other.</h4>
<h4 id="make-symbol">(<b>make-symbol</b> [<i>name|string</i>])  â› generates a fresh new symbol, prefixed by name.</h4>


<pre>
; valid symbols
	x let* Ã©lÃ©ment PI  aNoTher elvis! null + *  f_4 ;; space separated
	string->list jean-albert&antoinette
	á¼„Ï„Î¿Î¼Î¿Ï‚
	ğŸ˜-my-hidden-function-ğŸ˜
	other...
	*calendar*
	$Ã§Â§^jqrTs%
	&3
	NSRunLoop DefWindowProc PERFORM exit jmpne
	sort/name  a|filter
	<i>(make-symbol "cat")</i>  â› cat
	<i>(make-symbol "cat")</i>  â› cat_1
	
; numbers
	1 4e+10 -4 +666 0  ;; integer - exact 
	3.14 0.6789 ;; decimal - inexact 
	0xabcdef ;; hexadecimal - integer - exact
	3/4 ;; rational - exact
	1+i ;; complex - inexact
	100_000_000 : 100000000
	
; strings
	""
	"I am a string"
	"ğŸ“® You have mail"
	"A newline \n inside"
	
; lists or expressions
	()
	(cos PI) or [cos PI]
	(a b c ( d e f (g h [ i 333 ])))
	(ğŸ”´ âšªï¸ ğŸ”µ ( ğŸ”— â° ğŸ”— ))
	(+ 3 4)
	[(= a b) hit!!] or ((= a b) hit!!)
	("composite" 4555 log (tan PI))
	
; vectors
	#()
	#(1 2 3 5)
	#(ğŸ”µ "ğŸ”´ " ( 3 4) (+ simon antoinette))
	
; start-end delimiters
	(f |abc| ) â› (f | abc | )
	
; âŒ invalid symbols âŒ
	albert:antoinette
	_x
	#sharp
	@me
	
<small> ğŸ : This is not a tomato. This is a symbol, the name of which is the Unicode character 'ğŸ'.</small>
	
</pre>


<h3>Programs and Evaluation</h3>
<p>Every EchoLisp program is represented by a symbolic expression. The aim is to evaluate this expression. The evaluation rules are the following:
<ul>
<li>Constants (numbers, strings, boolean, etc.) evaluate to themselves.</li>
<li>Quoted objects : 'object or (quote object)  evaluate to object.</li>
<li>Symbols represent variables. The evaluation of a symbol returns its <b>binding</b> - value - in the current environment. Some symbols  - like sin, *, append, PI - have predefined values, and evaluate to native procedures(*) or constants. Some symbols have values which are user defined - (define year 2015) - or are bound by the context, like local variables in (let ...) expressions. The evaluation of a symbol without binding raises an error.</li>
<li>Lists represent functional applications. The list elements are first evaluated, and the first element of the list - operator or function - is applied to the rest of the list.</li>
<li>There are a few special forms which are lists beginning by a keyword like <b>if</b>, <b>when</b>, <b>define</b>, ... which do not evaluate all their arguments. These constructs are denoted by ğŸ‘€ . See the <a href=#alpha>alphabetical</a> list of functions for reference.</li>
<li id="void"><b>(void)</b> return a non-printable object</li>
</ul>
</p>
<p><small>(*) It is not possible, in the current implementation, to redefine a system predefined symbol. We use the words 'function' or 'procedure' to denote the same thing.</small></p>

<pre>
;; a simple program
<i>(define bonjour "Je te salue vieil OcÃ©an !")</i> ;; defining and binding the symbol 'bonjour'
<i>(display bonjour "color:blue")</i> ;; native function call, with two parameters
   â†’ <span style="color:blue">Je te salue vieil OcÃ©an !</span>

</pre>


<h2 id="boolean">Boolean expressions</h2>
<h3>"All which is not #f is #t" (Ludwig Wittgenstein)</h3>
<h4>Boolean value #t (true)</h4>
<h4>Boolean value #f (false)</h4>
<h4 id='boolean?'>(<b>boolean? </b><i>obj</i>) â› #t iff obj is #t or #f</h4>
<h4 id='not'>(<b>not </b><i>#f</i>) â› #t</h4>
<h4 id='not'>(<b>not </b><i>any-other-than-#f</i>) â› #f</h4>
<h4 id='or'>(<b>or </b><i>e<sub>1</sub> e<sub>2</sub> ..</i>) â› eval e<sub>1</sub> e<sub>2</sub> .. until e<sub>i</sub> not = #f and returns  e<sub>i</sub> or #f none true </h4>
<h4 id='or*'>(<b>or* </b><i>e<sub>1</sub> e<sub>2</sub> </i>) â› eval e<sub>1</sub>. If e<sub>1</sub> = #f or null or 0 or ""  : eval and returns  e<sub>2</sub>. Else returns  e<sub>1</sub>.  </h4>
<h4 id='and'>(<b>and </b><i>e<sub>1</sub> e<sub>2</sub> â€¦</i>) â› eval e<sub>1</sub> e<sub>2</sub>  .. stops on first e<sub>i</sub> =  #f; returns e<sub>last</sub> or #f is none true</h4>
<h4 id='xor'>(<b>xor </b><i>e<sub>1</sub> e<sub>2</sub></i>) â› eval e<sub>1</sub> and e<sub>2</sub>  and returns the exclusive or e<sub>1</sub> âŠ— e<sub>2</sub>  <small>Reminder: #t âŠ— #t =  #f âŠ— #f = #f , #t âŠ— #f = #f âŠ— #t = #t</small></h4>
<pre>
<i>#f</i>  â›   #f
<i>#t</i>  â›   #t
<i>(not #f)</i>  â›   #t
<i>(not 666)</i>  â›   #f
<i style="color:red">(not null)</i>  â›   #f

<i>(or 1 2 3 #f 4)</i>  â›   1
<i>(or (= 1 2) (= 1 3) 666)</i>  â›   666

<i>(and (write 1) (write 2) (write 3) #f 4)</i>  â› 1 2 3  #f
<i>(and 1 2 3 4)</i>  â›   4

<i>(not 0)</i>  â›   #f
<i>(not (not ()))</i>  â›   #t
<i>(not 'elvis)</i>  â›   #f
<i>(define dead #f)</i>  â›   dead
<i>(not dead)</i>  â›   #t

<i>(if #t "true" "false")</i>  â›   "true"
<i>(if #f "true" "false")</i>  â›   "false"
<i>(if null "true" "false")</i>  â›   "true"

<i>(boolean? #f)</i>  â›   #t
</pre>



<h2 id="calculus">Calculus</h2>
<h3 id ="operators">Operators</h3>
<h4 id="identity">(<b>identity </b><i>x</i>) â› x 
<h4>(<b>+ </b><i>a b c ...</i>) â› a + b + c + ... </h4>
<h4>(<b>- </b><i>a</i>) â› -a</h4>
<h4>(<b>- </b><i>a b c â€¦</i>) â› a - b - c - â€¦</h4>
<h4>(<b>* </b><i>a b c â€¦</i>) â› a * b * c â€¦</h4>
<h4>(<b>/ </b><i>a</i>) â› 1 / a</h4>
<h4>(<b>/ </b><i>a b c â€¦) â› a / (b * c * â€¦</i>)</h4>
<h4>(<b>// </b><i>a b</i>) â›  float result: same as (exact->inexact (/ a b))</h4>
<h4>(<b>% </b><i>a b</i>) â› a <a href="#modulo">modulo</a> b</h4>
<h4 id='min'>(<b>min </b><i>x y z â€¦</i>) â› minimum of</h4>
<h4 id='max'>(<b>max </b><i>x y z â€¦</i>) â› maximum of</h4>
<pre>
<i>(+ 42 666)</i>  â›  708
<i>(+ 1/2 67 1/3)</i>  â›  407/6
<i>(- 10 0.567)</i>  â›  9.433
<i>(- 444)</i>  â›  -444
<i>(* 1/7 7/9)</i>  â›  1/9
<i>(* 1 2 3 4 5 6 7)</i>  â›  5040

<i>(/ 6)</i>  â›  1/6
<i>(/ 6 7 8)</i>  â›  3/28 ;; rational result
<i>(// 6 7 8)</i>  â›   0.10714285714285714 ;; float result

<i>(min PI 22/7 42)</i>  â†’  3.141592653589793
<i>(max 10 8 6 4)</i>  â†’  10
<i>(apply max (iota 100))</i>  â†’  99

(lib 'math)
<i>(sigma identity 0 100)</i>  â†’  5050 ;; = 100 * 101 / 2 -  ğŸ© young Gauss
</pre>

<h3 id="constant">Constants</h3>
<pre>
<i>Infinity</i>
<i>-Infinity</i>
<i>PI</i>  â›   3.141592653589793
<i>PI/2</i>  â›   1.5707963267948966
<i>-PI</i>  â›   -3.141592653589793
<i>E</i>  â›   2.718281828459045
<i>I</i>  â›   0+i
<i>LOG2</i> â†’ 0.6931471805599453
<i>JOUR</i>  â›  86400 ;; 24 heures * 3600 secondes
<i>DAY</i>  â›  86400 ;; 24 * 3600

<i>(cos PI)</i>  â›   -1
<i>(exp (* I PI))</i>  â›   -1+0i ;; e<sup>i&pi;</sup> = - 1 ğŸ© Euler
<i>(log E)</i>  â›   1
<i>(tan PI/2)</i>  â›   16331239353195370
<i>(* I I)</i>  â›   -1+0i

<i>(+ Infinity 7)</i> â†’ Infinity
<i>(* Infinity -2016.2016)</i> â†’ -Infinity
</pre>


<h3>Numbers - predicates</h3>
<p>Set inclusion : Integer  &sub; Rational  &sub; Complex  &sub; Number. All predicates end with '?' and return #t (true) or #f (false).</p>
<h4 id="number?">(<b>number? </b><i>n</i>)</h4>
<h4 id="rational?">(<b>rational? </b><i>q</i>)</h4>
<h4 id="integer?">(<b>integer? </b><i>n</i>)</h4>
<h4>(<b>complex? </b><i>z</i>)</h4>
<h4 id="exact?">(<b>exact? </b><i>x</i>)</h4>
<h4 id = "inexact?">(<b>inexact? </b><i>x</i>)</h4>
<h4 id = "positive?">(<b>positive? </b><i>x</i>)&rarr; #t iff n >= 0</h4>
<h4>(<b>negative? </b><i>x</i>)</h4>
<h4 id = "positive*?">(<b>positive*? </b><i>n</i>) &rarr; #t iff n > 0</h4>
<h4 id= "zero?">(<b>zero? </b><i>x</i>)</h4>
<pre>
<i>(number? 42)</i>  â›  #t
<i>(number? 'elvis)</i>  â›  #f
<i>(integer? (- 6))</i>  â›  #t
<i>(rational? (/ 4 5))</i>  â›  #t
<i>(rational? (// 4 5))</i>  â›  #f
<i>(exact? PI)</i>  â›  #f
<i>E</i>  â›  2.718281828459045
<i>(inexact? E)</i>  â›  #t
<i>(positive*? 0)</i>  â›  #f
<i>(complex? 3+4i)</i>  â›  #t
<i>(rational? 12)</i>  â›  #t
<i>(complex? 9)</i>  â›  #t
<i>(zero? 0+0i)</i>  â›   #t
</pre>

<h3 id="integer-fun">Integer functions</h3>
<h4 id = "even?">(<b>even? </b><i>n</i>)</h4>
<h4 id = "odd?">(<b>odd? </b><i>n</i>)</h4>
<h4 id = "floor">(<b>floor </b><i>x</i>) â› nearest integer <= x</h4>
<h4 id = "number-length">(<b>number-length </b><i>x  [base]</i>) â› number of digits of (floor x), in base b (default=10)</h4>
<h4 id = "ceil">(<b>ceil </b><i>x</i>) â› nearest integer >= x</h4>
<h4 id="round">(<b>round </b><i>x</i>) â› nearest integer</h4>
<h4 id = "square?">(<b>square? </b><i>n</i>) â› is n a square ?</h4>
<h4 id="modulo">(<b>modulo </b><i>n p</i>) â› m such as n = q*p + m , 0 <= m < p</h4>
<h4 id="modulo">(<b>% </b><i>n p</i>) â› same as modulo</h4>
<h4 id="quotient">(<b>quotient </b><i>n p</i>) â› q such as n = q*p + m , 0 <= m < p</h4>
<br>
<h4 id='1+'>(<b>1+ </b><i>x</i>) â› x + 1</h4>
<h4 id='add1'>(<b>add1 </b><i>x</i>) â› x + 1</h4>
<h4 id='1-'>(<b>1- </b><i>x</i>) â› x - 1</h4>
<h4 id='sub1'>(<b>sub1 </b><i>x</i>) â› x - 1</h4>


<pre>
<i>(even? 77)</i>  â›  #f
<i>(odd? 0)</i>  â›  #f
<i>(floor PI)</i>  â›  3
<i>(ceil PI)</i>  â›   4
<i>(ceil -PI)</i>  â›  -3
<i>(round E)</i>  â›  3
<i>(square? (* 666 42 666 7 6))</i>  â›  #t
<i>(square? 144/49)</i>  â›   #t
<i>(modulo 2015 7)</i>  â›  5
<i>(modulo 2015 -5)</i>  â›  0
<i>(quotient 9 4)</i>  â›  2

<i>(1+ 7)</i>  â›   8
<i>(1+ 22/7)</i>  â›   29/7
<i>(1- I)</i>  â›   -1+i
<i>(add1 PI)</i>  â›   4.141592653589793

;; <b> 49 nuances of gray </b>
<i>(lib 'plot.lib)</i>
<i>(define (quarante-neuf-nuances-de-gris x y) 
  (let ((x (modulo (floor x ) 7)) 
        (y (modulo (floor y) 7))) (gray (// (+ x (* 7 y)) 48))))
        
(plot-rgb quarante-neuf-nuances-de-gris 7 7) </i> 
<img src = "./images/plot-gray-49.png" width="300" height = "300">
</pre>


<h2 id = "arithmetic">Arithmetic</h2>
<p>All of these functions work for integers < 2e+9. For larger integers, the bigint.lib may be used.</p>
<h4 id='powmod'>(<b>powmod </b><i>base exp mod</i>) â› base<sup>exp</sup> modulo <i>mod</i></h4>
<h4 id='gcd'>(<b>gcd </b><i>a b c â€¦</i>) â› greatest common divisor</h4>
<h4 id='lcm'>(<b>lcm </b><i>a b</i>) â› least common multiple = a * b / gcd (a,b)</h4>
<br>
<h4 id='prime?'>(<b>prime? </b><i>p</i>) â› #t if p is prime</h4>
<h4 id='primes'>(<b>primes </b><i>n</i>) â› set of n first primes</h4>
<h4 id='factor'>(<b>factor </b><i>a</i>) â› least prime factor of a ; = a iff a is prime</h4>
<h4 id='prime-factors'>(<b>prime-factors </b><i>n</i>) â› ordered list of prime factors</h4>
<h4 id='random-prime'>(<b>random-prime </b><i>n</i>) â› a prime p in [2â€¦n]</h4>
<h4 id='next-prime'>(<b>next-prime </b><i>n</i>) â› least prime p &gt; n</h4>

<pre>
<i>(gcd 42 666)</i>  â†’   6
<i>(gcd 42 666 33333333)</i>  â†’   3
<i>(lcm 42 666)</i>  â†’   4662
<i>(= (* 42 666) (* (gcd 42 666) (lcm 42 666)))</i>  â†’   #t

<i>(factor 101)</i>  â†’   101
<i>(factor (* 3 5 7 9))</i>  â†’   3
<i>(prime-factors 2015)</i>  â†’   (5 13 31)
(group (prime-factors 666)) â†’ ((2) (3 3) (37))

<i>(prime? 101)</i>  â†’   #t
<i>(primes 10)</i>   â†’ { 2 3 5 7 11 13 17 19 23 29 }

<i>(next-prime 1000000000)</i>  â†’   1000000007
<i>(random-prime 1000000000)</i>  â†’   125910523
<i>(random-prime 2)</i>  â†’   2

<i>(lib 'bigint)</i>
<span style="color:green">Lib: bigint.lib loaded.</span>
<i>(prime-factors (* 3 5 7 9 11 13 15 17))</i>  â†’   (3 3 3 3 5 5 7 11 13 17)
<i>(next-prime 1.e+20)</i>  â†’   100000000000000000039
</pre>

<h2 id="bitwise">Bitwise operations</h2>
<p>Perform logical operations on each corresponding bit - numbered from 0 to 31 - of two integers n and m. If n or m are not integers, they are converted.
<h4 id='bit-count'>(<b>bit-count </b><i>n </i>) -> number of bits set in n, 0 to 32</h4>
<h4 id='bit-right'>(<b>bit-right </b><i>n </i>) -> index of most significant right bit set in n, 0 to 31</h4>
<h4 id='bitwise-ior'>(<b>bitwise-ior </b><i>n m </i>) -> logical or : 0|0 = 1, 1|0 = 0|1 = 1|1 = 1</h4>
<h4 id='bitwise-and'>(<b>bitwise-and </b><i>n m</i>) -> logical and : 1&1 = 1, 1&0 = 0&1 = 0&0 = 0</h4></h4>
<h4 id='bitwise-xor'>(<b>bitwise-xor </b><i>n m </i>) ->   logical exclusive or : 0âŠ—0 = 1âŠ—1 = 0, 0âŠ—1 = 1âŠ—0 = 1</h4>
<h4 id='bitwise-not'>(<b>bitwise-not </b><i>n</i>) -> logical not : ~0 = 1, ~1 = 0</h4>
<h4 id='bitwise-bit-set?'>(<b>bitwise-bit-set? </b><i>n b</i>) is bit number b (0 <= b < 31) set ? #t or #f</h4>
<h4 id='arithmetic-shift'>(<b>arithmetic-shift </b><i>n m </i>) -> left shift - multiply by 2<sup>m</sup> - if m >=0 ; right shift if m < 0</h4>
<br>
<h4 id='number->string'>(<b>number->string </b><i>n [2|16]</i>) -> base 10, 2 or hexadecimal conversion. <small>May be long for huge (> 10000 digits) numbers</small></h4>

<pre>
<i>(define (<< n m) (arithmetic-shift n m ))
(define (>> n m) (arithmetic-shift n (- m)))</i>

(>> 666 1) â†’ 333
(>> 133 1) â†’ 66

(number->string 666) â†’ "666"
(number->string 666 2) â†’ "1010011010"
(number->string 666 16) â†’ "29a"
</pre>



<h2>Combinatorics</h2>
<p>NB: more combinatoric functions are defined in the <a href="#list.lib">list.lib</a> library.</p>
<h4 id='factorial'>(<b>factorial </b><i>n</i>) â› n! =  2 * 3 * â€¦ * n</h4>
<h4 id='factorial'>(<b>! </b><i>n</i>) â› n! =  2 * 3 * â€¦ * n <small>Same as factorial</small></h4>
<h4 id='Cnp'>(<b>Cnp </b><i>n p </i>) â› combinations : n! / (p! * (n-p)!)</h4>
<h4 id='Anp'>(<b>Anp </b><i>n p</i>) â› arrangements : n! / (n-p) !</h4>
<br>
<h4 id='vector-permute!'>(<b>vector-permute! </b><i>vector permutation-vector</i>) â› permutes vector <mark>in place</mark>, using <i>permutation-vector</i> which is a permutation of the indices [0 ... n-1]. In other words, result[i] := vector[perm[i]]</h4>


<pre>
<i>(factorial 10)</i>  â›   3628800
<i>(factorial 100)</i>  â›   9.33262154439441e+157

<i>(Cnp 4 2)</i>  â›   6
<i>(Cnp 1000 10)</i>  â›   2.6340956046197025e+23

;; (implode '(a b c)) -> ((a) (b) (c))
<i>(define (implode lst) (cond ((null? lst) null) (else (map list lst))))</i>

;; output all combinations of lst p to p.
;; Exemple only. Use the <a href="#combinations">combinations</a> function defined in <a href="#list.lib">list.lib</a>.
<i>
(define (combine lst p) (cond
 ((null? lst) null)
 ((< (length lst) p) null)
 ((= (length lst) p) (list lst))
 ((= p 1) (implode lst))
 (else (append 
      (map cons (circular-list (car lst)) (combine (cdr lst) (1- p)))
      (combine (cdr lst) p)))))</i>
      
<i>(Cnp 5 3)</i> â†’ 10
<i>(combine '( albert simon antoinette ludwig elvis) 3)</i>  â†’
   ((albert simon antoinette) (albert simon ludwig) (albert simon elvis) (albert antoinette ludwig) (albert antoinette elvis) (albert ludwig elvis) (simon antoinette ludwig) (simon antoinette elvis) (simon ludwig elvis) (antoinette ludwig elvis)) ;; 10 triplets
   
<i>(define perm #(1 3 2 0))
(vector-permute! #(a b c d) perm)</i>  â†’ #( b d c a)

<i>(lib 'bigint)</i>
<span style="color:green">Lib: bigint.lib loaded.</span>
<i>(Cnp 1000 10)</i>  â›   263409560461970212832400
<i>(factorial 100)</i>  â›   
9332621544394415268169923885626670049071596826438162146
8592963895217599993229915608941463976156518286253697920
827223758251185210916864000000000000000000000000


</pre>


<h2>Rational numbers a/b</h2>
<h4><b>22/7</b> â› read new rational</h4>
<h4 id='rational?'>(<b>rational? </b><i>x</i>) â› #t or #f</h4>
<h4 id='rational'>(<b>rational </b><i>a b</i>) â› a/b</h4>
<h4 id='num'>(<b>num </b><i>a/b</i>) â› numerator: a</h4>
<h4 id='den'>(<b>den </b><i>a/b</i>) â› denominator: b</h4>
<h4 id='rationalize'>(<b>rationalize </b><i>x</i>) â› p/q : |x - p/q| < 0.0001</h4>
<h4 id='rationalize'>(<b>rationalize </b><i>x Îµ</i>) â› p/q : |p/q - x| < Îµ</h4>
<h4 id='/'>(<b>/ </b><i>a b</i>)â› rational (when possible)</h4>
<h4 id='//'>(<b>// </b><i>a b</i>) â› always float</h4>

<pre>
<i>22/7</i>  â›   22/7 ;; no spaces to read a rational
<i>(rational 100 3450)</i>  â›   2/69 ;; creation
<i>(rational? 78)</i>  â›   #t ;; an integer is also a rational
<i>(rational? 0.3)</i>  â›   #f
<i>(rational? 22/7)</i>  â›   #t

<i>(num 22/14)</i>  â›   11
<i>(den 42/666) </i>  â›   111

<i>(/ 44 14)</i>  â›   22/7
<i>42/666</i>  â›   7/111
<i>(/ 1 2)</i>  â†’   1/2
<i>(// 1 2)</i>  â†’   0.5

<i>(+ 1 1/2 1/4 1/8)</i>  â›   15/8
<i>(+ 666.42 1/2)</i>  â›   666.92
<i>(+ 22/7 I)</i>  â›   3.142857142857143+i
<i>(expt 22/7 7)</i>  â›   3028.81317429691


<i>PI</i>  â›   3.141592653589793
<i>(rationalize PI 0.01)</i>  â›   22/7
<i>(rationalize PI)</i>  â›   333/106
<i>(rationalize PI 0.000001)</i>  â›   355/113
<i>(// 355 113)</i>  â›   3.1415929203539825
<i>(rationalize PI 0.000000001)</i>  â›   103993/33102
<i>(// 103993 33102)</i>  â›   3.1415926530119025
</pre>






<h2 id = "complex">Complex numbers z = a+ib</h2>
<h4><b>7+3i</b> â› read - input - a new complex
<h4 id='complex?'>(<b>complex? </b><i>z</i>) â› #t or #f</h4>
<h4 id='complex'>(<b>complex </b><i>a b</i>) â›  new complex = a + ib</h4>
<h4 id='make-rect'>(<b>make-rect </b><i>a b</i>) â› new complex = a + ib</h4>
<h4 id='polar'>(<b>polar </b><i>rho theta</i>) â› new complex = rho * (cos(theta) + i sin(theta))</h4>
<h4 id='make-polar'>(<b>make-polar </b><i>rho theta</i>) â› new complex = rho * (cos(theta) + i sin(theta))</h4>
<h4 id='imag'>(<b>imag </b><i>z</i>) â› imaginary part</h4>
<h4 id='real'>(<b>real </b><i>z</i>) â› real part</h4>
<h4 id='imag-part'>(<b>imag-part </b><i>z</i>) â› imaginary part = b</h4>
<h4 id='real-part'>(<b>real-part </b><i>z</i>) â› real part = a</h4>
<h4 id='magnitude'>(<b>magnitude </b><i>z</i>) â› rho = sqrt(a*a + b*b)</h4>
<h4 id='angle'>(<b>angle </b><i>z</i>) â› theta = atan2(b,a) in [-PI..PI]</h4>
<h4 id='conjugate'>(<b>conjugate </b><i>z</i>) â› <span style="text-decoration:overline">z</span> = a-ib</h4>
<p>and all usual functions: exp, expt, log, sin, ..</p>

<pre>
<i>(plot-z-mod log -4 -4)</i>  â›  plot log(z) in rectangle [-4-4i 4+4i].
<center> <img src="./images/logz.png" width=300 height="300"></center>
</pre>

<pre>
<i>3.2-4.8i</i>  â›   3.2-4.8i ;; no spaces to read a complex
<i>(complex? I)</i>  â›   #t
<i>I</i>  â›   0+i
<i>(complex 3 4)</i>  â›   3+4i ;; creation
<i>(define z (complex 3 4))</i>  â›   z
<i>z</i>  â›   3+4i
<i>(angle z)</i>  â›   0.9272952180016122
<i>(magnitude z)</i>  â›   5
<i>(polar (magnitude z) (angle z))</i>  â›   3+4i
<i>(conjugate z)</i>  â›   3-4i
<i>(exp (* I PI))</i>  â›   -1+0i ;; Euler formula

<i>(define (f z) (/ (1+ (* z z z))))</i>  â›   f ;;  1 / (z<sup>3</sup>+1)
<i>(f I)</i>  â›   0.5+0.5i
<i>(f 0.42-3i)</i>  â›   -0.01366639866973426-0.03383001817614986i

;; Three poles of  1 / (z<sup>3</sup>+1)
<i>(lib 'plot.lib)</i>  â› Lib: plot.lib loaded.
<i>(plot-z-mod f -3 -3)</i>  â›   plot f(z) in rectangle [-3-3i 3+3i].

<center> <img src="./images/1-z3+1.png" width=300 height="300"></center>

</pre>



<h2  id="maths">Math functions</h2>
<p>z &#x2208; &#x1D4D2;  - x &#x2208; &#x1D4E1; </p>
<h4 id='abs'>(<b>abs </b><i>x</i>) â› |x|</h4>
<h4 id='fract'>(<b>fract </b><i>x</i>) â› fractional part</h4>
<h4 id='sin'>(<b>sin </b><i>z</i>)</h4>
<h4 id='cos'>(<b>cos </b><i>z</i>)</h4>
<h4 id='tan'>(<b>tan </b><i>z</i>)</h4>
<h4 id='log'>(<b>log </b><i>z</i>)</h4>
<h4 id='sqrt'>(<b>sqrt </b><i>z</i>) â› square root</h4>
<h4 id='cbrt'>(<b>cbrt </b><i>z</i>) â› cubic root</h4>
<h4 id='exp'>(<b>exp </b><i>z</i>) â› e<sup>z</sup></h4>
<h4 id='expt'>(<b>expt </b><i>z z1</i>) â› z<sup>z1</sup></h4>
<h4 id='expt'>(<b>^ </b><i>z z1</i>) â› z<sup>z1</sup> <small>Same as expt</small></h4>
<h4 id='acos'>(<b>acos </b><i>x</i>) â› alpha in [0 .. PI]</h4>
<h4 id='asin'>(<b>asin </b><i>x</i>) â› alpha in [-PI/2.. PI/2]</h4>
<h4 id='atan'>(<b>atan </b><i>x</i>)â› alpha in [-PI/2 .. PI/2]</h4>
<h4 id='atan2'>(<b>atan </b><i>y x</i>) â› alpha in [-PI .. PI] : tan(y/x) = alpha</h4>
<h4 id='log2'>(<b>log2 </b><i>x</i>) â› y : 2<sup>y</sup> = x</h4>
<h4 id='log10'>(<b>log10 </b><i>x</i>) â› y : 10<sup>y</sup> = x</h4>

<pre>
<i>(fract PI)</i>  â†’   0.14159265358979312
<i>(abs -PI)</i>  â†’   3.141592653589793

<i>(cos PI)</i>  â›   -1
<i>(sin 22/7)</i>  â›   -0.00126448893037729
<i>(cos I)</i>  â›   1.5430806348152437+0i
<i>(sin I)</i>  â›   0+1.1752011936438014i
<i>(+ (* (cos I)(cos I)) (* (sin I) (sin I)))</i>  â›   1+0i
<i>(atan2 0 5)</i>  â›   0
<i>(atan2 5 0)</i>  â›   1.5707963267948966 ;; PI/2

<i>(log 6)</i>  â›   1.791759469228055
<i>(log -3)</i>  â›   NaN
<i>(log -3+0i)</i>  â›   1.0986122886681098+3.141592653589793i

<i>(exp (log 666))</i>  â›   666.0000000000001
<i>(expt 3 4)</i>  â›   81
<i>(expt -3 4)</i>  â›   81
<i>(expt 3 -4)</i>  â›   0.012345679012345678
<i>(expt -3 -4.5)</i>  â›   0-0.007127781101106491i

<i>(sqrt 1000000000000)</i>  â›   #1000000
<i>(sqrt -9)</i>  â›   0+3i
<i>(sqrt I)</i>  â›   0.7071067811865476+0.7071067811865476i

<i>(cbrt -27)</i>  â› -3
<i>(cbrt 0+i)</i>  â› 0.8660254037844389+0.49999999999999944i

</pre>



<h3 id="random">Random</h3>
<h4 id='random'>(<b>random </b><i></i>) â› random in [0 â€¦ 1[</h4>
<h4 id='random'>(<b>random </b> -1) â› random in ]-1 â€¦ 1[</h4>
<h4 id='random'>(<b>random </b><i>int-base</i>) â› random integer in [0 .. base [</h4>
<h4 id='random'>(<b>random </b><i> int-negative-base</i>) â› random integer in ]base ... -base[</h4>

<h4 id='random-seed'>(<b>random-seed </b><i>seed</i>) â› new seed</h4>
<h4 id='shuffle'>(<b>shuffle </b><i>list</i>) <b>O</b>(n) operations</h4>
<pre>
<i>(random)</i>  â›   0.621223164399653
<i>(random-seed 'elvis)</i>  â›   0.03779020818580782
<i>(random)</i>  â›   0.4152655335541243
<i>(random)</i>  â›   0.5532895568415128
<i>(random-seed 'elvis)</i>  â›   0.03779020818580782
<i>(random)</i>  â›   0.4152655335541243
<i>(random 100)</i>  â›   55

<i>(shuffle '(a b c d))</i>  â›   (c a d b)
<i>(shuffle (iota 16))</i>  â›   (5 14 6 13 3 2 8 11 12 9 1 0 15 7 4 10)

<i>(unicode->list 9824 9831)</i>  â›   (â™  â™¡ â™¢ â™£ â™¤ â™¥ â™¦ â™§)
<i>(shuffle (unicode->list 9824 9831))</i>  â›   (â™¡ â™§ â™¤ â™  â™¦ â™¢ â™£ â™¥)

;; sum of 1000000 random numbers
<i>(for/sum ((i 1000000)) (random))</i>  â›   500188.5688371864
<i>(for/sum ((i 1000000)) (random))</i>  â›   499835.121561366

;; random integers list
<i>(define (rand-list n (range 100)  (acc null)) 
		(if (zero? n) acc 
		(rand-list (1- n) range (cons (random range) acc))))</i>  â›   rand-list
<i>(rand-list 22)</i>  â›   
		(6 70 59 68 21 75 57 94 36 94 77 94 16 26 15 19 67 91 66 17 92 52)

;; throw dices
<i>(define (dice) (unicode->string (+ 0x2680 (random 6))))</i>  â›   dice
<i>(dice)</i>  â›  <span style = "font-size:32px">âš</span>
<i>(dice)</i>  â›  <span style = "font-size:32px">âšƒ</span>
<i>(dice)</i>  â›  <span style = "font-size:32px">âšƒ</span>
</pre>
    


<h2 id="predicates">Predicates</h2>
<h4 id='symbol?'>(<b>symbol? </b><i>obj</i>) â› #t or #f</h4>
<h4 id='procedure?'>(<b>procedure? </b><i>obj</i>) â› #t or #f</h4>
<h4 id='number?'>(<b>number? </b><i>obj</i>) â› #t or #f</h4>
<h4 id='null?'>(<b>null? </b><i>obj</i>) â› #t if obj is null - which is the same as the empty list  ()</h4>
<h4 id='empty?'>(<b>empty? </b><i>obj</i>) â›  same as (null? obj)</h4>
<h4 id='!null?'>(<b>!null? </b><i>obj</i>) â› same as (not (null? obj))</h4>
<h4 id='!empty?'>(<b>!empty? </b><i>obj</i>) â› same as (not (empty? obj))</h4>
<h4 id='list?'>(<b>list? </b><i>obj</i>) â› #t if obj is a list or null</h4>
<h4 id='pair?'>(<b>pair? </b><i>obj</i>) â› #t if obj is a list not null or dotted pair (a . b)</h4>

<pre>
<i>(define simon 999999)</i>  â†’   simon
<i>(symbol? 'simon)</i>  â†’   #t
<i>(symbol? simon)</i>  â†’   #f
<i>(number? simon)</i>  â†’   #t

<i>(procedure? append)</i>  â†’   #t
<i>(define (simon x)(+ x x))</i>  â†’   simon
<i>(procedure? simon)</i>  â†’   #t

<i>(gensym)</i>  â†’   #:g1001
<i>(symbol? (gensym))</i>  â†’   #t

<i>(null? ())</i>  â†’   #t
<i>(null? null)</i>  â†’   #t
<i>(null? 0)</i>  â†’   #f
<i>(list? '(a b c))</i>  â†’   #t
<i>(pair? '(simon antoinette))</i>  â†’   #t
<i>(pair? '(simon . antoinette))</i>  â†’   #t
<i>(list? null)</i>  â†’   #t
<i>(pair? null)</i>  â†’   #f
</pre>


<h2 id="compare">Comparison operators</h2>
<h3>All things which are "eq?" are also "equal?" (Broderick Fitsche)</h3>
<h4 id='eq?'>(<b>eq? </b><i>obj<sub>1</sub> obj<sub>2</sub></i>) â› #t iff obj<sub>1</sub> and obj<sub>2</sub> are the same object (pointer)</h4>
<h4 id='eqv?'>(<b>eqv? </b><i>obj<sub>1</sub> obj<sub>2</sub></i>) â› #t iff (eq? obj<sub>1</sub> obj<sub>2</sub>) or same value objects or same numeric vectors</h4>
<h4 id='equal?'>(<b>equal? </b><i>obj<sub>1</sub> obj<sub>2</sub></i>) â› #t iff (eqv? obj<sub>1</sub> obj<sub>2</sub>) or isomorphic objects</h4>
<h4 id='!eq?'>(<b>!eq? </b><i>obj<sub>1</sub> obj<sub>2</sub></i>) â› same as (not (eq? obj<sub>1</sub> obj<sub>2</sub>))</h4>
<h4 id='!equal?'>(<b>!equal? </b><i>obj<sub>1</sub> obj<sub>2</sub></i>) â› same as (not (equal? obj<sub>1</sub> obj<sub>2</sub>))</h4>


<pre>
<i>(eq? 'simon 'antoinette)</i>  â†’   #f
<i>(eq? "simon" "simon")</i>  â†’   #t
<i>(eq? "simon" (string-append "si" "mon"))</i>  â†’   #t
<i>(eq? 0.5 2/4)</i>  â†’   #f
<i>(eqv? 0.5 2/4)</i>  â†’   #t
<i>(equal? 0.5 6/12)</i>  â†’   #t

<i>(eq? '(1 2 3) '(1 2 3))</i>  â†’   #f
<i>(equal? '(1 2 3) (append '(1) '(2 3)))</i>  â†’   #t

<i>(eq? '#(1 2 3) '#(1 2 3))</i>  â†’   #f
<i>(equal? '#(1 2 3) '#(1 2 3))</i>  â†’   #t
</pre>

<h3 id = "numcompare">Numbers comparisons</h3>
<h4 id='='>(<b>= </b><i>x y</i>)</h4>
<h4 id=!'='>(<b>!= </b><i>x y</i>)  same as (not (= x y))</h4>
<h4 >(<b>&gt; </b><i>x y</i>)</h4>
<h4 >(<b>&gt;= </b><i>x y</i>)</h4>
<h4 >(<b>&lt; </b><i>x y</i>)</h4>
<h4 >(<b>&lt;= </b><i>x y</i>)</h4>
<h4 id='zero?'>(<b>zero? </b><i>x</i>)</h4>
<h4 id='!zero?'>(<b>!zero? </b><i>x</i>)  â†’ same as (not (zero? x)) </h4>

<pre>
<i>(= 0.5 1/2)</i>  â†’   #t
<i>(= PI 3.14159)</i>  â†’   #f
<i>(= I 0+i)</i>  â†’   #t
<i>(= (sqrt 4) 2)</i>  â†’   #t
<i>(> I 8)</i>
	ğŸ’¥ error: '>' : argument type is not correct : 0+i

</pre>





<h2 id="lists">Lists</h2>
<h3> "All lists are incomplete, except the empty list" (Maurice Blanchot)
<h4 id = "null"><b>null</b> or <b>()</b> is the empty list.
<h4 id = "first">(<b>first </b><i>list</i>) â› first item of list</h4>
<h4 id = "car">(<b>car </b><i>list</i>) â› same as (first list)</h4>
<h4 id = "rest">(<b>rest </b><i>list</i>) â› rest of list, after first item</h4>
<h4 id = "cdr">(<b>cdr </b><i>list</i>)  â› same as (rest list)</h4>
<h4 id = "cadr">(<b>second </b><i>list</i>)  â› (first (rest list))</h4>
<h4 id = "cadr">(<b>cadr </b><i>list</i>)  â› (car (cdr list)) same as (second list) </h4>
<h4 id = "caddr">(<b>third </b><i>list</i>)  â› (first (rest (rest list)))</h4>
<h4 id = "caddr">(<b>caddr </b><i>list</i>)  â› (car (cdr (cdr list)) same as (third list)</h4>
<h4 id = "cddr">(<b>cddr </b><i>list</i>)  â› (cdr (cdr list))</h4>
<h4> and <b>car</b>/<b>cdr</b> combinations : <b>caar, cadr, cdar, cddr, caaar, caadr, â€¦</b></h4>
<pre>
<i>(first '(1 2 3))</i>  â›   1
<i>(rest '(1 2 3))</i>  â›   (2 3)
<i>(cdr '(1))</i>  â›   null

<i>(define noms '(albert (ludwig wittgenstein) (simon gallubert) elvis))</i>  

<i>(first noms)</i>  â›  albert
<i>(rest noms)</i>  â›  ((ludwig wittgenstein) (simon gallubert) elvis)
<i>(second noms) </i>  â›  (ludwig wittgenstein)
<i>(third noms)</i>  â›  (simon gallubert)
<i>(car noms)</i>  â›  albert
<i>(caadr noms)</i>  â›  ludwig
<i>(cdadr noms)</i>  â›  (wittgenstein)
<i>(cdddr noms)</i>  â›  (elvis)
<i>(cdr noms)</i>  â›  ((ludwig wittgenstein) (simon gallubert) elvis) 
</pre>


<h3>Lists - components</h3>
<h4 id="length">(<b>length </b><i>list</i>)</h4>
<h4 id="last">(<b>last </b><i>list</i>) â›  last element</h4>
<h4 id = "list-ref">(<b>list-ref </b><i>list index</i>) â›  list[index] - <small>index in [0..length(list)[</small></h4>
<h4 id = "list-index">(<b>list-index </b><i>item list</i>) â›  position of <i>item</i> in list - <small>in [0..length(list)[</small> - or #f . Uses (equal?) predicate.</h4>
<br>
<h4 id = "sublist">(<b>sublist </b><i>list from to</i>)  â›  new list = list [from ..to[</h4>
<h4 id = "list-tail">(<b>list-tail </b><i>list pos</i>)  â›  list [pos ... end] <small>Same as (cddd..dr list). <i>pos</i> is in [0..length(list)[ ; starts from end if pos < 0</small></h4>
<br>
<h4 id = "take">(<b>take </b><i>list n</i>)  â›  new list : n first elements of list</h4>
<h4 id = "drop">(<b>drop </b><i>list n</i>)  â›  new list : n first elements removed</h4>

<p> ğŸ‘“ ğŸ‘“ ğŸ‘“ <b>take</b> may also be used to extract elements from various sequences types : (take <i>vector</i> n), (take <i>string</i> n), (take <i>stream</i> n), (take <i>hash</i> n), (take <i>generator</i> n), (take <i>table</i> n), (take <i>function:1</i> n), etc. <small>For compatibility or ignored reasons, (take list n) or (drop list n) may be written as (take n list) or (drop n list).</small>
</p>
<p>
<b>drop</b> may also be used to drop elements from various sequences types : (drop <i>vector</i> n), (drop <i>string</i> n), (drop <i>generator</i> n).
</p>
<pre>
<i>(define nums (iota 9))</i>  â›  nums
<i>nums</i>  â›  (0 1 2 3 4 5 6 7 8)
<i>(length nums)</i>  â›  9
<i>(length noms)</i>  â›  4
<i>(length '((d e f g h i) (x y z ludwig t)))</i>  â›   2
<i>(last nums)</i>  â›  8
<i>(list-tail nums 8)</i>  â›  (8) 
<i>(list-tail nums 4)</i>  â›  (4 5 6 7 8)
<i>(list-tail nums -2)</i>  â›  (7 8)
<i>(list-ref nums 6)</i>  â›  6
<i>(sublist nums 2 6)</i>  â›  (2 3 4 5)
<i>(last noms)</i>  â›  elvis

<i>(take '(a b c d e) 3)</i>  â†’ (a b c)
<i>(take (iota 1000) 7)</i> â†’ #{ 0 1 2 3 4 5 6 } ;; a list, also a set.
<i>(take factorial 10) â†’ (1 1 2 6 24 120 720 5040 40320 362880)

(lib 'sequences)
<i>(take 10 [7 50/3 ..])</i>
    â†’ (7 50/3 79/3 36 137/3 166/3 65 224/3 253/3 94)

<i>(define oops (circular-list 'a 'b 'c 'd))</i>  
<i>oops</i>  â›  (a b c d a ..âˆ)
<i>(length oops)</i>  â›  Infinity
<i>(list-ref oops 12567)</i>  â›   d
</pre>

<h3>Pairs</h3>
<h4 id='pair?'>(<b>cons </b><i>item<sub>1</sub> item<sub>2</sub></i>) â› pair {item<sub>1</sub> . item<sub>2</sub>}</h4>
<h4 id='car'>(<b>car </b><i>pair</i>) â› item<sub>1</sub></h4>
<h4 id='cdr'>(<b>cdr </b><i>pair</i>) â› item<sub>2</sub></h4>
<h4 id='pair?'>(<b>pair? </b><i>pair</i>) â› # t</h4>

<pre>
<i>'(42 . 666)</i>  â†’   {42 . 666} ;; pair
<i>(define couple (cons 'albert 'antoinette))</i>  â†’   couple
<i>couple</i>  â†’   {albert . antoinette}
<i>(car couple)</i>  â†’   albert
<i>(cdr couple)</i>  â†’   antoinette
<i>(pair? couple)</i>  â†’   #t
<i>(list? couple)</i>  â†’   #f

<i>(define other '(simon . antoinette))</i>  â†’   other
<i>other</i>  â†’   {simon . antoinette}
<i>(pair? other)</i>  â†’   #t
</pre>


<h3>Lists - marking</h3>
<p>Sublists - i.e. consecutive rests - of a list can be marked, unmarked with symbols, or any object. This does not modify the sublists, nor the items in the lists. If (mark-print) is #t ,marks appear in the printed output before the marked sublist.</p>

<h4 id='mark'>(<b>mark </b><i>list tag</i>) â› marks head of (sub)list with tag</h4>
<h4 id='unmark'>(<b>unmark </b><i>list</i>) â› removes tag</h4>
<h4 id='mark?'>(<b>mark? </b><i>list</i>) â› is list marked ? #f or tag</h4>
<h4 id='mark-filter'>(<b>mark-filter </b><i>list</i>) â› extracts list of all marked sublists</h4>
<h4 id='mark-filter'>(<b>mark-filter </b><i>list filter</i>) â› extracts list of all marked sublists, whose tag is eq to <i>filter</i></h4>
<h4 id='mark-print'>(<b>mark-print </b>[<i>#t | #f</i>]) â› show/hide marks - #t is default</h4>

<pre>
<i>(define persons '( Basin Ducret Potain Swann Verdurin))</i>  

<i>(mark (rest persons) 'ğŸ³)</i>  
<i>persons</i>  â†’   (Basin ğŸ³ Ducret Potain Swann Verdurin)

<i>(mark (member 'Swann persons) 'ğŸ€)</i>  
<i>persons</i>  â†’   (Basin ğŸ³ Ducret Potain ğŸ€ Swann Verdurin)
<i>(length persons)</i>  â†’   5

<i>(mark-filter persons)</i>  â†’   ((ğŸ€ Swann Verdurin) (ğŸ³ Ducret Potain ğŸ€ Swann Verdurin))
<i>(mark-filter persons 'ğŸ€)</i>  â†’   ((ğŸ€ Swann Verdurin))

;; extract all marked items
<i>(map car (mark-filter persons))</i>  â†’   (Swann Ducret)

;; unmark all
<i>(maplist unmark persons)</i> 
<i>persons</i>  â†’   (Basin Ducret Potain Swann Verdurin)

;; default print color for marks is red
(mark (list-tail persons -1) 666)
   â†’ (Basin Ducret Potain Swann <span style="color:red">666</span> Verdurin)
(mark-print #f)  â†’ #f ;; hide marks
persons  â†’ (Basin Ducret Potain Swann Verdurin)


;; <span style="border : 1px solid black">Load </span> <a href="./lib/combinations.glisp">combinations.glisp</a>
<i>(maplist unmark persons)</i> 
<i>(comb-next persons 3)</i>  â†’   (Basin Ducret Potain)
<i>(comb-next persons 3)</i>  â†’   (Basin Ducret Swann)
<i>(comb-next persons 3)</i>  â†’   (Basin Ducret Verdurin)
<i>(comb-next persons 3)</i>  â†’   (Basin Potain Swann)
...
<i>(comb-next persons 3)</i>  â†’   (Potain Swann Verdurin)

</pre>


<h3>Lists construction</h3>
<h4 id='cons'>(<b>cons </b><i>item null</i>) â› new list = (item)   ; constructor : the mother of all lists</h4>
<h4 id='cons'>(<b>cons </b><i>item list</i>) â› new list : first = item, rest = <i>list</i>  </h4>
<h4 id='cons'>(<b>cons </b><i>item-a item-b</i>) â› dotted pair ( item-a . item-b) </h4>
<h4 id='append'>(<b>append </b><i>list<sub>1</sub></i> list<sub>2</sub>  â€¦ </i>) â› new list :  makes a copy of <i>list<sub>1</sub></i> and appends list<sub>2..n</sub>.<small>The last list may be an atom. (append '(a b c) d) is the same as (append '(a b c) (list d))</small></h4>
<h4 id='list'>(<b>list </b><i>a b c  â€¦</i>) â› (a b c â€¦) ; make a new list from items a,b, ...</h4>
<h4 id='make-list'>(<b>make-list </b><i>length obj</i>) â› new list (obj obj obj â€¦)</h4>
<br>
<h4><b>&#x1F335 Chirurgy - Be careful -  ğŸ˜µ list is modified</b></h4>
<h4 id='list-swap!'>(<b>list-swap! </b>list u v )</i> â› (a b c â€¦ v â€¦ u â€¦) </h4>
<h4 id='list-swap-ref!'>(<b>list-swap-ref! </b>list i j )</i> â› swaps items at index i,j. <small> i,j in [0 â€¦ length(list)-1]</small> </h4>
<h4 id='set-car!'>(<b>set-car! </b>list new-first)</i> â› (new-first b c â€¦)</h4>
<h4 id='set-cdr!'>(<b>set-cdr! </b>list list<sub>2</sub>)</i> â› (a x y z ..) ; replaces (rest list) by list2 </h4>
<h4 id='nconc'>(<b>nconc </b><i>list list<sub>2</sub>  â€¦</i>) â› (a b c .. x y  â€¦) ; physically concatenates lists</h4> 

<pre>
<i>null</i>  â›   null ;; the empty list
<i>()</i>  â›   null ;; the same

;; construction
<i>(cons 666 null)</i>  â›   (666)
<i>(cons 9 (cons 8 (cons 7 (cons 6 null))))</i>  â›   (9 8 7 6)
<i>(cons 42 (iota 9))</i>  â›   (42 0 1 2 3 4 5 6 7 8)
<i>(list 6 7 8 9)</i>  â›   (6 7 8 9)

;;dotted pairs
<i>(cons 'a 'b)</i>  â›  (a . b)
<i>(rest (cons 'a 'b))</i>   â› b

<i>(define friends '(jean albert simone))</i>  â›   friends
<i>(define other '(antoinette maurice))</i>  â›   other

;; new lists creation
<i>(append friends other)</i>  â›   (jean albert simone antoinette maurice)

<i>(append other friends other)</i> 
   â›  (antoinette maurice jean albert simone antoinette maurice)
   
<i>(cons 'snoopy friends)</i>  â›   (snoopy jean albert simone)

<i>(list (list friends other (list (list other))))</i> 
   â›   (((jean albert simone) (antoinette maurice) (((antoinette maurice)))))

;; chirurgy : modifies friends
<i>friends</i>  â›   (jean albert simone)
<i>(nconc friends other)</i> 
<i>friends</i>  â›   (jean albert simone antoinette maurice)

<i>(set-car! friends 'elvis)</i> 
<i>friends</i>  â›   (elvis albert simone antoinette maurice)

<i>(set-cdr! friends null)</i> 
<i>friends</i>  â›   (elvis)
</pre>

<h3>Lists of numbers</h3>
<p>Iota, range and srange constructors return <a href="#set?">sets</a> - which are also lists - of numbers. (range) works with integers, and (srange) handles any number type. <i>step</i> may be negative. Default values are start=0, step=1.<small> Note that the <i>end</i> value is not included in the generated interval</small>.
</p>
<h4 id='iota'>(<b>iota </b><i>n</i>) â› {0 1 2 â€¦ n-1}</a></h4>
<h4 id='range'>(<b>range </b><i>n </i>) â› {0 1 2 â€¦ n-1} </h4>
<h4 id='range'>(<b>range </b><i>start end </i>) â› {start start+1 â€¦ end-1} </h4>
<h4 id='range'>(<b>range </b><i>start end step</i>) â› {start start+step start+2*step â€¦ &lt; end}</h4>
<h4 id='srange'>(<b>srange </b><i>start </i>[end [step]]) â› {start start+step start+2*step â€¦  &lt; end}. Same as range, but start/end/step may be rational or float values.</h4>

<pre>
<i>(iota 7)</i>  â›   #{0 1 2 3 4 5 6}
<i>(reverse (iota 8))</i>  â›   (7 6 5 4 3 2 1 0)
<i>(range 4 9)</i>  â›   #{4 5 6 7 8}
<i>(range 4 16 3)</i>  â›   #{4 7 10 13}

<i>(srange 23 5  -7/4)</i> â†’  #{ 23 85/4 39/2 71/4 16 57/4 25/2 43/4 9 29/4 11/2 }
</pre>

<h3>Lists operations</h3>
<h4 id='member'>(<b>member </b><i>item list</i>) Looks for item in list â› #f or sublist (item â€¦) - uses equal? predicate</h4>
<h4 id='member*'>(<b>member* </b><i>item list</i>) Looks for item in list, and recursively in sub-lists of list. â› #f or sublist (item â€¦) - uses equal? predicate</h4>

<h4 id='memv'>(<b>memv </b><i>item list</i>) Looks for item in list â› #f or sublist (item â€¦) - uses eqv? predicate</h4>
<h4 id='memq'>(<b>memq </b><i>item list</i>) Looks for item in list â› #f or sublist (item â€¦) - uses eq? predicate</h4>
<br>
<h4 id='filter'>(<b>filter </b><i>predicate list</i>) â› list all items such as (predicate item) is #t</h4>
<h4 id='filter-count'>(<b>filter-count </b><i>predicate list</i>) â› count items such as (predicate item) is #t</h4>
<br>
<h4 id='reverse'>(<b>reverse </b><i>'(a b c d</i>)) â› (d c a b)</h4>
<h4 id='flatten'>(<b>flatten </b><i>list</i>)  â› recursively flattens sub-lists</h4>
<br>
<h4 id='group'>(<b>group </b><i>list</i>)  â› new list = group consecutive equal? items into sub-lists. <b>O</b>(n)</h4>
<h4 id='group'>(<b>group </b><i>list compare-proc:2:2</i>)  â› new list = group consecutive items into sub-lists, using compare-proc for testing equality.  <b>O</b>(n)</h4>
<h4 id='group'>(<b>group* </b><i>list</i>)  â› new list = group equal? items into sub-lists. <b>O</b>(n<sup>2</sup>)</h4>
<h4 id='group'>(<b>group* </b><i>list compare-proc:2:2</i>)  â› new list = group items into sub-lists, using compare-proc for testing equality. <b>O</b>(n<sup>2</sup>)</h4>


<br>
<h4 id='list-sort'>(<b>list-sort </b><i>sort-predicate list</i>)  â›  new list sorted by (sort-predicate a b) -> #t|#f</h4>
<h4 id='list-sort/fields'>(<b>list-sort/fields </b><i>num-fields list</i>)  <i>list</i> is a list of lists : (field<sub>0</sub> field<sub>1</sub> ..) Ascending sorts <i>list</i> by sorting first on field<sub>0</sub>, then field<sub>1</sub>, ..field<sub>i</sub>, i in [0..num-fields[. â›  new list </h4>
<br>
<h4 id='shuffle'>(<b>shuffle </b><i>list</i>) â› random ordering</h4>
<br>
<h4 id='circular-list'>(<b>circular-list </b><i>a b c</i>) â› (a b c a b â€¦ ad infinitum)</h4>
<h4 id='circular?'>(<b>circular?</b> <i>list</i>) does this list contain auto-references ? â› #t or #f
<h4 id='copy'>(<b>copy </b><i>list</i>) â› deep copy of list; can copy circular lists or lists with deep auto-references.
<pre>
<i>(define somelist ' (a b c d e f g 666 h))</i>  â›   somelist
<i>(member 42 somelist)</i>  â›   #f ;; ğŸ˜µ does not return (), but #f
<i>(member 'd somelist)</i>  â›   (d e f g 666 h)
<i>(filter number? somelist)</i>  â›   (666)
<i>(filter-count symbol? somelist)</i>  â›   8

<i>(circular-list 'dog 'after 'tail)</i>  â›   (dog after tail dog after ..âˆ)
<i>(circular-list 1 2 3)</i>  â›   (1 2 3 1 2 ... âˆ)
<i>(cdddr (circular-list '(a b)))</i>  â›   ((a b) (a b) (a b) ..âˆ)

<i>(define (unicode->list from to) 
    (for/list ((i (in-range from to))) (unicode->string i)))</i>
<i>(unicode->list 0x1F628 0x1F637)</i>  
	â›   (ğŸ˜¨ ğŸ˜© ğŸ˜ª ğŸ˜« ğŸ˜¬ ğŸ˜­ ğŸ˜® ğŸ˜¯ ğŸ˜° ğŸ˜± ğŸ˜² ğŸ˜³ ğŸ˜´ ğŸ˜µ ğŸ˜¶ ğŸ˜·)

<i>(define L (shuffle (iota 16)))</i>  â›   L
<i>L</i>  â›   (13 10 5 3 2 0 7 6 1 9 15 4 11 8 12 14)
<i>(list-sort < L)</i>  â›   (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15)

<i>(define (my-sort-function a b)(write 'compare a b) (> a b))</i>  â›   my-sort-function
<i>(list-sort my-sort-function '(albert simon martine maurice))</i>
compare     albert     simon    
compare     albert     martine    
compare     simon     martine    
compare     albert     maurice    
compare     simon     maurice    
compare     martine     maurice    
                   â›   (simon maurice martine albert)
                   
<i>(define L '(ğŸŒ¿ ğŸŒ¿ ğŸŒ¿ ğŸ„ ğŸŒ¹ ğŸŒ¹ ğŸŒ» ğŸŒ¿ ğŸŒ¿ ğŸŒ»))</i>
<i>(group L)</i>
    â†’ ((ğŸŒ¿ ğŸŒ¿ ğŸŒ¿) (ğŸ„) (ğŸŒ¹ ğŸŒ¹) (ğŸŒ») (ğŸŒ¿ ğŸŒ¿) (ğŸŒ»))
<i>(group* L)</i>
    â†’ ((ğŸŒ¿ ğŸŒ¿ ğŸŒ¿ ğŸŒ¿ ğŸŒ¿) (ğŸ„) (ğŸŒ¹ ğŸŒ¹) (ğŸŒ» ğŸŒ»))
    
<i>(flatten '((ğŸŒ¹ ğŸŒ¹) (ğŸŒ») (ğŸŒ¿ ğŸŒ¿ ğŸŒ¿ ğŸŒ¿ ğŸŒ¿) (ğŸ„)))</i>
    â†’ (ğŸŒ¹ ğŸŒ¹ ğŸŒ» ğŸŒ¿ ğŸŒ¿ ğŸŒ¿ ğŸŒ¿ ğŸŒ¿ ğŸ„)
    
<i>(define task '(0 1 2 4 6 7 8 11 12 14 15 16 17 18 19 27 28 29 30 31 32 33))</i>
<i>(define ( g1 a b) (or (= a b) (= b (1+ a))))</i> ;; n and n+1 are considered equal
<i>(group task g1)</i>
   â†’ ((0 1 2) (4) (6 7 8) (11 12) (14 15 16 17 18 19) (27 28 29 30 31 32 33))
   
<i>(define L '((a b) (a c) (b d) (b e) (a z) (a x)))
(define (same u v) (eq? (first u) (first v)))
(group* L same)</i>
    â†’ (((a b) (a c) (a z) (a x)) ((b d) (b e)))

</pre>

<h2 id = "list.lib"> ğŸ“–  List library</h2>
<p>This library imports various operations on lists. The list-xxx! operations modify the list in place. Other operations return a new list. These functions do not operate on circular lists.
<br>
To create a new shallow copy of a list, use (append list ()) .
</p>
<h4 id='list-partition'>(<b>list-partition </b><i>list predicate:1</i>)  â†’  new list (left-list right-list) such as for each element <i>left</i> in left-list : (predicate <i>left</i>) is  #t, other elements in right-list.</h4>
<h4 id='list-partition'>(<b>list-partition </b><i>list compare-proc:2 pivot</i>)  â†’  new list (left-list right-list) such as for each element <i>left</i> in left-list : (compare-proc <i>left</i> pivot) is  #t, other elements in right-list.</h4>
<br>
<h4 id='list-rotate'>(<b>list-rotate </b><i>list n</i>)  â†’  new list rotated left n times.<small> n may be negative</small></h4>
<h4 id='list-rotate!'>(<b>list-rotate! </b><i>list n</i>)  â†’  list is rotated left n times</h4>
<h4 id='list-rotate-right!'>(<b>list-rotate-right! </b><i>list n</i>)  â†’  list is rotated right n times</h4>
<br>
<h4 id='list-insert!'>(<b>list-insert! </b><i>list new-item after</i>)  â†’  inserts new-item after after-item; uses eq? predicate to find after-item; error if after-item is not found.</h4>
<h4 id='list-replace!'>(<b>list-replace! </b><i>list old-item new-item</i>)  â†’  replaces (one time) old-item by new-item; uses eq? to find old-item; return #f if old-item not found.</h4>
<h4 id='list-delete'>(<b>list-delete </b><i>list item</i>)  â†’  new list, with item deleted; #f if item not found.</h4>

<pre>
;; see <a href="http://rosettacode.org/wiki/Sorting_algorithms/Selection_sort#EchoLisp">selection sort</a> for examples of use.
</pre>

<h3>Permutations and combinations</h3>
<h4 id='sublists'>(<b>sublists </b><i>list p</i>)  â†’  returns a list of the 2<sup>N</sup> sublists of <i>list</i> in unspecified order, including the empty - null - list.  <small>Rem. (sublists ())  â†’  (()).</small></h4>
<br>
<h4 id='list-permute'>(<b>list-permute </b><i>list permutation</i>)  â†’  a new permutation of list. <i>permutation</i> is a list or vector permutation of the integers 0..n-1 where n is length(list). The permutation may include repetitions.</h4>
<br>
<h4 id='permutations'>(<b>permutations </b><i>list</i>)  â†’  returns a list of the n! permutations of the elements of <i>list</i>.</h4>
<h4 id='in-permutations'>(<b>in-permutations </b><i>list</i>)  â†’  returns a stream delivering the n! permutations of the list (0 ... n-1).</h4>
<br>
<h4 id='combinations'>(<b>combinations </b><i>list p</i>)  â†’  returns a list of the combinations of the n elements of <i>list</i> taken p at a time witout repetition. The number of combinations is (<a href ="#Cnp">Cnp</a> n p) = n!/(p! * (n-p)!), p <=n.</h4>
<br>
<h4 id='combinations/rep'>(<b>combinations/rep </b><i>list p</i>)  â†’  returns a list of the combinations of the n elements of <i>list</i> taken p at a time with possible repetition. The number of combinations with repetition is (Cnp n+p-1 p), p may be > n.</h4>

<pre>
(lib 'list)

<i>(list-rotate '(a b c d) 1)</i> â†’ (b c d a)
<i>(list-rotate '(a b c d) 40000001)</i> â†’ (b c d a)

<i>(list-partition (shuffle (iota 15)) < 9.5)</i>
    â†’ ((3 6 9 0 7 1 4 2 5 8) (12 13 14 10 11))
    
<i>(define L '( 6 7 4 7 4 8 3 4))
(while (list-replace! L 4 666))</i>
    L   â†’ (6 7 666 7 666 8 3 666)
    
<i>(sublists (iota 3))</i>  â†’   (() (2) (1) (1 2) (0) (0 2) (0 1) (0 1 2))
<i>(length (sublists (iota 20)) )</i>  â†’   1048576 ;; 2<sup>20</sup>

<i>(for ((p (in-permutations 3))) (write p))</i>
    â†’  (0 1 2) (0 2 1) (2 0 1) (2 1 0) (1 2 0) (1 0 2) 
    
<i>(list-permute '(a b c d) '( 3 2 1 0))</i> â†’ (d c b a)
<i>(list-permute '(a b c d) '( 0 0 1 2))</i> â†’ (a a b c)
<i>(list-permute '(a b c d) #( 0 0 1 2))</i> â†’ (a a b c)

<i>(combinations '(a b c d) 3)</i>   â†’ ((a b c) (a b d) (a c d) (b c d))
<i>(combinations/rep '(a b) 3)</i>  â†’ ((a a a) (a a b) (a b b) (b b b))
</pre>


<h2 id = "environment">Environments</h2>
<p> An environment is a set of bindings which can be seen as a list ((name<sub>1</sub> value<sub>1</sub>)(name<sub>2</sub> value<sub>2</sub>) ...). Function calls, <b>let</b> forms, <b>for</b> loops create new environments, which are chained using the 'parent' link. Functions are provided to inspect environment, or create new ones. The printed form of an environment is #|environment name| .  </p>
<br> 
<h4 id='environment?'>(<b>environment? </b><i>obj</i>) is obj an environment ?  â†’ #t or #f</h4>
<h4 id='bound?'>(<b>bound? </b><i>symbol</i>)  â†’ #f or the environment in which symb is bound</h4>
<h4 id = "environment-current">(<b>environment-current</b>)  â†’ environment in which this function is called</h4>
<h4 id='environment-bindings'>(<b>environment-bindings </b><i>env</i>)  â†’ env-list = ((name<sub>1</sub> value<sub>1</sub>) (name<sub>2</sub> value<sub>2</sub>) ...)</h4>
<h4 id='environment-parent'>(<b>environment-parent </b><i>env</i>)  â†’ null or parent</h4>
<h4 id='environment-of'>(<b>environment-of </b><i>lambda-closure | function-id | symbol </i>)  â†’ its environment or null</h4>
<h4 id='environment-new'>(<b>environment-new </b><i>env-list</i>)  â†’ new environment with bindings (name<sub>i</sub> value<sub>i</sub>)</h4>
<h4><b>system-global-environment</b>  â†’ starter environment</h4>
<h4><b>user-initial-environment</b>  â†’ user environment = top-level environment</h4>
<br>
<h4 id='eval'>(<b>eval </b><i>expression</i>)  â†’ evaluates expression in current environment</h4>
<h4 id='eval'>(<b>eval </b><i>expression env</i>)  â†’ evaluates expression in environment <i>env</i></h4>

<pre>
</pre>


<h2 id="functions">Functions</h2>
<h3>Function call</h3>
<h4 id='operator'>(<b>operator </b><i>val<sub>1</sub> â€¦ val<sub>i</sub> â€¦ val<sub>n</sub></i>) â› function call</h4>
<p>Applies an operator to a list of values. <b>operator</b> and val<sub>i</sub> are evaluated before application. The <b>operator</b> may be a lambda expression i.e. an anonymous function such as (lambda(x) (+ x x)), a built-in function : sin, cos, .. , a user defined function or an expression which evaluates to an operator.
</p>
<h4 id='apply'>(<b>apply </b><i>fun list</i>) â› applies a function to a list of values</h4>

<pre>
<i>(sin 7)</i>  â›   0.656986598
<i>(sin (+ 4 3))</i>  â›   0.656986598
<i>(sin (length '(a b c d e f g)))</i>  â›   0.656986598

<i>((lambda(x) (sin x)) 7)</i>  â›   0.656986598
<i>(define (f x) (sin x))</i>  â›   f
<i>(f 7)</i>  â›   0.656986598

<i>((lambda (x) ((if (> x 6) sin cos) x)) 7)</i>  â›   0.656986598
<i>(define xsin sin)</i>  â›   xsin
<i>(xsin 7)</i>  â›   0.656986598

<i>(define a 0)</i>  â›   a
<i>(set! a sin)</i>  â›   a
<i>(a 7)</i>  â›   0.656986598

<i>(apply + '(1 2 3 4 5))</i>  â›   15
<i>(apply * (range 1 11))</i>  â›   3628800  ;; âˆi iâˆˆ{1â€¦10} = 10!
<i>(apply + (iota 1000))</i>  â›   499500  ;; âˆ‘i  iâˆˆ{0â€¦999}

;; ğŸ‘ Sum of squares of the 7 first primes.
<i>(apply + (map * (primes 7) (primes 7)))</i> â†’ 666 
</pre>

<h4>(<b>take </b><i>fun:1 n</i>)  â› list ((fun 0) (fun 1) ... (fun n-1)). fun:1 is a function of one integer argument in {0, 1, 2 ...}</h4>
<pre>
<i>(take factorial 10)</i>
    â†’ (1 1 2 6 24 120 720 5040 40320 362880)

<i>(define (f n) (cos (* PI n)))
(take f 12)</i>
    â†’ (1 -1 1 -1 1 -1 1 -1 1 -1 1 -1)
</pre>


<h3 id = "lambda">Lambda</h3>
<p> A lambda expression - &lambda;-expr - is an anonymous function with no arguments, a fixed number of arguments, or variable number of arguments. &lambda;-exprs support default values for arguments. &lambda;-exprs evaluate to themselves. To apply a &lambda;-expr to a list of values, write ( &lambda;-expr  val<sub>1</sub> ... val<sub>n</sub>) .<br>
The &lambda;-expr evaluates in sequence its body, a list of expressions expr<sub>i</sub>, and the returns the value of the last evaluated expr<sub>i</sub>.
<br>
&lambda;-exprs with free variables inside - i.e. variables which are not arguments, are said to be <u>closures</u>. The value - binding - of a free variable is taken from the &lambda;-expr  definition environment.
<br>
ğŸ‘“ Lambda formal parameters such as x, y, name are printed out as _x, _y, _name ...
</p>

<h4 id='lambda'>(<b>lambda </b><i>(arg<sub>1</sub> â€¦ arg<sub>n</sub></i>) expr<sub>1</sub> â€¦ ) â› n arguments</h4>
<h4 id='lambda'>(<b>lambda </b><i>(arg<sub>1</sub> .. arg<sub>n</sub> (arg<sub>n+1</sub> def<sub>n+1</sub>) ..(arg<sub>p</sub> def<sub>p</sub>)) expr<sub>1</sub> â€¦</i>) â› arguments with default values</h4>
<h4 id='lambda'>(<b>lambda </b><i>(arg<sub>1</sub> â€¦ arg<sub>n</sub> . rest-id</i>) expr<sub>1</sub> â€¦) â› n arguments + variable number of args bound to rest list</h4>
<h4 id='lambda'>(<b>lambda </b><i> rest-id expr<sub>1</sub> â€¦ </i>) â› variable number of arguments</h4>
<pre>
<i>(lambda (x) (+ x x))</i>  â›   (Î» (_x) ( + _x _x)) ;; self evaluates

<i>((lambda (x) (+ x x)) 42)</i>  â›   84 ;; apply &lambda;-expr  to 42
<i>((lambda (x y z t) (+ x y z t)) 1 2 3 4)</i>  â›   10

<i>((lambda (x y . rest) (write x y rest) (+ x y)) 1 2 3 4 5 6)</i>  ;; binds rest to (3 4 5 6)
	1 2 (3 4 5 6)   
	â› 3
	
;; binds <i>all</i> to list of argument values
<i>((lambda all all) 'a 'b 'c 'd)</i>  â›   (a b c d)

;; default value for <i>nom</i>
<i>((lambda (prenom (nom 'gallubert)) (list prenom nom)) 'simon)</i>  
	â›   (simon gallubert)
<i>((lambda (prenom (nom 'gallubert)) (list prenom nom)) 'simon 'de-jeumont-schneidre)</i>  
	â›   (simon de-jeumont-schneidre)
</pre>

<h2 id="closure">Closures</h2>
<p>Closures are no more, no less than lambda expressions with their own environment. The free variables inside the lambda definition are bound to their values at lambda definition time.</p>

<pre>
;; f returns a closure, with free variables y and z
<i>(define ( f y z) 
	(lambda (x)
		(writeln (environment-bindings (environment-current))) 
		(+ x y z)))</i> 
		
<i>(define g (f 100 333) )</i>  
<i>g</i>  â†’   (ğŸ”’ Î» (_x) 
			(#writeln (#environment-bindings (#environment-current))) 
			(#+ _x <span style="color:blue">y z</span>))

<i>(g 666)</i>  ;; show the lambda environment bindings
	(("y" 100) ("z" 333)) 
	â†’   1099

;; simple currying : transform an n-args procedure into a lambda expression with (n-1) arguments.
<i>(define (kurry proc x0) (lambda(y) (proc x0 y)))</i>  

<i>(kurry * 2)</i>  â†’   (ğŸ”’ Î» (_y) (<span style="color:blue">proc x0</span> _y))
<i>(define *-2 (kurry * 2))</i>  

<i>(*-2 666)</i>  â†’   1332

;; Example : drawing a family of curves (s-curve x gamma)
;; (define (f-gamma x gamma) (lambda(x) (s-curve x gamma)))
;; and plot (f-gamma x gamma) - which is a function of x only - for each gamma
;; See or load <a href="./lib/curves.glisp">curves.glisp</a>

<img src = "./images/s-curve-family.png" width="300" height="300">

;; Example : implement stack operations in message passing style
;; See or load <a href="./lib/snippets.glisp">snippets</a>
</pre>





<h3 id = 'fundef'>Function definition</h3>
<p>A function - or procedure - is a named lambda expression. (define (f x y) (+ x y)) is the same as (define f (lambda(x y) (+ x y))). Evaluating f - the symbol - will return its associated lambda expression.
<br>
Primitives - built-in - functions symbols such as sin,append, ...  evaluate as <span style="color:blue">#sin,  #append</span> which is the printed representation of a built-in procedure.
</p><p>
Good practice: the first expression of the body may be a documentation string, which will be displayed by (usage function-id) or (us function-id).
</p>

<h4 id='define'>(<b>define </b><i>(function-id  arg<sub>1</sub> â€¦ arg<sub>n</sub></i>) expr<sub>1</sub>  â€¦)</h4>
<h4 id='define'>(<b>define </b><i>(function-id  arg<sub>1</sub> ... arg<sub>n</sub> (arg<sub>n+1</sub> def<sub>n+1</sub>) ... (arg<sub>p</sub> def<sub>p</sub>)) </i> expr<sub>1</sub>  â€¦)</h4>
<h4 id='define'>(<b>define </b><i>(function-id  arg<sub>1</sub> â€¦ arg<sub>n</sub> . rest-id</i>) expr<sub>1</sub> â€¦)</h4>

<pre>
<i>(define (f x) (+ x x))</i>  â›   f
<i>f</i> â†’ (Î» (_x) (#+ _x _x))
<i>(define (g x) "square : (g x) â› x^2"  (* x x))</i>  â›   g
<i>(us g)</i>
<i>(define (h x) (+ (f x) (g x)))</i>  â›   h

<i>(f 1000)</i>  â›   2000
<i>(g 1000)</i>  â›   1000000
<i>(h 1000)</i>  â›   1002000

<i>(define (w u) (f (g (h u))))</i>  â›   w
<i>(w 12)</i>  â›   56448

<i>(define (f x y . rest) (write x y rest) (+ x y))</i>  â›   f
<i>(f 12 13 14 15 16)</i>   12 13 (14 15 16)   â›   25
	
<i>(define (f x . add-list) (* x (apply + add-list)))</i>  â›   f
<i>(f 10 1 2 3 4 5)</i>  â›   150 ;; 10 * (1+2+3+4+5)
	
;; default values
<i>(define (hit x (target 0) (precision 0.0001)) 
		(if (< (abs (- x target)) precision) "OK" "KO"))</i>  â›   hit
<i>(hit 0.01)</i>  â›   "KO"
<i>(hit 0.00000001)</i>  â›   "OK"
<i>(hit (acos -1) PI)</i>  â›   "OK"

<i>(define (multi-valued x y z) (values (+ x y) (+ x z) (+ y z)))</i>  â›   multi-valued
<i>(define-values (a b c) (multi-valued 11 12 13))</i>  â›   (a b c)
	<i>a</i>  â›   23  <i>b</i>  â›   24  <i>c</i>  â›   25
</pre>



<h3 id="recursion">Tail recursion - No Fibonacci was harmed during the making of this <span style="text-decoration:line-through">television</span> computer program</h3>
<p>Tail call elimination is implemented in EchoLisp for recursive tail calls.</p>
<pre>
<i>(define (multiplier n m (acc 0))</i> ;; perform m additions
	<i>(if (zero? m) acc 
	(multiplier n (1- m) (+ acc n))))</i>  â›   multiplier
<i>(multiplier 3 1000)</i>  â›   3000
<i>(multiplier 3 1000000)</i>  â›   3000000

<i>(time (multiplier 3 1000000))</i>  â›   3000000
	1099 msec
<i>(time (multiplier PI 1000000))</i>  â›   3141592.6535849427
	1091 msec
	
<i>(trace 'multiplier)</i>  â›   #t
<i>(multiplier 3 4)</i>  â›   12
ğŸ’¡ [0]     --> multiplier _n 3
ğŸ’¡ [0]     --> multiplier _m 4
ğŸ’¡ [0]     --> multiplier _acc 0
ğŸ’¡ [0]     multiplier <-- 12

;; ğŸ˜– The following is <em>NOT</em> tail call recursive : see [stack depth] in trace.
<i>(define (multiplier n m) 
	(if (= 1 m) 
	n 
	(+ n (multiplier n (1- m)))))</i>  â›   multiplier
	
<i>(multiplier 3 4)</i>  â›   12
ğŸ’¡ [0]     --> multiplier _n 3
ğŸ’¡ [0]     --> multiplier _m 4
ğŸ’¡ [1]         --> multiplier _n 3
ğŸ’¡ [1]         --> multiplier _m 3
ğŸ’¡ [2]             --> multiplier _n 3
ğŸ’¡ [2]             --> multiplier _m 2
ğŸ’¡ [3]                 --> multiplier _n 3
ğŸ’¡ [3]                 --> multiplier _m 1
ğŸ’¡ [3]                 multiplier <-- 3
ğŸ’¡ [2]             multiplier <-- 6
ğŸ’¡ [1]         multiplier <-- 9
ğŸ’¡ [0]     multiplier <-- 12

<i>(multiplier 3 1000000)</i>
	ğŸ˜–ï¸ <span style="color:red">error: stack[10002] : stack overflow : 10001</span>
</pre>

<h3>Remember : Caching functions values</h3>
<p> For functions which take one integer argument - and may return any object - , and in case of frequent access or recursive calls, the cache allows to compute <b>once</b>, store and retrieve the values of (f n). The computation of (f n) should not include side effects, or take into account the values of global variables which may change.</p>
<h4 id='remember'>(<b>remember </b><i>function-name  </i>)  â†’ sets an empty cache for the function</h4>
<h4 id='remember'>(<b>remember </b><i>function-name init-vector </i>)  â†’ sets an initialized cache for the function : f(0) = v[0], ... </h4>
<h4 id='forget'>(<b>forget </b><i>function-name</i>)  â†’ suppress the cache for the unction</h4>
<h4 id='cache'>(<b>cache </b><i>function-name</i>)  â†’ #f or vector of values f(0) f(1) ... </h4>
<h4 id='cache-size'>(<b>cache-size </b> )  â†’ cache size - the same for all functions
<h4 id='cache-size'>(<b>cache-size </b>  <i>new-size</i>)  â†’ sets the cache size

<pre>
;; fob(n) = fob(n-1) + fob(n-2) + fob(n-3)
<i>(define *calls* 0)</i> ;; calls counter
<i>(define (fob n) 
	(++ *calls*)</i> ;; bumps counter
		<i>(if (< n 3) n 
		(+ (fob ( - n 1)) (fob (- n 2)) (fob (- n 3)))))</i>  â†’   fob

<i>(fob 20)</i>  â†’   101902
<i>*calls*</i>  â†’   <span style="color:red">128287</span> ;; ğŸ˜“

<i>(remember 'fob)</i>  â†’   #t
<i>(set! *calls* 0)</i>  â†’   *calls*
<i>(fob 20)</i>  â†’   101902
<i>*calls*</i>  â†’   <span style="color:red">21</span> ;; ğŸ˜ƒ 

<i>(define (fib n) (if (< n 2) n (+ (fib (1- n)) (fib (- n 2)))))</i>
<i>(time (fib 27))</i> â†’ 196418 time:435 msec

<i>(define (fib n)  (+ (fib (1- n)) (fib (- n 2)))) </i>
<i>(remember 'fib #(0 1))</i> ;; first two values in cache
<i>(time (fib 27))</i> â†’ 196418 time:0 msec
</pre>


<h3>Functions composition</h3>
<h4 id='pipeline'>(<b>-> </b><i> x f<sub>1</sub> f<sub>2</sub> f<sub>2</sub> ...</i>) pipeline first  â› (f<sub>last</sub>  ... ( f<sub>2</sub> ( f<sub>1</sub> x))). The f<sub>i</sub> are functions symbols or function calls : (f<sub>i</sub> a b c ...). If f<sub>i</sub> is a function call, then the value x for f<sub>1</sub>, or the previous result for f<sub>i&gt;1</sub> is inserted <b>first</b> in the list of parameters. <small> If the parameters list include one or more place holders : _ , then  a replacement is made at the placeholder location, instead of first location.</small>  </h4>
<br>
<h4 id='pipeline'>(<b>->> </b><i> x f<sub>1</sub> f<sub>2</sub> f<sub>3</sub> ...</i>) pipeline last â› (f<sub>last</sub> ... ( f<sub>2</sub> ( f<sub>1</sub> x))). If f<sub>i</sub> is a function call, then the value x for f<sub>1</sub>, or the previous result for f<sub>i&gt;1</sub> is inserted <b>last</b> in the list of parameters. <small>If the parameters list include one or more place holders : _ , then a replacement is made at the placeholder location, instead of last location.</small>  </h4>
<br>
<h4 id='curry'>(<b>curry </b><i>proc l<sub>1</sub> l<sub>2</sub> â€¦</i>) â›  returns a curried-proc - lambda expression - such as the call (curried-proc r<sub>1</sub> r<sub>2</sub> â€¦) is equivalent to the call (proc  l<sub>1</sub> l<sub>2</sub> â€¦  r<sub>1</sub> r<sub>2</sub> â€¦)</h4>

<h4 id='rcurry'>(<b>rcurry </b><i>proc r<sub>1</sub> r<sub>2</sub> â€¦</i>) right-curry  â›  returns a right-curried-proc - lambda expression - such as the call (right-curried-proc l<sub>1</sub> l<sub>2</sub> â€¦) is equivalent to the call (proc l<sub>1</sub> l<sub>2</sub> â€¦ r<sub>1</sub> r<sub>2</sub> â€¦ )</h4>
<p>
curry is functionally equivalent to: (define (curry proc . left-args) (lambda right-args (apply proc (append left-args right-args))))
</p>

<h4 id='compose'>(<b>compose </b><i>f:1 g:1 h â€¦ last:n</i>) â› &lambda; : f âˆ˜ g âˆ˜ h âˆ˜ â€¦ âˆ˜ last </h4>
<h4 id='iterate'>(<b>iterate </b><i>f:1 n</i>) â› &lambda; : f âˆ˜ f âˆ˜ f âˆ˜ â€¦  = f<sup>n</sup></h4>

<pre>
<i>(-&gt; 0 sin cos display)</i>  â†’ 1 ;; same as (display ( cos (sin x)))
  
<i>(define (f x) (-&gt; x (* 10) (/ 2) (writeln "f")))</i> ;; same as (writeln (/ (* x 10) 2) "f")
<i>(f 4)</i>
    â†’    20     "f"    
<i>(define (g x) (-&gt;&gt; x (* 10) (/ 2) (writeln "g")))</i> ;; same as (writeln  "g" (/  2 (* 10 x)))
<i>(f 4)</i>
     â†’   "g"     1/20  
     
;; using on an infinite list [0 ..]
;; sum of the first 10 even squares
(lib 'sequences)
<i>( ->> [0 ..] (map * _ _ )  (filter even?) (take 10) (apply +))</i>
     â†’  1140  

<i>(define add42 (curry + 42))</i>  â†’   add42
<i>(add42 666)</i>  â†’   708

<i>(map (curry cons 'simon) '( gallubert garfunkel et-merveilles))</i> 
   â†’   ((simon . gallubert) (simon . garfunkel) (simon . et-merveilles))
;; an other way :
<i>(map cons (circular-list 'simon) '( gallubert garfunkel et-merveilles))</i> 
   â†’   ((simon . gallubert) (simon . garfunkel) (simon . et-merveilles))

<i>(define f (compose sin cos))</i>  â›   f
<i>(f 7)</i>  â›   0.6844887989926141
<i>(sin(cos 7))</i>  â›   0.6844887989926141

<i>(define abscos (compose abs cos))</i>  â›   abscos
<i>(abscos PI)</i>  â›   1

<i>(define g (compose exp log))</i>  â›   g
<i>(g 42)</i>  â›   42.00000000000001

<i>(define cos10 (iterate cos 10))</i>  â›   cos10
<i>(cos10 1.0)</i>  â›   0.7442373549005569
<i>(define cos100 (iterate cos10 10))</i>  â›   cos100
<i>(cos100 0.6)</i>  â›   0.7390851332151605
<i>(cos 0.7390851332151605)</i>  â›   0.7390851332151608 ;; ğŸ˜œ fixed point found
</pre>

<h3 id='inline'>Inline functions</h3>
<p>Inline functions are standard javascript mathematical expressions -strings - compiled into functions. They may be used for speed, or convenient one-liners, for function plotting, etc. They use up to 4 parameters, namely and mandatorily x,y,z,t. They cannot be re-defined into standard lambda functions. An inline function must use the <b>return</b> keyword. The ^ (exponentiation) operator is allowed: x^4 is expanded into pow(x,4).
</p>
<p>Known constant and functions (all arguments values ar numbers) :
<br>[E, PI, SQRT2, acos, asin, atan, atan2, ceil, floor, hsl , max, min, random, sin, cos, tan, log, pow, exp, random, round, rgb ,sqrt, cbrt, fract,  /* integers  */ isprime,  factor, factorial, issquare, gcd, lcm, powmod] .
</p>
<h4 id="inline">(<b>inline</b> (function-name x [y [ z [ t]]]) expression-string)  â› function-name or #f in case of syntax error.</h4>
<pre>
(inline (sphere x y z) "x-= 3 ; return x^2 + y^2 + z^2 - 25")
(plot-3d-xyz sphere)
</pre>

<h3 id='compile.lib'>Compile.lib - Functions compilation</h3>
<p>Functions may be compiled into javascript functions, for better performance and lesser clarity. Speed improvement is x3 or x4. Note that no type checking nor trace is performed by compiled functions. The printed name of a compiled function is #_ğŸ”·_name,  or #_ğŸ”¶_name for "float" functions.
<h4 id = 'compile'>(<b>compile</b> <i>function-name</i> [<i>options-string</i>]) â› #t or #f</h4>
<p><i>options-string</i> may include the following options:
<ul>
<li>-v, -verbose : verbose compilation</li>
<li>-a, -all : recursively compiles all user functions called by <i>function-name</i></li>
<li>-f, -float : all operands (integers, rationals, bigints) are translated to javascript (float) numbers. Do not use if you need exact rational/big integers arithmetic, or complex values.
</ul>
</p>
<pre>
<i>(lib 'plot)</i>
<i>(lib 'compile)</i>
<i>(define (pixel x y) 
	(rgba (atan x) (atan y) 0 (+ (sin x) (sin y))))</i>
	
pixel â†’ (Î» (_x _y) (#rgba_clamp (#atan _x) (#atan _y) 0 (#+ (#sin _x) (#sin _y))))
	
<i>(compile 'pixel "-v-f")</i>
ğŸ’¡ [0]     compiling _ğŸ”¶_pixel ((#rgba_clamp (#atan _x) (#atan _y) 0 (#+ (#sin _x) (#sin _y))))

;; generated code: 
<span style="color:magenta">var ref,top = _blocks[_topblock];
/* */return (
/* */_rgba_clamp(Math.atan(_stack[top]),Math.atan(_stack[1 + top]),0,
     (Math.sin(_stack[top]) + Math.sin(_stack[1 + top])))
/* */);</span>
pixel  â†’ (Î» (_x _y) (#_ğŸ”¶_pixel))

;; "-float" option in action
<i>(define (f x y) (+ x y))</i>
<i>(compile 'f)</i>
    f â†’ (Î» (_x _y) (#_ğŸ”·_f))
    (f 1/4 1/3)  â†’  7/12
<i>(compile 'f "-float")</i>
    f â†’ (Î» (_x _y) (#_ğŸ”¶_f))
    (f 1/4 1/3) â†’ 0.5833333333333333
</pre>



<h2 id='let'>Local bindings</h2>
<p>The let family forms introduce local bindings which are only valid inside the (let ....) lexical scope. A (let ...) form generates one (or more) &lambda; expressions with their own environments.</p>
</p>
<h4 id='let'>(<b>let </b><i>((id<sub>1</sub> val-expr<sub>1</sub></i>) â€¦) expr<sub>1</sub> â€¦ expr<sub>n</sub>) â› Parallel binds id<sub>i</sub> to val-expr<sub>i</sub> and evals expr<sub>1</sub> ..expr<sub>n</sub></h4>
<h4 id='let'>(<b>let </b><i>proc-id ((id<sub>1</sub> val-expr<sub>1</sub></i>) â€¦) expr<sub>1</sub> â€¦ expr<sub>n</sub>) â› Binds proc-id to the let lambda body</h4>
<h4 id='let*'>(<b>let* </b><i>((id<sub>1</sub> val-expr<sub>1</sub></i>) â€¦) expr<sub>1</sub> â€¦ expr<sub>n</sub>)  â› Sequential binds id<sub>i</sub> to val-expr<sub>i</sub> and evals expr<sub>1</sub> ..expr<sub>n</sub></h4>
<h4 id='letrec'>(<b>letrec </b><i>((id<sub>1</sub> val-expr<sub>1</sub></i>) â€¦) expr<sub>1</sub> â€¦ expr<sub>n</sub>)  â› Recursively binds id<sub>i</sub> to val-expr<sub>i</sub> and evals expr<sub>1</sub> ..expr<sub>n</sub></h4>

<pre>
<i>(let ((x 3)(y (+ 10 20))) (* x y))</i>  â†’   90

<i>(let ((x 3) (y (+ x x))) (* x y))</i>  
	â†’   â›” error: |user| : unbound variable : x
	
<i>(let* ((x 3) (y (+ x x))) (* x y))</i>  â†’   18

<i>(letrec 
	[(local-even? 
		(lambda (n) (if (= n 0) #t 
		(local-odd? (- n 1))))) 
	(local-odd? 
		(lambda (n) (if (= n 0) #f 
		(local-even? (- n 1)))))] 
	(list (local-even? 23) (local-odd? 23)))</i>  â†’   (#f #t)
	
<i>(let countdown 
	[(i 10)] 
		(if (= i 0) 
			'liftoff 
			(begin (write i) (countdown (- i 1)))))</i>  
	10 9 8 7 6 5 4 3 2 1
	â†’   liftoff
</pre>

<h3 id="local-var">Local variables</h3>
<p>An other way to use local variables/functions inside functions is to <b>define</b> them inside the function body, or to declare them as optional arguments. These variables are allocated onto the stack.</p>
<pre>
 ;; let
<i>(define (f x y)
	(let ((r2 (+ (* x x) (* y y)))) 
	;; computations using r2 here ...
	r2))</i>
	
    f â†’  (f (_x _y) ((#Î» (_r2) _r2) (+ (* _x _x) (* _y _y))))
	(f 30 40)
	â†’  2500

 ;; local define
<i>(define (f x y)
	(define r2 (+ (* x x) (* y y)))
	;; ...
	r2)</i>
	
 	f â†’ (f (_x _y _r2) (set! _r2 (+ (* _x _x) (* _y _y))) _r2)
 
 ;; optional arg
<i>(define (f x y (r2)) 
    (set! r2 (+ (* x x) (* y y))) 
    ;; ...
    r2)</i>

 	f â†’ (f (_x _y _r2) (set! _r2 (+ (* _x _x) (* _y _y))) _r2)
 	
;; defining an internal function
<i>(define (f x y) 
	(define (g a b) (+ (* a a) (* b b))) 
	;; ...
	(g x y))</i>
	
	f  â†’ (f (_x _y _g) (set! _g (#Î» (_a _b) (+ (* _a _a) (* _b _b)))) (_g _x _y))
	(f 3 4)
	â†’ 25
</pre>



<h2 id = "assignment">Variables - Definitions -</h2>
<h3 id="definitions">Definition</h3>
<h4 id='define'>(<b>define </b><i>var-id value</i>) sets a binding for var-id - a symbol - in the current environment, which is user-initial-environment if the definitions is made at top-level. â›  var-id</h4>
<p>
<small>N.B: Definitions of variables or functions are possible inside a function definition. These variables will act as <a href="#local-var">local variables</a>. 
See a <a href="http://rosettacode.org/wiki/Man_or_boy_test#EchoLisp">convoluted</a> example. </small>
</p>
<h4 id='define-global'>(<b>define-global </b><i>expr value</i>) expr must evaluate to a symbol, the binding of which is set to value, inside the global - user-initial - environment. â›  symbol</h4>
<br>
<h4 id='define-constant'>(<b>define-constant </b><i>CONSTANT-ID value</i>) installs a replacing macro for CONSTANT-ID. â› CONSTANT-ID</h4>
<br>
<h4 id='define-values'>(<b>define-values </b><i>(var-id<sub>1</sub> â€¦ var-id<sub>i</sub> ..</i>) value-expression) define several var's at once, â› (var-id<sub>1</sub> â€¦ var-id<sub>i</sub> ..)</h4>
<h4 id='values'>(<b>values </b><i>val<sub>1</sub> â€¦ val<sub>i</sub> â€¦</i>) â› value expression</h4>

<pre>
<i>(define a 123)</i>  â›   a
<i>a</i>  â›   123

<i>(define b PI)</i>  â›   b
<i>b</i>  â›   3.141592653589793
<i>(set! b "albert")</i>  â›   b
<i>b</i>  â›   "albert"

<i>(define cube (lambda(x) (* x x x)))</i>  â›   cube
<i>(cube 666)</i>  â›   295408296

<i>(define-values (a b c) (values 10 (* 10 10) (* 10 10 10)))</i>  â›   (a b c)
<i>(+ a b c)</i>  â›   1110

<i>(define-constant PI/4 (/ PI 4))</i>  â›   PI/4
<i>PI/4</i>  â›   0.7853981633974483

;; local - inner - definitions
<i>(define (f x y)
	(define local-z ( + x y)) ;; var
	(define (local-f u v) (* u v)) ;; function
	(local-f local-z local-z))</i> ;; call of locally defined function 
<i>(f 10 20)</i>  â†’   900 
</pre>

<h3>Assignment</h3>
<h4 id='set!'>(<b>set! </b><i>var-id value</i>) â› Sets a new binding for var-id in the current environment. The var-id must be defined - either globally, or locally such as a function argument -  before being set. <i>var-id</i> is not evaluated. Returns (void)</h4>
<h4 id='setv!'>(<b>setv! </b><i>var-id value</i>) â› same as set! , but returns <i>value</i>.</h4>
<br>
<h4 id='set!-values'>(<b>set!-values </b><i>(var-id ...) values-expression</i>) â› new parallel bindings for var-id's in the current environment. Returns (void). <small><i>values-expression</i> is either (values a b ..) or a list ( a b ...)</small></h4>
<br>
<h4 id='++'>(<b>++ </b><i>var-id </i>) â› Binds var-id to its value + 1. Same as (set! var-id (+ var-id 1)). Returns new <i>var-id</i> value.</h4>
<h4 id='--'>(<b>-- </b><i>var-id </i>) â› Binds var-id to its value - 1. Same as (set! var-id (- var-id 1)). Returns new <i>var-id</i> value.</h4>
<br>
<h4 id='+='>(<b>+= </b><i>var-id increment</i>) â› Binds var-id to its value + <i>increment</i>. Same as (set! var-id (+ var-id increment)). Returns new <i>var-id</i> value.</h4>
<h4 id='-='>(<b>-= </b><i>var-id increment</i>) â› Binds var-id to its value - <i>increment</i>. Same as (set! var-id (- var-id increment)). Returns new <i>var-id</i> value.</h4>
<br>
<h4 id='*='>(<b>*= </b><i>var-id multiplier</i>) â› Binds var-id to its value + <i>multiplier</i>. Same as (set! var-id (* var-id multiplier)). Returns new <i>var-id</i> value.</h4>
<h4 id='/='>(<b>/= </b><i>var-id divisor</i>) â› Binds var-id to its value / <i>divisor</i>. Same as (set! var-id (/ var-id divisor)). Returns new <i>var-id</i> value. <small>Rational, exact division</small></h4>
<h4 id='%='>(<b>%= </b><i>var-id  modulo</i>) â› Binds var-id to  its value modulo <i>modulo</i>. Same as (set! var-id (% ver-id modulo)). Returns new <i>var-id</i> value. 
<h4 id='//='>(<b>//= </b><i>var-id divisor</i>) â› Binds var-id to its value // <i>divisor</i>. Same as (set! var-id (// var-id divisor)). Returns new <i>var-id</i> value. <small>Float, inexact division.</small></h4>
<br>
<h4 id='symset!'>(<b>symset! </b><i>expr value</i>) <i>expr</i> must evaluate to a symbol name, var-id. â› Sets a new binding for var-id in the current environment. The var-id must be defined - either globally, or locally such as a function argument -  before being set. Returns <i>value</i>.</h4>


<pre>
<i>(define x 42)</i>  â†’   x
<i>(set! x 666)</i>
<i>x</i>  â†’   666

<i>(define a 100)</i>  â†’   a
<i>(+= a 333)</i>  â†’   433
<i>a</i>  â†’   433

<i>(define assign 0)</i>
<i>(set! assign set!)</i>
<i>(assign assign 333)</i>
<i>assign</i>  â†’   333

;; local binding for x
<i>((lambda (x) x) 'albert)</i>  â†’   albert
<i>((lambda (x) (set! x 'antoinette) x) 'albert)</i>  â†’   antoinette

;; global
<i>x</i>  â†’   666

;; errors
<i>(set! not-defined 2015)</i>
<span syle="color:red">âŒ error: set! : unbound variable : not-defined</span>

;; values
<i>(define-values (albert simon) (values 42 84))</i> 
<i>(set!-values (albert simon) (values simon albert))</i>  
<i>albert</i>  â†’   84
</pre>



<h2 id = "maps"> Mapping and folding</h2>
<h3>" â€¦ liste des chasseurs qu'Assourbanipal invitait Ã  ses battues" (Marcel Proust)</h3>
<p><b>map</b>  applies a function to successive elements of list(s), and returns the list of results. <b>foldl</b> and <b>foldr</b> applies a function to successive elements of list(s) and return the accumulated result. <b>foldl</b> applies from left to right, <b>foldr</b> applies from right to left. Iterations stops as soon as the last element of one of the lists is reached.
</p>
<p><b>maplist</b>  applies a function to successive rests of a list, and returns the list of results.
<br><br>
Let list<sub>a</sub> = (a<sub>1</sub> a<sub>2</sub> â€¦ a<sub>n</sub>) and list<sub>b</sub> = (b<sub>1</sub> b<sub>2</sub> â€¦ b<sub>n</sub>), fun:i a function which takes i arguments.
</p>

<h4 id='for-each'>(<b>for-each </b><i>fun:1 list<sub>a</sub></i>) â› evals (fun a<sub>i</sub>) for all i - returns void</h4>
<h4 id='for-each'>(<b>for-each </b><i>fun:2 list<sub>a</sub> list<sub>b</sub></i>) â› evals (fun a<sub>i</sub> b<sub>i</sub>) - returns void</h4>
<h4 id='map'>(<b>map </b><i>fun:1 list<sub>a</sub></i>) â› returns a list : ((fun a<sub>1</sub>) (fun a<sub>2</sub>) â€¦)</h4>
<h4 id='map'>(<b>map </b><i>fun:2 list<sub>a</sub> list<sub>b</sub></i>) â› returns a list : ((fun a<sub>1</sub> b<sub>1</sub>) (fun a<sub>2</sub> b<sub>2</sub>) â€¦)</h4>
<h4 id='maplist'>(<b>maplist </b><i>fun:1 list</i>) â› returns a list : ((fun list) (fun (rest list)) (fun (rest(rest list))) â€¦)</h4>
<br>
<h4 id='every'>(<b>every </b><i>predicate:1 list<sub>a</sub></i>) â› returns #t iff all (predicate a<sub>i</sub>) ... return #t. Else #f. </h4>
<h4 id='every'>(<b>every </b><i>predicate:2 list<sub>a</sub> list<sub>b</sub></i>) â› return #t iff all (predicate a<sub>i</sub> b<sub>i</sub>)  â€¦ return #t. Else return #f.</h4>
<h4 id='any'>(<b>any </b><i>predicate:1 list<sub>a</sub></i>) â› returns a<sub>i</sub> if one of (predicate a<sub>i</sub>) returns #t. Else #f. </h4>
<h4 id='any'>(<b>any </b><i>predicate:2 list<sub>a</sub> list<sub>b</sub></i>) â› returns ( a<sub>i</sub> . b<sub>i</sub>) if one of (predicate a<sub>i</sub> b<sub>i</sub>)  returns #t. Else returns #f.</h4>


<br>
<h4 id='foldl'>(<b>foldl </b><i>fun:2 v<sub>0</sub> list<sub>a</sub></i>) â› accumulates v<sub>i</sub> = (fun a<sub>i</sub> v<sub>i-1</sub>) from left to right - return v<sub>n</sub></h4>
<h4 id='foldl'>(<b>foldl </b><i>fun:3 v<sub>0</sub> list<sub>a</sub> list<sub>b</sub></i>) â› accumulates v<sub>i</sub> = (fun a<sub>i</sub> b<sub>i</sub> v<sub>i-1</sub>)  - returns v<sub>n</sub></h4>
<h4 id='foldr'>(<b>foldr </b><i>fun:2 v<sub>0</sub> list<sub>a</sub></i>) â› accumulates v<sub>i</sub> = (fun a<sub>i</sub> v<sub>i-1</sub>) from right to left - return v<sub>n</sub></h4>
<h4 id='foldr'>(<b>foldr </b><i>fun:3 v<sub>0</sub> list<sub>a</sub> list<sub>b</sub></i>) â› accumulates v<sub>i</sub> = (fun a<sub>i</sub> b<sub>i</sub> v<sub>i-1</sub>)  - returns v<sub>n</sub></h4>

<pre>
<i>(define alist '(a1 a2 a3 a4))</i>  â›   alist
<i>(define blist '(b1 b2 b3))</i>  â›   blist  
<i>(for-each write alist blist)</i>  â›   null
	a1     b1    
	a2     b2    
	a3     b3  
	
<i>(iota 9)</i>  â›   (0 1 2 3 4 5 6 7 8)
<i>(map even? (iota 9))</i>  â›   (#t #f #t #f #t #f #t #f #t)
<i>(map * (iota 10) (iota 10))</i>  â›   (0 1 4 9 16 25 36 49 64 81)
<i>(map cons alist blist)</i>  â›    ((a1 . b1) (a2 . b2) (a3 . b3))

<i>(map (lambda(x) (* x 666)) (iota 10))</i>  â›   
	(0 666 1332 1998 2664 3330 3996 4662 5328 5994)
<i>(map * (iota 7) (circular-list 999))</i>  â›   
	(0 999 1998 2997 3996 4995 5994)
<i>(foldl + 0 (iota 10))</i>  â›   45 ;; =  1 + 2 + .. + 9
<i>(foldl cons null alist)</i>  â›   (a4 a3 a2 a1)
<i>(foldr cons null alist)</i>  â›   (a1 a2 a3 a4)
<i>(foldl string-append "" alist blist)</i>  â›   "a3b3a2b2a1b1"
<i>(foldr string-append "" (iota 5) (iota 5))</i>  â›   "0011223344"

<i>(any (lambda ( x y) (= 42 (* x y))) (range 100) (rest (range 100)))</i> â†’ (6 . 7)
</pre>


<h2 id = "vectors">Vectors</h2>
<p>Vectors implement variable length arrays of lisp objects.. Vectors <mark>do self-evaluate</mark>. </p>
<h4> <b>#( a b c â€¦)</b> â› read new vector
<h4> <b>#( 0 4 PI I 333 â€¦)</b> â› read new vector
<h4 id='vector?'>(<b>vector? </b><i><big>V</big></i>) â› #t or #f</h4>
<h4 id='vector'>(<b>vector </b><i>a b c â€¦</i>) â› new vector #(a b c ...)</h4>
<h4 id='vector-empty?'>(<b>vector-empty? </b>) â› #t or #f</h4>
<h4 id='vector-length'>(<b>vector-length </b><i><big>V</big></i>)</h4>
<h4 id='make-vector'>(<b>make-vector </b><i>length</i>)  â› new vector #(0 0 0 ...)</h4>
<h4 id='make-vector'>(<b>make-vector </b><i>length init</i>)  â› new vector #(init init ...)</h4>
<h4 id='vector-dup'>(<b>vector-dup </b><i><big>V</big></i>)  â› new vector, shallow copy of <big>V</big></h4>
<h4 id='vector-copy'>(<b>copy </b><i><big>V</big></i>)  â› new vector, deep copy of <big>V</big></h4>
<h4 id='vector-append'>(<b>vector-append </b><i><big>V</big><sub>1</sub> <big>V</big><sub>2</sub></i>) â› new vector of concatened contents
<br>
<h4 id='build-vector'>(<b>build-vector </b><i>length fun</i>) â› new vector #((fun 0) (fun 1) ...)</h4>
<br>
<h4 id='subvector'>(<b>subvector </b><i><big>V</big> start [end]</i>) â› new vector <big>V</big>[start] .. <big>V</big>[end-1]</h4>
<h4 id='subvector'>(<b>take</b> V n) â› new vector V[0]..V[n-1]</h4>
<h4 id='subvector'>(<b>drop</b> V n) â› new vector V[n]..V[last]</h4>
<br>
<h4 id='vector->list'>(<b>vector->list </b><i><big>V</big></i>) â› list</h4>
<h4 id='list->vector'>(<b>list->vector </b><i>'(a b c ...</i>))  â› new vector #(a b c ..)</h4>
<br>
<h4 id='vector-fill!'>(<b>vector-fill! </b><i><big>V</big> a</i>) â› #(a a aâ€¦)</h4>
<h4 id='vector-pop'>(<b>vector-pop </b><i><big>V</big></i>) â› #f if <big>V</big> is empty</h4>
<h4 id='vector-push'>(<b>vector-push </b><i><big>V</big> obj</i>) â› adds obj at end of <big>V</big></h4>
<h4 id='vector-swap!'>(<b>vector-swap! </b><i><big>V</big> i j</i>)  tmp = V[i], V[i]=V[j],V[j] = tmp ; â› tmp </h4>
<h4 id='vector-shift'>(<b>vector-shift </b><i><big>V</big></i>) â› removes <big>V</big>[0] and returns it.  #f if <big>V</big> is empty</h4>
<h4 id='vector-rotate!'>(<b>vector-rotate! </b><i><big>V</big> n</i>) â› rotates <big>V</big> in place, n times. Left if n < 0, right if n > 0.</h4>
<br>
<h4 id='vector-ref'>(<b>vector-ref </b><i><big>V</big> i</i>) â› <big>V</big>[i] , i in [0.. length[. <small>Error if i is out of bounds</small></h4>
<h4>[<big>V</big> <i>i</i>] â› same as (vector-ref </b><i><big>V</big> i</i>). <small>Short-cut, and quick access</small></h4>
<br>
<h4 id='vector-remove-ref'>(<b>vector-remove-ref! </b><i><big>V</big> i</i>) â› removes <big>V</big>[i] and returns it.</h4>
<h4 id='vector-set!'>(<b>vector-set! </b><i><big>V</big> i obj</i>) â› set <big>V</big>[i] to obj. Returns obj. <small> No error if i is out of bounds allocated by make-vector. Vector size increases as needed. </small></h4>
<br>
<h4 id='vector+='>(<b>vector+= </b><i><big>V</big> i increment</i>) â› set <big>V</big>[i] to <big>V</big>[i]+<i>increment</i>. Returns <big>V</big>[i].</h4>
<h4 id='vector*='>(<b>vector*= </b><i><big>V</big> i multiplier</i>) â› set <big>V</big>[i] to <big>V</big>[i]*<i>multiplier</i>. Returns <big>V</big>[i].</h4>
<br>
<h4 id='vector-map'>(<b>vector-map </b><i>fun <big>V</big> <big>W</big> ... </i>) â› new vector [(fun <big>V</big>[0] <big>W</big>[0] ...) (fun <big>V</big>[1] <big>W</big>[1] ...) â€¦.]</h4>
<h4>(<b>for-each </b><i>fun <big>V</big> <big>W</big> ... </i>) â› call (fun <big>V</big>[0] <big>W</big>[0] ...) (fun <big>V</big>[1] <big>W</big>[1] ...) ... returns void </h4>
<br>
<h4 id='vector-filter'>(<b>vector-filter </b><i>pred <big>V</big></i>) â› new vector U from V, such as (pred U[i]) = #t</h4>
<h4 id='vector-index'>(<b>vector-index </b><i>value <big>V</big></i> [start-index]) â› i such as (equal? <big>V</big>[i] value), or #f. Sequential search from start-index or 0 (default)</h4>
<h4 id='vector-search'>(<b>vector-search </b><i>pred:1:1 <big>V</big></i> [start-index]) â› i such as (pred <big>V</big>[i]) != #f, or #f. Sequential search from start-index or 0 (default)</h4>


<h3>Sorted vectors</h3>
<h4 id='vector-sort!'>(<b>vector-sort! </b><i>sort-proc:2:2 <big>V</big></i>) â› reorder vector such as (sort-proc  <big>V</big>[i-1] <big>V</big>[i]) = #t</h4>

<br>
<h4 id='vector-search'>(<b>vector-search* </b><i>value sorted-vector/< </i>) â› i such as  <big>V</big>[i] = value, or #f</h4>
<h4 id='vector-insert'>(<b>vector-insert* </b><i>sorted-vector/<  value</i>)  inserts value in V, at the right place  â› value or  #f</h4>
<h4 id='vector-remove'>(<b>vector-remove* </b><i>sorted-vector/<  value</i>)  removes value from <big>V</big>  â›   value or #f</h4>


<pre>
<i>(vector? 'elvis)</i>  â›   #f
<i>(vector 8 9 '(+ 5 7) 10)</i>  â›   #(8 9 (+ 5 7) 10)

<i>(define simon (make-vector 7))</i>  â›   simon
<i>simon</i>  â›   #(0 0 0 0 0 0 0)
<i>(vector-fill! simon 666)</i>  â›   #(666 666 666 666 666 666 666)

<i>(define simon (list->vector (range 2 17 3)))</i>  â›   simon
<i>simon</i>  â›   #(2 5 8 11 14)
<i>(vector-ref simon 3)</i>  â›   11
<i><mark>[simon 3]</mark></i>  â›   11
<i>(vector-set! simon 3 1000)</i>  â›   1000
<i>simon</i>  â›   #(2 5 8 1000 14)

(vector-map * simon simon simon)  â†’ #( 8 125 512 1000000000 2744)
<i>(vector-filter prime? simon)</i>  â›   #(2 5)
<i>(vector-member 1000 simon)</i>  â›   3

<i>(define (cube x) (* x x x))</i>  â›   cube
<i>(define simon (build-vector 10 cube))</i>  â›   simon
<i>simon</i>  â›   #(0 1 8 27 64 125 216 343 512 729)
<i>(vector-sort! > simon)</i>  â›   #(729 512 343 216 125 64 27 8 1 0)

<i>(define inside (make-vector 5 444))</i>  
<i>inside</i>  â›   #(444 444 444 444 444)
<i>(vector-set! simon 4 inside)</i>  
<i>simon</i>  â›   #(729 512 343 216 #(444 444 444 444 444) 27 8 1 0)
<i>(vector? simon)</i>  â›   #t
</pre>

<h2 id = 'types.lib'>Types.lib</h2>
<h3>Types</h3>
<p>
Types are used to check - at run-time -  that function call arguments values conform to the function signature, that structures slots values are well typed, or to check that a given set of values conforms to a pattern. Types may describe different kind of patterns : atoms (numbers, symbols, etc.) , finite lists, infinite lists, lists of lists, vectors, instances of structures.  A Type is defined by a type-expression, which is one of :
<ul>
<li>a predefined type : 
	Object, 
 	Type, 
 	Any, 
 	Boolean, 
 	String, 
 	Symbol, 
 	Procedure, 
 	Date,
	List, 
	Pair, 
	Set, 
	Vector, 
	Stream, 
	Empty, 
	Null, 
	!Empty, 
	!Null, 
	Number, 
	Rational, 
	Complex, 
	Integer, 
	Exact, 
	Inexact, 
	Positive, 
	Negative, 
	Positive*.
	 <small>They all correspond to a native predicate: number?, vector?, ...</small>
	.</li>
<li>a type name <small>see make-type</small>
<li>a predicate name <small>Matching ok if (predicate value) â†’ #t</small> </li>
<li>a structure name <small>Matching ok if value is an instance of the structure</small></i>
<li>a 'symbol <small>Matching ok if value is the same symbol</small></i>
<li>a number <small>Matching ok if value = number</small></i>
<li>a list of Types (Type<sub>1</sub> Type<sub>2</sub> .. Type<sub>n</sub>) <small>Matching ok if value is a list of exactly n elements, each one matching  Type<sub>i</sub></small></li>
<li>a list of Types (Type<sub>1</sub> Type<sub>2</sub> .. Type<sub>n</sub> ...)<small> The last Type is the ellipsis <b>...</b> symbol. Matching ok if value is a list of >= n elements, each one matching  Type<sub>i</sub>, the last ones matching Type<sub>n</sub></small></li>
<br>
<li>a choice of Types [Type<sub>1</sub> | Type<sub>2</sub> .. | Type<sub>n</sub>] <small>Matching ok if value matches one of Type<sub>i</sub></small></li>
<li>a logical 'and' of Types [Type<sub>1</sub> & Type<sub>2</sub> .. & Type<sub>n</sub>] <small>Matching ok if value matches all of Type<sub>i</sub></small></li>
<br>
<li>a vector of Types #(Type<sub>1</sub> Type<sub>2</sub> .. Type<sub>n</sub>) <small>Matching ok if value is a vector of exactly n elements, each one matching  Type<sub>i</sub></small></li>
<li>a vector of Types #(Type<sub>1</sub> Type<sub>2</sub> Type<sub>n</sub> ...) <small>Matching ok if value is a vector of >= n elements, each one matching  Type<sub>i</sub>, the last ones matching Type<sub>n</sub></small>

</ul>
</p>
<p>
Types do auto-evaluate. <small>Use (type-inspect <i>type-name</i>) to see the inside</i>.</small> The make-type function do not evaluate its arguments.
</p>
<h4 id='make-type'>(<b>make-type </b><i>type-name [supertype] type-expression</i>) â†’ new Type. <i>supertype</i> is optional.</h4>
<h4 id='type?'>(<b>type? </b><i>object</i>) Is <i>object</i> of type Type ? â†’ #t or #f</h4>
<h4 id='types'>(<b>types</b>)  â†’ list of known Types</h4>
<br>
<h4 id='type-of?'>(<b>type-of? </b><i>expr type</i>) Checks <i>expr</i> value versus <i>type</i>.  â†’  #t or #f.</h4>
<h4 id='type-check'>(<b>type-check </b><i>expr type [proc:1]</i>) Checks <i>expr</i> value versus <i>type</i>.  â†’  #t if successful. Else if <i>proc</i> is present, returns (proc expr). Else raises an error.</h4>


<pre>
(lib 'types)
<i>(make-type NumPair (Number Number))</i>  ;; A list of two numbers
<i>(type-check '( 6 7) NumPair)</i>  â†’   #t
<i>(type-check '( 6 abcd ) NumPair)</i>
<span style="color:red">ğŸ˜¡ error: NumPair : type-check failure : abcd </span>

<i>(make-type NumList (Number ...))</i>  â†’   NumList - a list of n numbers
<i>(type-check (iota 42) NumList)</i>  â†’   #t

;; Type : integers in range [1 .. 10]
;; defined by a predicate
<i>(define (one-ten? x)  (in-interval? x 1 10))
(make-type one-ten [Integer & one-ten?])</i>

;; or defined by a choice
<i>(make-type One-ten [ 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 ])</i>

(type-check 7 One-ten) â†’ #t
(type-check 42 One-ten)
<span style="color:red">â›” error: One-ten : type-check failure : 42</span>

;; Handling the exception
<i>(define (on-error-10 n) (writeln n 'out-of-range) 10)
(type-check 12 One-ten on-error-10)</i>
12     out-of-range    
    â†’ 10
</pre>

<h3>Typed EchoLisp</h3>
<p>Types may be declared for functions arguments or structures fields. Assigned values will be checked against the argument or the field type. A type declaration has the following syntax : <b>type-name:variable-id</b>.</p>
<h4 id='signature'>(<b>signature </b><i>function-id</i>)  â†’ signature = list-of-types or null</h4>

<pre>
(lib 'types)

(define (sum-list NumList:xs) (apply + xs))
(signature 'sum-list) â†’ (NumList)
(sum-list (iota 8)) â†’ 28
(sum-list "albert")
  <span style="color:red">â— error: NumList : type-check failure : albert â†’ 'sum-list:xs'</span>

(define (surface real:a real:b real:c ) ;; HÃ©ron formula - a,b,c are the triangle sides
    (define p (// (+ a b c ) 2))
    (sqrt (* p (- p a) (- p b) (- p c))))

(surface 3 4 5) â†’ 6
(signature 'surface) â†’ (Real Real Real _)

(surface "heron" 4 5 )
    <span style="color:red">ğŸ’£ error: Real : type-check failure : heron â†’ 'surface:a'</span>
</pre>

<h3>Polymorphism - Methods</h3>
<br>

<pre>
</pre>

<h2 id="vlib.lib"> ğŸš² Typed vectors library : vlib.lib ğŸš² </h2>
<p>Typed vectors are constant sized vectors, with predefined elements type and size. See <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays">reference</a> for more information. They allow quick access, and less memory consumption. The available types are : uint8, uint8-clamped, uint32, int32, float32, float64. <small>Note: pop, push, .. operations will not work on fixed length vectors.</small>
</p>
<h4 id='make-typed-vector'>(<b>make-&lt;type&gt;-vector </b><i>length [init-value]</i>) -> new constant sized typed vector</h4>
<pre>
(lib 'vlib)

<i>(make-float32-vector 4 42.5)</i>  â†’   #float32( 42.5 42.5 42.5 42.5)
<i>(make-uint32-vector 8)</i>  â†’   #uint32( 0 0 0 0 0 0 0 0)
</pre>

<h3>See also <a href="#bit-map">plot</a> functions and typed vectors.</h3>
<h3 id="bit-vectors">Bit-vectors</h3>
<p>Bit-vectors - sets of #f/#t values - are implemented using uint32 vectors</p>.
<h4 id='make-bit-vector'>(<b>make-bit-vector </b><i>n</i>) â› n-bits bit-vector, initialized to #f (0). Bits are numbered 0 .. n-1.</h4>
<h4 id='make-bit-vector-1'>(<b>make-bit-vector-1 </b><i>n</i>) â› n-bits bit-vector, initialized to #t (1). Bits are numbered 0 .. n-1.</h4>
<h4 id='build-bit-vector'>(<b>build-bit-vector </b><i>n  fun:1:1</i>) â› n-bits bit-vector, bit b initialized to #f if (fun b) = #f, else to #t.</h4>
<br>
<h4 id='bit-vector-set!'>(<b>bit-vector-set! </b><i>bit-vector b [#t|#f]</i>) â› sets bit b , b in [0 .. n-1] to #t or #f</h4>
<h4 id='bit-vector-ref'>(<b>bit-vector-ref </b><i>bit-vector b</i>) â› #t or #f</h4>
<h4 id='bit-vector-toggle'>(<b>bit-vector-toggle </b><i>bit-vector b</i>) â› toggles the value of bit b. â› new value</h4>
<h4 id='bit-vector-scan-0'>(<b>bit-vector-scan-0 </b><i>bit-vector b</i>) â› bit number of first #f bit, from b included. â› #f if not found</h4>
<h4 id='bit-vector-scan-1'>(<b>bit-vector-scan-1 </b><i>bit-vector b</i>) â› bit number of first #t bit, from b included. â› #f if not found</h4>
<br>
<h4 id='bit-vector-take'>(<b>bit-vector-take </b><i>bit-vector b n </i>) â› list of n first values (b<sub>1</sub> ... b<sub>n</sub>) such as bit-vector[b<sub>i</sub>] = #t </h4>
<h4 id='bit-vector-count'>(<b>bit-vector-count </b><i>bit-vector b</i>) â› n = number of #t bits, up to b included.</h4>
<h4 id='bit-vector-xcount'>(<b>bit-vector-xcount </b><i>bit-vector n</i>) â› b such as there are n #t bits up to b, included. #f if not found.
<pre>
</pre>


<h2 id = "sets">Sets</h2>
<h3>"Sets are lists, but lists are not sets" - Broderick Fitsche -</h3>
<p>The empty set is  âˆ… , or null. A set is  âˆ…,  or an unordered list of numbers, symbols, strings, lists or sets, without duplicates. The sets { a b} and { b a} are the same set. ( a a b) is a list, but not a set.<br>
For convenience, <b>make-set</b> - the set constructor - re-orders the elements with the following precedence order :  âˆ… < number < symbol or string < list < set . <br>
Sets do self evaluate.
<h4><b>âˆ…</b>  â›  constant : the empty set - same as null</h4>
<h4>#{b a c c d ...}  â›  {a b c d ...} read a set, by calling make-set</h4>
<h4 id='set?'>(<b>set? </b><i>object</i>) is object a set?  â›  #t or #f </h4>
<h4 id='make-set'>(<b>make-set </b><i>from-list</i>) â› new set from <i>from-list</i> </h4>
<h4 id='set-equal?'>(<b>set-equal? </b><i>setA setB</i>) â› #t or #f (deep equality)</h4>
<h4 id='set-intersect'>(<b>set-intersect </b><i>setA setB</i>) â› elements in A and in B</h4>
<h4 id='set-product'>(<b>set-product </b><i>setA setB</i>) â› all pairs (a . b) where a in A and b in B</h4>
<h4 id='set-union'>(<b>set-union </b><i>setA setB</i>) â› elements in A or B</h4>
<h4 id='set-intersect?'>(<b>set-intersect? </b><i>setA setB</i>) â› #t or #f</h4>
<h4 id='set-substract'>(<b>set-substract </b><i>setA setB</i>) â› elements in A, not in B</h4>
<h4 id='set-subset?'>(<b>set-subset? </b><i>setA setB</i>) â› all elements of B in A ?  â› #t or #f </h4>
<h4 id='set-sym-diff'>(<b>set-sym-diff </b><i>setA setB</i>) â› symmetrical difference : elements in (A or B) , not in (A and B) </h4>

<pre>
<i>(make-set '( b b b a b 1 "b" c (e f) (f e) (f e) 12))</i> â†’ { 1 12 a b c (e f) (f e) }

<i>(define A (make-set ' ( ğŸ  ğŸ ğŸ† ğŸ‡ ))) (define B (make-set ' ( ğŸ  ğŸ‡ ğŸ‚ )))</i>
<i>(set-intersect A B)</i> â†’ { ğŸ‡  ğŸ }
<i>(set-union A B)</i> â†’ { ğŸ† ğŸ‡  ğŸ ğŸ ğŸ‚ }
<i>(set-substract A B)</i> â†’ { ğŸ† ğŸ }
<i>(set-sym-diff A B)</i> â†’ { ğŸ† ğŸ ğŸ‚ }
 
<i>(set? âˆ…)</i> â†’ #t

(set-intersect  (range 7 999) (range 995 2000))  â†’ { 995 996 997 998 }

;; power set : set of all subsets : 2<sup>Card(A)</sup> elements.
<i>
(define (set-cons  a A) (make-set (cons a A)))
(define (power-set e) 
	(cond ((null? e) 
		(make-set (list âˆ…)))
		(else (let [(ps (power-set (cdr e)))]
		(make-set
		 (append ps (map set-cons (circular-list (car e)) ps)))))))
</i>
(power-set B) â†’ { âˆ… { ğŸ‡ } { ğŸ‡ ğŸ } { ğŸ‡ ğŸ ğŸ‚ } { ğŸ‡ ğŸ‚ } { ğŸ } { ğŸ ğŸ‚ } { ğŸ‚ } }

;; The Von Neumann universe
<i>(define V0 (power-set null)) V0</i> â†’ { âˆ… }
<i>(define V1 (power-set V0)) V1</i> â†’ { âˆ… { âˆ… }}
<i>(define V2 (power-set V1)) V2</i> â†’ { âˆ… { âˆ… } { âˆ… { âˆ… }} {{ âˆ… }}}
<i>(define V3 (power-set V2)) V3</i> â†’ { âˆ… { âˆ… } { âˆ… { âˆ… }} { âˆ… { âˆ… } { âˆ… { âˆ… }}} { âˆ… { âˆ… } { âˆ… { âˆ… }} {{ âˆ… }}} { âˆ… { âˆ… } {{ âˆ… }}} { âˆ… { âˆ… { âˆ… }}} { âˆ… { âˆ… { âˆ… }} {{ âˆ… }}} { âˆ… {{ âˆ… }}} {{ âˆ… }} {{ âˆ… } { âˆ… { âˆ… }}} {{ âˆ… } { âˆ… { âˆ… }} {{ âˆ… }}} {{ âˆ… } {{ âˆ… }}} {{ âˆ… { âˆ… }}} {{ âˆ… { âˆ… }} {{ âˆ… }}} {{{ âˆ… }}}}
<i>(define V4 (power-set V3)) (length V4)</i> â†’ 65536

;; Cartesian products of A and B : set of all pairs ( a . b) such as  a âˆˆ A, b âˆˆ B.
<i>(define-syntax-rule (Card A) (length (make-set A))) </i>
<i>(define (set-product A B)
	(make-set
	(for*/list ((a A)(b B)) (cons a b))))</i>

<i>(define ranks {A R D V 10 9 8 7 6 5 4 3 2})</i>
<i>(define suits  {â™  â™¥ â™¦ â™£})</i>
<i>(style 'â™¦ "color:#c00000")</i>
<i>(style 'â™¥ "color:#c00000")</i>
<i>(set-product ranks suits)</i> â†’  { (2 . â™ ) (2 . â™£) (2 . <span style="color:#c00000">â™¥</span>) (2 . <span style="color:#c00000">â™¦</span>) (3 . â™ ) (3 . â™£) (3 . <span style="color:#c00000">â™¥</span>) (3 . <span style="color:#c00000">â™¦</span>) (4 . â™ ) ... (R . <span style="color:#c00000">â™¥</span>) (R . <span style="color:#c00000">â™¦</span>) (V . â™ ) (V . â™£) (V . <span style="color:#c00000">â™¥</span>) (V . <span style="color:#c00000">â™¦</span>) }
<i>(Card (set-product ranks suits))</i>  â†’ 52
</pre>


<h2 id = "strings">Strings</h2>
<h3>"All strings are immutable"  (Ludwig Wittgenstein)</h3>
<p>All functions which return a string return a <mark>new</mark> string. There is no 'character' type in EchoLisp. Characters are simply strings of length 1. See for example string->list and unicode->string. Input string delimiters are " ..." or #' ... '#.<br>
Use \n to insert a new line character, \" to protect the double quote.
<br><br>
'here-strings' are delimited by #<< ... >>#. They may include new lines, separators, etc.
</p>
<h4 id='string-delimiter'>(<b>string-delimiter </b>) â› get string output delimiter. " = default</h4>
<h4 id='string-delimiter'>(<b>string-delimiter delimiter</b>) â› set string output delimiter. Use "" for none.</h4>

<pre>
<i>(string-delimiter "|")</i>
<i>"B B King"</i> â› |B B King|
<i>#'She says: "Here he comes"'#</i> â›  |She says: "Here he comes"| 

<i>#&lt;&lt;<br>He says:
    "Here I am".
&gt;&gt;#</i>  â› 
|He says:
    "Here I am".|
</pre>

<h4 id='string?'>(<b>string? </b><i>obj</i>) â› #t if <i>obj</i> is a string, else #f</h4>
<h4 id='string-empty?'>(<b>string-empty? </b><i>obj</i>) â› #t if <i>obj</i> is the empty string, else #f</h4>
<h4 id='string'>(<b>string </b><i>obj</i>) â› <i>obj</i> converted to string</h4>
<br>
<h4 id='string-alphabetic?'>(<b>string-alphabetic? </b><i>str</i>) â› #t if all characters are in range [a-z A-Z Ã©Ã¨Ãª...], else #f</h4>
<h4 id='string-length'>(<b>string-length </b><i>str</i>)</h4>
<br>
<h4 id='string-ref'>(<b>string-ref </b><i>str index</i>) â› str[index]</h4>
<h4 id='string-first'>(<b>string-first </b><i>str</i>) â› str[0]</h4>
<h4 id='string-last'>(<b>string-last </b><i>str</i>) â› str[(string-length str) -1]</h4>
<h4 id='string-rest'>(<b>string-rest </b><i>str</i>) â› str[1 â€¦]</h4>
<br>
<h4 id='substring'>(<b>substring </b><i>str start</i>) â› str[start â€¦ last]</h4>
<h4 id='substring'>(<b>take </b><i>str n</i>) â› str[0 â€¦ n[</h4>
<h4 id='substring'>(<b>drop </b><i>str n</i>) â› str[n â€¦ last]</h4>
<h4 id='substring'>(<b>substring </b><i>str -start</i>) â› str[last-start â€¦ last] - negative start</h4>
<h4 id='substring'>(<b>substring </b><i> str start end</i>) â› str[start â€¦end[</h4>
<br>
<h4 id='string-append'>(<b>string-append </b><i>str<sub>1</sub> str<sub>2</sub> ..</i>) â› concatenates all <i>str<sub>i</sub></i>. <small>Use (string-append s) to make a copy of s</small></h4>
<h4 id='string->list'>(<b>string->list </b><i>str</i>) â› explode string into list of characters</h4>
<h4 id='string-join'>(<b>string-join </b><i>list [separator]</i>) â› concatenates each list elelemnt string representation, inserting <i>separator</i>. The default <i>separator</i> is " " .</h4>
<h4 id='list->string'>(<b>list->string </b><i>list</i>) â› concatenates list items string representation</h4>
<br>
<h4 id='string-upcase'>(<b>string-upcase </b><i>"abcd"</i>) â› "ABCD"</h4>
<h4 id='string-downcase'>(<b>string-downcase </b><i>"ABcD"</i>) â› "abcd"</h4>
<h4 id='string-titlecase'>(<b>string-titlecase </b><i>"longtemps"</i>) â› "Longtemps"</h4>
<h4 id='string-randcase'>(<b>string-randcase </b><i>"longtemps"</i>) â› "lOnGTeMps"</h4>
</br>
<h4 id='string-replace'>(<b>string-replace </b><i>str old new</i>) â› replaces old by new inside str</h4>
<h4 id='string-remove'>(<b>string-remove </b><i>str to-remove</i>) â› removes all characters - any order - of <i>to-remove</i> string from str</h4>
<h4 id='string-match'>(<b>string-match </b><i>str substring</i>) is substring inside string ? â› #t or #f </h4>
<br>
<h4 id='string-prefix?'>(<b>string-prefix? </b><i>prefix str</i>) â› #t or #f </h4>
<h4 id='string-prefix?'>(<b>string-suffix? </b><i>suffix str</i>) â› #t or #f </h4>
<h4 id='string-index'>(<b>string-index </b><i>needle-str str</i>) â› index >=0 or #f if needle not found</h4>
<br>
<h4 id='string->number'>(<b>string->number </b><i>str</i>) â› parses string into integer or float (inexact) number. Returns #f if str does not represent a number.
<h4 id='number->string'>(<b>number->string </b><i>number [base]</i>) â› conversion to base <i>base</i>. Default is 10.</h4>
<h4 id='symbol->string'>(<b>symbol->string </b><i>[symbol | string]</i>) â› string from symbol name. Returns <i>string</i> if argument is a string.</h4>
<br>
<h4 id='string->unicode'>(<b>string->unicode </b><i>string</i>) â› explodes <i>string</i> into list of unicode characters values</h4>
<h4 id='unicode->string'>(<b>unicode->string </b><i>char-code</i>) â› unicode character = 1-character string</h4>
<h4 id='unicode->string'>(<b>unicode->string </b><i>char-code-list</i>) â› concatenates char codes into a string</h4>
<p>char-code may be decimal: 1028, hexadecimal:0x404, unicode:#\u0404</p>
<br>
<h4 id='string-pad-right'>(<b>string-pad-right </b><i>object length</i>) â› new string of length <i>length</i>, right padded with spaces</h4>
<h4 id='string-pad-left'>(<b>string-pad-left </b><i>object length</i>) â› new string of length <i>length</i>, left padded with spaces</h4>
<br>
<h4 id='string-diacritics'>(<b>string-diacritics </b><i>string</i>) â› new string, replacing diacritics - Ã©,Ã¨,Ã´, .. - with non-accented characters.</h4>
<h4 id='string-trim'>(<b>string-trim </b><i>string</i>) â› new string with left, right spaces suppressed.</h4>
<h4 id='string-trim-left'>(<b>string-trim-left </b><i>string</i>) â› new string with left spaces suppressed.</h4>
<h4 id='string-trim-right'>(<b>string-trim-right </b><i>string</i>) â› new string with right spaces suppressed.</h4>
<br>
<h4 id='string->html'>(<b>string->html </b><i>string</i>) â› new string, replacing all white spaces with html non-breaking spaces (&amp;nbsp;)



<h3>Strings compare</h3>
<h4 id='string=?'>(<b>string=? </b><i>str1 str2</i>) â› #t or #f</h4>
<h4 id='string=?'>(<b>string&gt=? </b><i>str1 str2</i>) â› #t or #f</h4>
<h4 id='string=?'>(<b>string&lt=? </b><i>str1 str2</i>) â› #t or #f</h4>
<h4 id='string=?'>(<b>string&gt? </b><i>str1 str2</i>) â› #t or #f</h4>
<h4 id='string=?'>(<b>string&lt? </b><i>str1 str2</i>) â› #t or #f</h4>
<br>
<h4 id='string-ci=?'>(<b>string-ci=? </b><i>str1 str2</i>) â› #t or #f ;; -ci : ignore case</h4>
<h4 id='string-ci=?'>(<b>string-ci&gt=? </b><i>str1 str2</i>) â› #t or #f</h4>
<h4 id='string-ci=?'>(<b>string-ci&lt=? </b><i>str1 str2</i>) â› #t or #f</h4>
<h4 id='string-ci=?'>(<b>string-ci&gt? </b><i>str1 str2</i>) â› #t or #f</h4>
<h4 id='string-ci=?'>(<b>string-ci&lt? </b><i>str1 str2</i>) â› #t or #f</h4>

<pre>
<i>(define intro "Longtemps je me suis couchÃ©")</i>  

<i>(string-length intro)</i>  â›   27
<i>(string-ref intro 3)</i>  â›   "g"
<i>(string-append intro " de bonne heure.")</i>  â›   "Longtemps je me suis couchÃ© de bonne heure."
<i>(string-join (iota 4) " - ")</i>  â›   "0 - 1 - 2 - 3"
<i>(string-append "[" (string-join (iota 4) ",") "]")</i>  â›   "[0,1,2,3]"
<i>(string-rest intro)</i>  â›   "ongtemps je me suis couchÃ©"

<i>(string-upcase intro)</i>  â›   "LONGTEMPS JE ME SUIS COUCHÃ‰"
<i>(string-randcase intro)</i>  â›   "longtEMpS Je Me SuIs couchÃ‰"
<i>(string-randcase intro)</i>  â›   "lonGTEMps jE me Suis cOUchÃ©"

<i>(string-replace intro "couchÃ©" "levÃ©")</i>  â›   "Longtemps je me suis levÃ©"

<i>(string=? "Long" "long")</i>  â›   #f
<i>(string-ci=? "Long" "long")</i>  â›   #t
<i>(substring intro 4)</i>  â›   "temps je me suis couchÃ©"
<i>(substring intro 4 10)</i>  â›   "temps "
<i>(substring intro -6)</i>  â†’   "couchÃ©"

<i>(string-append intro " " (unicode->string 0x1F604))</i> 
          â›   "Longtemps je me suis couchÃ© ğŸ˜„"
<i>(string-delimiter "")</i>  â›  
<i>(unicode->list 0x2744 0x274E)</i>  â›   (â„ â… â† â‡ âˆ â‰ âŠ â‹ âŒ â â)

<i>(string->list intro)</i>  â›   (L o n g t e m p s j e m e s u i s c o u c h Ã©)
<i>(string-delimiter "-")</i>  â›   ---
<i>(string->list 1234566)</i>  â›   (-1- -2- -3- -4- -5- -6- -6-)
<i>(string->list (iota 5))</i>  â›   (-0- -1- -2- -3- -4-)

<i>(number->string 666)</i>  â†’   "666"
<i>(number->string 666 16)</i>  â†’   "0x29a"
<i>(number->string 666 2)</i>  â†’   "|2|1010011010"

;; See also <a href="http://rosettacode.org/wiki/Execute_a_Markov_algorithm#EchoLisp">Markov algorithm</a> for strings manipulations.
</pre>

<h2 id = "regexp">Regular expressions</h2>
<p>Regular expressions - regexp - may be used in replace, split or match functions. The syntax and use or regular descriptions are depicted in the <a href ="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_parenthesized_substring_matches">Javascript reference</a>.
<br>
Regular expressions are objects which may be created using the "/pattern/" syntax, or by the make-regexp function : (make-regexp pattern). Regular expression objects do auto evaluate, and are printed as #regexp:pattern.  In the following, <i>regexp</i> is a simple string, a regexp string - "/pattern/" - , or a regexp object.<small> Note: special characters like "\" must be protected by "\" inside a regexp string</small>.
</p>
<h4 id = make-regexp>(<b>make-regexp</b> <i>pattern-string</i>) â› new regexp object</h4>
<br>
<h4 id='string-replace'>(<b>string-replace </b><i>str regexp replacement-string</i>) â› regular expression replace. <i>regexp</i> may use <a hreh ="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_parenthesized_substring_matches">parenthesized substrings</a>, and replacement-string may use the $<sub>i</sub> notation to denote the parenthesized substring matches. </h4>
<h4 id='string-replace'>(<b>string-replace </b><i>str regexp replacement-string mod</i>) â› use modifiers "i":ignore case, "g":global, ...</h4>
<br>
<h4 id='string-match'>(<b>string-match </b><i>str regexp </i>)  regular expression match â› #t or #f</h4>
<h4 id='string-match'>(<b>string-match </b><i>str regexp mod</i>) modifier "i":ignore case â› #t or #f</h4>
<br>
<h4 id='string-split'>(<b>string-split </b><i>str [splitter] </i>)  â› list of substrings, splitted according to the regexp <i>splitter</i> separator. The default <i>splitter</i> is " ". </h4>
<br>
<h4 id='regexp-match'>(<b>regexp-match </b><i>regexp  str</i>)  â› list of substrings matching regexp inside str, or empty list. <small>If the regexp is a string, or does not use the "g" option, only the first matching occurence is returned.</small></h4>
<h4 id='regexp-match*'>(<b>regexp-match* </b><i>regexp  str</i>)  â› list of substrings matching   regexp expressions inside regexp, or empty list. <small>regexp-match* forces the  "g" option = multiple occurences search option.</small> </h4>
<h4 id='regexp-exec'>(<b>regexp-exec </b><i>regexp  str</i>)  â› list of substrings matching the  parenthesized expressions inside regexp, or empty list</h4>

<pre>
<i>(string-replace intro "/.e/" "â€¦e")</i>  â›   "Longâ€¦emps je me suis couchÃ©"
<i>(string-replace intro "/.e/" "â€¦e" "g")</i>  â›   "Longâ€¦emps â€¦e â€¦e suis couchÃ©"

<i>(define R (make-regexp "(\\w+)\\s(\\w+)"))</i> ;; word- 1 space - word
<i>R</i>  â†’   <span style="color:magenta">#regexp:/(\w+)\s(\w+)/</span>
<i>(string-replace "Simon Gallubert" R "$2 $1")</i>  â†’   "Gallubert Simon"

<i>(string-match "Simon Gallubert" "/s.*g/" "i")</i>  â†’   #t
<i>(string-match "Simon Gallubert" "/s.*g/" )</i>  â†’   #f

<i>(string-split "Simon Gallubert on the moon" "/mo+/")</i>  â†’   ("Si" "n Gallubert on the " "n")

<i>(regexp-exec R "Ludwig Wittgenstein")</i>  â†’   ("Ludwig" "Wittgenstein")
<i>(regexp-exec R "Elvis")</i>  â†’   #f

<i>(define RANGE (make-regexp "^ *(\-?\\d+)\-(\-?\\d+) *$" ))</i> ;; number-number
<i>RANGE</i>  â†’  <span style="color:magenta"> #regexp:/^ *(-?\d+)-(-?\d+) *$/</span>
<i>(regexp-exec RANGE "4--12")</i>  â†’   ("4" "-12")

</pre>

<h2 id = "dates">Date & Time</h2>
<h4>(<b>current-time</b>) -> seconds since 1/1/1970</h4>
<h4 id='current-time-milliseconds'>(<b>current-time-milliseconds </b><i></i>)-> milliseconds</h4>
<br>
<h4 id='date?'>(<b>date? </b><i>object</i>) -> is <i>object</i> a date ? #t or #f </h4>
<h4 id='date'>(<b>date </b><i>year month day hour minute seconds milliseconds</i>) -> new date object</h4>
<p> Milliseconds, seconds, hour, .. are optional, in that order. Month must be in[1-12], day in [1-7], hour in [0-23].</p>
<h4 id='date'>(<b>date </b>[<i>multiplier</i>] <i>unit-name</i>) -> new date object = now + multiplier*unit</h4>
<p>Multiplier is optional - default 1 - , positive or negative. 
<br>Unit-name is one of [year, month, week, day, hour, mn, minute, second, sec] or [an, mois, semaine, jour, heure, minute, seconde, <mark>longtemps</mark>], singular or plural.
<br>Or, without multiplier, [now, today, tomorrow, yesterday, maintenant, demain, hier].
</p>
<h4 id='string->date'>(<b>string->date </b><i>date-string</i>) -> new date</h4>
<h4><small><img src="https://abs.twimg.com/emoji/v1/72x72/1f1eb-1f1f7.png" width="18" height="18" /> string->date accepte les formats yyyy-mm-dd et jj/mm/aaaa: (string->date "2016-11-13"), (string->date "13/11/1946") ,  (string->date "1/5/2015T14:48:00")</small></h4>
<br>
<h4 id='seconds->date'>(<b>seconds->date </b><i>sec</i>) -> new date since 1/1/1970</h4>
<h4>(<b>currrent-date</b>) -> new date : now</h4>

<br>
<h4 id='date-diff'>(<b>date-diff </b><i>date_1 date_2</i>) -> difference in seconds</h4>
<h4 id='date-add!'>(<b>date-add! </b><i>date seconds</i>) -> add seconds to the date object</h4>
<br>
<h4 id='date->seconds'>(<b>date->seconds </b><i>date</i>) -> seconds since 1/1/1970</h4>
<h4 id='date->string'>(<b>date->string </b><i>date</i>) -> localized date+time string </h4>
<h4 id='date->date-string'>(<b>date->date-string </b><i>date</i>) -> localized date string </h4>
<h4 id='date->time-string'>(<b>date->time-string </b><i>date</i>) -> localized time string </h4>
<h4 id='date-format'>(<b>date-format </b><i>date language options-values-list</i>) -> formatted date string </h4>
<br>

<pre>
<small>
<a href=http://fr.wikipedia.org/wiki/Liste_des_codes_ISO_639-1>Languages</a> :
	fr,en,be, ...
Options names and combinations:
    weekday, year, month, day, hour, minute, second
    weekday, year, month, day
    year, month, day
    year, month
    month, day
    hour, minute, second
    hour, minute
    hour12 : #t or #f
Options possible values:
        "narrow", "short", "long" ,"numeric", "2-digit".
        
<i>(define std-format '((hour numeric) (minute numeric) (month long) (weekday long) (day numeric)))</i>
</small>
</pre>



<pre>
<i>(date->string (current-date))</i>  â†’   "15/4/2015 12:15:05"
<i>(define now (current-date))</i>  â†’   now
<i>now</i>  â†’   Wed Apr 15 2015 12:15:19 GMT+0200 (CEST)

;; ğŸº pause-cafÃ© â˜•ï¸
<i>(define later (current-date))</i>  â†’   later 
<i>(date-diff later now)</i>  â†’   166 ;; seconds

<i>(- later now)</i>
âŒ <span style="color:red">error: sub : expected numeric value  </span>

;; default formatting
<i>(string->date "2016 1 1")</i>  â†’   Fri Jan 01 2016 00:00:00 GMT+0100 (CET)
<i>(string->date "2016 Feb 1")</i>  â†’   Mon Feb 01 2016 00:00:00 GMT+0100 (CET)

</i>(date->string (string->date "2016 Feb 31"))</i> â†’ "2/3/2016 00:00:00"

<i>(define now (current-date))</i>  â†’   now
<i>now</i>  â†’   Fri Apr 17 2015 13:05:57 GMT+0200 (CEST)
<i>(date-add! now 3600)</i> 
<i>now</i>  â†’   Fri Apr 17 2015 14:05:57 GMT+0200 (CEST)
<i>(date->seconds now)</i>  â†’   1429272357

<i>(date 2 2 2 2 2 2)</i>  â†’   Sun Feb 02 1902 02:02:02 GMT+0100 (PMT)

(date-format (current-date ) "fr" std-format) â†’ "dimanche 10 mai 14:15"
(date-format (current-date ) "be" std-format) â†’ "Ğ½ÑĞ´Ğ·ĞµĞ»Ñ, 10 Ğ¼Ğ°Ñ 14.28"
(date-format (current-date) 'ja std-format)  â†’ "5æœˆ10æ—¥æ—¥æ›œæ—¥ 14:40"

(define my-format '((second "2-digit" ) (minute numeric) (hour "2-digit") (hour12 #t)))
(date-format (current-date ) "fr" my-format)  â†’ "2:22:22 PM" ;; sans tricher

(date-format (date 3 'mois) 'fr std-format) â†’ "dimanche 16 aoÃ»t 2015 11:41"
(date-format (date -1 'week) 'en std-format) â†’ "Monday, May 11, 2015, 11:42 AM"
(date-format (date 'longtemps) 'fr std-format) â†’ "mardi 20 avril 2021 12:23"
(date-format (date -100 'longtemps) 'fr std-format) â†’ "samedi 31 octobre 1125 10:33"
</pre>

<h2 id="control">Control - special forms -</h2>
<pre style = "border:none;margin-left:20px;">
<h4 id='begin'>(<b>begin </b><i>expr<sub>1</sub> â€¦. expr<sub>n</sub></i>) â› 
	Eval expr<sub>1â€¦n</sub> & return expr<sub>n</sub> </h4>
<h4 id='begin0'>(<b>begin0 </b><i>expr<sub>1</sub> â€¦. expr<sub>n</sub></i>) â› 
	Eval expr<sub>1â€¦n</sub> & return expr<sub>1</sub> </h4>
	
<h4 id='when'>(<b>when </b><i>cond expr<sub>1</sub> â€¦ expr<sub>n</sub></i>) â› 
	If cond is #t eval expr<sub>1â€¦n</sub> & return expr<sub>n</sub> - else return #f</h4>
<h4 id='unless'>(<b>unless </b><i>cond expr<sub>1</sub> â€¦ expr<sub>n</sub></i>) â› 
	If cond is not #t eval expr<sub>1â€¦n</sub> & return expr<sub>n</sub> - else return #t</h4>
<h4 id='if'>(<b>if </b><i>cond t-expr f-expr</i>)  â› 
	If cond is #t  
		eval and return t-expr
		else eval and return f-expr</h4>
<h4 id='cond'>(<b>cond </b><i>
	(test<sub>1</sub> expr<sub>1</sub> â€¦last<sub>1</sub>)
	(test<sub>2</sub> expr<sub>2</sub> â€¦last<sub>2</sub>)  â€¦) </i> â› 
	If test<sub>i</sub> is #t, eval expr<sub>i</sub> â€¦ & return last<sub>i</sub>. Else return #f</h4>
<h4 id='cond'>(<b>cond </b><i>
	(test<sub>1</sub> expr<sub>1</sub> â€¦last<sub>1</sub>) 
	(test<sub>2</sub> expr<sub>2</sub> â€¦last<sub>2</sub>) â€¦ 
	(<b>else</b> else<sub>1</sub> .. last_else)) </i> â› 
	If test<sub>i</sub> is #t, eval expr<sub>i</sub> â€¦ & return last<sub>i</sub>.
	If no success, eval else<sub>1</sub> â€¦  & return last_else.</h4>
	
<h4 id='case'>(<b>case </b><i> key
	((datum<sub>11</sub> datum<sub>12</sub> â€¦ ) expr<sub>1</sub> â€¦last<sub>1</sub>) 
	((datum<sub>21</sub> datum<sub>22</sub> â€¦ ) expr<sub>2</sub> â€¦last<sub>2</sub>)
	(<b>else</b> else<sub>1</sub> .. last_else)) </i> â› 
	If key matches - eqv? - one of datum<sub>ij</sub>, eval expr<sub>i</sub> â€¦ and return last<sub>i</sub>.
	If no success, eval else<sub>1</sub> â€¦  and return last_else.
	If no success and no <i>else</i> clause, return #f.</h4>
</pre>

<pre>
<i>(begin (write 1) (write 2) (+ 3 4) (+ 5 7) 0)</i>  â›   0
<i>(if #t 3 4)</i>  â›   3
<i>(if #f 5 (* 3 4))</i>  â›   12
<i>(if (string>? "albert" "antoinette") 'albert 'antoinette)</i>  â›   antoinette
<i>((if #t * +) 7 6)</i>  â›   42

<i>((Î» (x y) ((if (> x y) * +) x y)) 6 7)</i>  â›   13
<i>((Î» (x y) ((if (> x y) * +) x y)) 7 6)</i>  â›   42

<i>(define (f a b) 
	(cond 
		((> a b)  (write a "gt" b) a) 
		((< a b)  (write a "lt" b) b) 
		(else (write "equal") (+ a b))))</i>  â›   f
  
<i>(f 4 5)</i>  â›  4  "lt"  5  â›  5
<i>(f 55 4)</i>  â›  55  "gt"  4  â›  55
<i>(f -1 -1)</i>  â› "equal"  â›  -2
</pre>


<h2 id = "iterations">Looping and iterating</h2>
<center>
<img src = "./images/for-loop.jpg">
</center>
<p>(<b>for</b> â€¦) iterates over local variables v<sub>i</sub>, which take values in range expressions, evaluates a body = sequence of  expressions expr<sub>i</sub>, and returns the successive values of the last one  accumulated in sum, product, vector or list etc. Iterations stops as soon as a range is exhausted, or a #:break is encountered. <small>The for iterations forms are based on <a href="http://srfi.schemers.org/srfi-42/">Scheme</a> and Racket.</small></p>
<p>(<b>for*</b> â€¦) nests iterations.</p>

<p>
<b>Keywords:</b><br>
<br> #:break <i>condition</i> :  stops the while, for or for* execution if condition is #t.
<br> #:break <i>condition</i> => ret-expression :  stops the while, for or for* execution if condition is #t, and returns the value of ret-expression.
<br> #:continue <i>condition</i> :  interrupts the body execution - without accumulating -, restarts the next while, for or for* iteration if condition is not #f.
<br> #:when <i>condition</i> :  Same as #:continue (not condition).
<br><br><small>In the following, expr<sub>i</sub> is [expression | #:when condition | #:break condition | #:continue condition]. <i>start</i>, <i>end</i>, <i>incr</i> are numbers. <i>i, j, k, </i>, v<sub>i</sub> are the loop formal parameters = any symbol. <i>body</i> is a sequence or expr<subi</sub>. expr<sub>n</sub> is the last expression in body. </small>
</p>

<h4 id='while'>(<b>while </b><i>cond expr<sub>1</sub> â€¦ expr<sub>n</sub></i>) 
	â› loops evaluating expr<sub>i</sub> until cond is #f <mark>or null</mark> - returns #f </h4>
	<br>
<h4 id='for'>(<b>for </b><i>((v<sub>1</sub> range<sub>1</sub>)(v<sub>2</sub> range<sub>2</sub>) â€¦)</i> expr<sub>1</sub> â€¦ expr<sub>n</sub>) â› parallel loops. Returns last expr<sub>n</sub> unless a #:break => ret-value is encountered.</h4>

<h3> Range and sequence expressions </h3>
<p>An iteration expression (id expr) will assign the consecutive values of expr - which may-be a numerical range, sequence, vector, .. to the local variable <i>id</i>. Multiple assignments are possible: ((id<sub>1</sub> id<sub>2</sub> ..) expr). When expr returns (v<sub>1</sub> v<sub>2</sub> ..) v<sub>i</sub> is assigned to id<sub>i</sub>. When expr returns pairs - eg. hash table - , use ((id<sub>1</sub> . id<sub>2</sub>) expr) to bind the values.
</p> 
<h4 id='for'>(<b>for </b>((<i>i end</i>) â€¦) body </i>) 
	â› i in range [0 â€¦ end[</h4>
<h4 id='for'>(<b>for </b>((<i>j (<b>in-range</b> start end</i>)) â€¦) body</i>) 
	â› j in [start â€¦ end[</h4>
<h4 id='for'>(<b>for </b>((<i>k (<b>in-range</b> start end incr</i>)) â€¦) body</i>) 
	â› k in [start â€¦ end[ by steps incr </h4>
<br>
<h4 id='for'>(<b>for </b>((<i>i list</i>) â€¦) body</i>) â› i values : elements of list.</h4>

<h4 id='for'>(<b>for </b>((<i>j stream</i>) â€¦) body</i>) â› j values : consecutive values of stream. See <a href="#predefined-sequences">predefined</a> sequences and streams : in-naturals, in-primes, in-permutations, in-cycle, ..</h4>
<br>
<h4 id='for'>(<b>for </b>((<i>j (<b>in-producer</b> proc [arg<sub>1</sub> arg<sub>2</sub>  â€¦]</i>)) â€¦) body</i>) â› j values : consecutive values of calls to  (proc [arg<sub>1</sub> arg<sub>2</sub> â€¦]). <small>The arguments - if any - are evaluated once, when initializing the for loop. <i>proc</i> may be a state based procedure, which returns a different value at each call. Iteration stops when <i>proc</i> returns #f, else use a #:break to stop the producer iterations, or parallel iterations.</small></h4>

<br>
<h4 id='for'>(<b>for </b>((<i>sst string</i> ) â€¦) body</i>) â› sst values : consecutive substrings of length 1.</h4>
<h4 id='for'>(<b>for </b>((<i>i vector</i> ) â€¦) body</i>) â› i values : vector[0], vector[1], ...</h4>
<h4 id='for'>(<b>for </b>((<i>(k . v) hash</i> ) â€¦) body</i>) â› k, v values : all pairs (key . value) of <i>hash</i>, in unspecified order. <small>Requires hash.lib</small> </h4>
<h4 id='for'>(<b>for </b>((<i>rec table</i> ) â€¦) body</i>) â› rec values : successive rows -instances of structure - of <i>table</i>. <small>Requires sql.lib</small> </h4>
<h4 id='for'>(<b>for </b>((<i>gen procrastinator</i> ) â€¦) body</i>) â› gen values : successive calls of (next <i>procrastinator</i>). <small>Requires <a href= "#sequences.lib">sequences.lib</a>. <i>procrastinator</i> is a sequence, iterator, combinator, generator, ..</small> </h4>


<h3>Constructing values</h3>
<h4 id='for/fold'>(<b>for/fold </b><i> (acc init) ((i â€¦) â€¦)</i> body) â› returns acc - which is set to expr<sub>n</sub> at the end of each iteration</h4>
<h4 id='for/sum'>(<b>for/sum </b><i>((i â€¦) â€¦)</i> body) â› returns sum of expr<sub>n</sub></h4>
<h4 id='for/product'>(<b>for/product </b><i>((i â€¦) â€¦)</i> body) â› returns product of expr<sub>n</sub></h4>
<h4 id='for/list'>(<b>for/list </b><i>((i â€¦) â€¦)</i> body) â› returns list  of expr<sub>n</sub></h4>
<h4 id='for/vector'>(<b>for/vector </b><i>((i â€¦) â€¦)</i> body) â› returns vector of expr<sub>n</sub></h4>
<h4 id='for/string'>(<b>for/string </b><i>((i â€¦) â€¦)</i> body) â› returns string concatenation of expr<sub>n</sub></h4>
<br>
<h4 id='for/and'>(<b>for/and </b><i>((i â€¦) â€¦)</i> body) â› stops as soon as expr<sub>n</sub> is #f and returns #f. Else returns #t.</h4>
<h4 id='for/or'>(<b>for/or </b><i>((i â€¦) â€¦)</i> body) â› stops as soon as expr<sub>n</sub> is not #f and returns expr<sub>n</sub>. Else returns #f.</h4>
<br>
<h4 id='for/max'>(<b>for/max </b><i>((i â€¦) â€¦)</i> body) â›  returns max of expr<sub>n</sub>.</h4>




<h3>Nested loops</h3>
<h4 id='for*'>(<b>for* </b><i>((a range<sub>1</sub></i>)(b range<sub>2</sub>) â€¦) body) â› nested loops. Iterates over a, b, .. in order a<sub>1</sub> b<sub>1</sub> b<sub>2</sub> .. a<sub>2</sub> b<sub>1</sub> .. Inner loops are reinitialized at each outer loop iteration. A #:break stops the whole for* iterations.  Returns void, unless a #:break => ret-value is encountered. </h4>
<br>
<h4 id='for*/fold'>(<b>for*/fold </b><i> (acc init) ((i â€¦) â€¦)</i> body)</h4>
<h4 id='for*/sum'>(<b>for*/sum </b><i>((i â€¦) â€¦)</i> body)</h4>
<h4 id='for*/product'>(<b>for*/product </b><i>((j â€¦) â€¦)</i> body)</h4>
<h4 id='for*/list'>(<b>for*/list </b><i>((i â€¦) â€¦)</i> body)</h4>
<h4 id='for*/vector'>(<b>for*/vector </b><i>((k â€¦) â€¦)</i> body) </h4>
<h4 id='for*/string'>(<b>for*/string </b><i>((i â€¦) â€¦)</i> body)</h4>
<h4 id='for*/and'>(<b>for*/and </b><i>((i â€¦) â€¦)</i> body)</h4>
<h4 id='for*/or'>(<b>for*/or </b><i>((i â€¦) â€¦)</i> body)</h4>
<h4 id='for*/max'>(<b>for*/max </b><i>((i â€¦) â€¦)</i> body)</h4>


<pre>
<i>(for ((n 7)) (write (* n n n)))</i>  â›
	0 1 8 27 64 125 216 
<i>(for ((i (in-range 2 6 3/7))) (write i))</i>  â›
	2 17/7 20/7 23/7 26/7 29/7 32/7 5 38/7 41/7 
<i>(for ((i 3)(j (in-range 6 10))) (write (list i j)))</i>  â›
	(0 6) (1 7) (2 8) 
	
<i>(for ((i 1000)(j 1000)) #:break (= (+ i j) 10) (write i j)) </i>
 â› 0 0 1 1 2 2 3 3 4 4 
	
<i>(define noms '(albert simon ludwig elvis))</i>  â›   noms
<i>(define scores '(45 99 34 555))</i>  â›   scores
<i>(for ((n noms)(s scores)) (write (list n s)))</i>  â›  
	(albert 45) (simon 99) (ludwig 34) 

;; ğŸš´ Why bother with a recursive factorial ? :  9!
<i>(for/product ((f (in-range 2 10))) f)</i>  â›   362880  

;; sum(1/n<sup>2</sup>)  = &pi;<sup>2</sup>/6
<i>(for/sum ((n (in-range 1 100000))) (// 1 (* n n)))</i>  â›  1.6449240667982423 
<i>(/ (* PI PI) 6)</i>  â›   1.6449340668482264 ;; ğŸ˜² proof

;; Find x : cos(x) = x
(lib 'math)
<i>(for/fold (x 0.5) ((i 1000000))  #:break (~= x (cos x)) (cos x))</i>
     â†’  0.7390851332151605
     
;; Iterate over vector elements
<i>(define V (list->vector (iota 100)))
(for/sum [(vi V)] vi) </i>  â†’ 4950

;; Iterate over hash table
(lib 'hash)
<i>(define H (list->hash '((a . 1) (b . 2)(c . 3)) (make-hash)))
(for [ ((k . v) H)] (writeln 'key k 'value v))</i>

;; <mark>Nested loops</mark>
<i>(for* ((i 3)(j (in-range 6 10))) (write (list i j)))</i>
	 â›  (0 6) (0 7) (0 8) (0 9) (1 6) (1 7) (1 8) (1 9) (2 6) (2 7) (2 8) (2 9) 
<i>(for*/sum ((i 1000)(j 1000)) 1)</i>  â›   1000000 ;; count nested loops

;; &Sigma; &Sigma; (i + j - 1) = n<sup>3</sup>
<i>(for*/sum ((i (in-range 1 1001)) (j (in-range 1 1001))) (+ i j -1))</i>  â†’  1000000000 

;;Break and continue
<i>(for*/list ((i 4)(j 5)) #:continue (even? (+ i j)) (list i j))</i>
	â†’ ((0 1) (0 3) (1 0) (1 2) (1 4) (2 1) (2 3) (3 0) (3 2) (3 4))
<i>(for*/list ((i 4)(j 5)) #:break (> (+ i j) 4) (list i j))</i>
	â†’ ((0 0) (0 1) (0 2) (0 3) (0 4) (1 0) (1 1) (1 2) (1 3))

;; Local bindings may be used to initialize range expressions
<i>(for* ((i 5) ( j (1+ i))) (when (zero? j) (writeln)) (write (list i j)))</i>
(0 0)
(1 0) (1 1)
(2 0) (2 1) (2 2)
(3 0) (3 1) (3 2) (3 3)
(4 0) (4 1) (4 2) (4 3) (4 4) 

;; Break and return value
<i>(define i 0)
(while #t 
    (set! i (1+ i)) 
    #:break (> i 10) => 'NO_MORE 
    (write i))</i>
   â†’ 1 2 3 4 5 6 7 8 9 10 
   NO_MORE
</pre>

<h3>Do</h3>
<pre style = "border:none;margin-left:20px;">
<h4 id='do'>(<b>do </b> 
    ((variable<sub>1</sub> init<sub>1</sub> step<sub>1</sub>) â€¦) 
    (test final<sub>1</sub> â€¦) 
    expr<sub>1</sub> â€¦)</h4>
    Not very often used. See the Scheme report, <a href="https://people.csail.mit.edu/jaffer/r5rs_6.html">expressions</a>, 4.2.4.
</pre>

<h2 id="amb.lib">amb operator - amb.lib</h2>
<p>The amb library implements the non-deterministic<a href="http://rosettacode.org/wiki/Amb"> <b>amb</b> operator</a> as defined by John McCarthy : selection of choices among lists of values, and backtracking until all required conditions - constraints - are met.</p>

<h3>amb-select</h3>
<h4 id='amb-select'>(<b>amb-select </b><i>predicate:1:1 (values<sub>1</sub> values<sub>2</sub> ...</i>)) â†’ first selection of choices (c<sub>1</sub> c<sub>2</sub> ...) among <i>values</i> lists, such as (predicate (c<sub>1</sub> c<sub>2</sub> ...) ) is #t.</h4>
<br>
<h4 id='amb-select/random'>(<b>amb-select/random </b><i>predicate:1:1 (values<sub>1</sub> values<sub>2</sub> ...</i>)) â†’ random selection of choices (c<sub>1</sub> c<sub>2</sub> ...) among <i>values</i> lists, such as (predicate (c<sub>1</sub> c<sub>2</sub> ...) ) is #t.</h4>
<h4 id='amb-select/all'>(<b>amb-select/all </b><i>predicate:1:1 (values<sub>1</sub> values<sub>2</sub> ...</i>)) â†’ list of all selections of choices (c<sub>1</sub> c<sub>2</sub> ...) among <i>values</i> lists, such as (predicate (c<sub>1</sub> c<sub>2</sub> ...) ) is #t.</h4>

<pre>
(lib 'amb)
<i>(define (sum13 nums) (= 13 (apply + nums)))</i> ;; sum of numbers must be 13
;; first number in [0..6], second in [0..4], third in [0..7]

<i>(amb-select sum13 (list (iota 7) (iota 5) (iota 8)))</i>
   â†’ (2 4 7)
<i>(amb-select/random sum13 (list (iota 7) (iota 5) (iota 8)))</i>
   â†’ (3 4 6)
<i>(amb-select/random sum13 (list (iota 7) (iota 5) (iota 8)))</i>
   â†’ (5 3 5)
   
<i>(amb-select/all sum13 (list (iota 7) (iota 5) (iota 8)))</i>
   â†’ ((2 4 7) (3 3 7) (3 4 6) (4 2 7) (4 3 6) (4 4 5) (5 1 7) (5 2 6) (5 3 5) (5 4 4) (6 0 7) (6 1 6) (6 2 5) (6 3 4) (6 4 3))
</pre>

<h3>amb functions</h3>
<h4 id='amb-make-context'>(<b>amb-make-context </b>) â†’ a new amb context to make the following functions work.</h4>
<h4 id='amb'>(<b>amb </b><i>context list-of-values</i>) â†’ next choice among list-of-values</h4>
<h4 id='amb-fail'>(<b>amb-fail</b>) â†’ will force amb calls to backtrack, and try new choices</h4>
<h4 id='amb-require'>(<b>amb-require </b><i>expr</i>) â†’ same as (unless <i>expr</i> (amb-fail))</h4>
<br>
<h4 id='amb-run'>(<b>amb-run </b><i>proc:1:n context [args ...]</i>) proc is a one or more argument(s) procedure - (proc context args ...) - , which includes calls to amb and amb-fail/amb-require. Amb-run will try all possible choices until no failure is raised. Returns â†’ (proc context [args ..]) if success, else #f.</h4>
<br>
<h4 id='amb-choices'>(<b>amb-choices </b><i>context</i>) â†’ list of current choices</h4>
<h4 id='amb-vector'>(<b>amb-vector </b><i>context</i>) â†’ vector of current choices. <small>Same as (list->vector (amb-choices context)), but quicker.</small></h4>
<br>
<h4 id='distinct?'>(<b>distinct? </b><i>list</i>) â†’ #t if all elements of list are distincts - not eq? - . Else #f</h4>

<pre>
(lib 'amb)
;; find numbers a,b such as a<sup>3</sup> + b<sup>3</sup> is a square
<i>
(define (square-sum context)
    (define a (amb  context (range 1 100)))
    (define b (amb  context (range 1 100)))
    (amb-require (< a b))
    (amb-require (square? (+ (* a a a ) (* b b b ))))
    (writeln 'square-sum-of-cubes a b)
    (amb-fail))</i> ;; show all solutions

<i>(amb-run square-sum  (amb-make-context))</i> â†’ 
  square-sum-of-cubes     1     2    
  square-sum-of-cubes     2     46    
 ...  
  square-sum-of-cubes     10     65    
  square-sum-of-cubes     11     37    
...
</pre>


<h2 id="catch"> Try, catch and throw</h2>
<p>Near the same construct as in javascript. Note that the <b>catch</b> procedure has two parameters. An error-id is a symbol. The body of a try or catch expression is a sequence of expressions. Its value is the value of the last evaluated expression</p>
<h4 id='throw'>(<b>throw </b><i>error-id message</i>) -> throws an user exception named <i>error-id</i>, with message <i>message</i> which can be any object. </h4>
<br>
<h4 id='try'>(<b>try</b> try-body (<b>catch</b> (id message) catch-body</i>)) -> 
<br>Evaluates try-body in sequence. If any <u>user</u> exception is thrown, calls the catch procedure with parameters error-id and message , executes its catch-body and return its value.<br>
According to the received error-id, the catch procedure may decide to return something, or to leave, and return to top-level, by calling (<a href="#error">error</a> ...) . </h4>
<pre>
See or load <a href="./lib/calc.glisp">calc.glisp</a> for use of (catch) and (throw)
</pre>    

<h2 id="stacks">Stacks</h2>
<p>Stacks may be used when appropriate in place of lists, for performance or simplicity reasons. Stacks have identifiers - <i>stack-id</i> , are global objects, are not bound to a variable with the same name. Stacks pop values LIFO style. Use (stack (gensym)) to get a safe, anonymous stack. Stack values may be any EchoLisp object. See <a href="http://rosettacode.org/wiki/Create_an_HTML_table#EchoLisp">html</a> example.</p>
<h4 id='stack'>(<b>stack </b><i>stack-id</i>) new empty stack â› stack-id </h4>
<h4 id='stack-empty?'>(<b>stack-empty? </b><i>stack-id</i>) â› #t or #f </h4>
<h4 id='stack-length'>(<b>stack-length </b><i>stack-id</i>) â› # of items</h4>
<br>
<h4 id='push'>(<b>push </b><i>stack-id value</i>) push value  â› value</h4>
<h4 id='stack-top'>(<b>stack-top </b><i>stack-id</i>) â› value, or #f if stack is empty</h4>
<h4 id='pop'>(<b>pop </b><i>stack-id</i>) â› pop value, or #f if stack is empty</h4>
<br>
<h4 id='stack->list'>(<b>stack->list </b><i>stack-id</i>) â› stack contents, as a list</h4>
<h4 id='list->stack'>(<b>list->stack  </b><i> list stack-id</i>) â› new stack from list</h4>
<h4 id='stack-swap'>(<b>stack-swap </b><i>stack-id</i>) â› swaps stack[top] & stack[top-1]</h4>


<pre>
<i>(push 'my-stack (+ 2000 15))</i>  â†’   2015
<i>(push 'my-stack 'simon)</i>  â†’   simon
<i>(pop 'my-stack)</i>  â†’   simon
<i>my-stack</i>
	â— error: |user| : unbound variable : my-stack
<i>(pop 'my-stack)</i>  â†’   2015
<i>(pop 'my-stack)</i>  â†’   #f

<i>(define (list->html item)
  (if (list? item)
	(begin (push 'html "&lt;ul&gt;\n")
	       (for-each list-&gt;html item) 
	       (push 'html "&lt;/ul&gt;\n"))
	(begin (push 'html "&lt;li&gt;") 
	       (push 'html item) 
	       (push 'html "&lt;/li&gt;\n"))))
	
(stack 'html)
(list->html 
 '(people (gallubert simon) ( wittgenstein ludwig ) (presley (elvis aaron) )))
string-join (stack->list 'html) " ")</i>  â†’
 </pre>
 
<h4>
<ul>
<li> people </li>
<ul>
<li> gallubert </li>
<li> simon </li>
</ul>
<ul>
<li> wittgenstein </li>
<li> ludwig </li>
</ul>
<ul>
<li> presley </li>
<ul>
<li> elvis </li>
<li> aaron </li>
</ul>
</ul>
</ul>
</h4>

<h2 id="boxes">Boxes</h2>
<p>Boxes are 1-dimension object, which serve as containers for a value, and allow to pass objects by reference.</p>
<h4 id='box'>(<b>box </b><i> value</i>) â› a new box, container for <i>value</i></h4>
<h4 id='set-box!'>(<b>set-box! </b><i>a-box value</i>) â› -> set box contents</h4> 
<h4 id='unbox'>(<b>unbox </b><i>a-box</i>) â› get contents</h4>
<h4 id='box?'>(<b>box? </b><i>a-box</i>) â› is a-box a box ? #t or #f</h4>

<pre>
<i>(box 42)</i>  â›   #[box 42]
<i>(define schrÃ¶dinger (box "cat"))</i>  â›   schrÃ¶dinger
<i>schrÃ¶dinger</i>  â›   #[box "cat"]
<i>(box? schrÃ¶dinger)</i>  â›   #t
<i>(box? "cat")</i>  â›  #f ;; ğŸ˜ "cat" is a string is not a box

<i>(set-box! schrÃ¶dinger "dog")</i>  â›   #[box "dog"]
<i>schrÃ¶dinger</i>  â›   #[box "dog"]
<i>(unbox schrÃ¶dinger)</i>  â›   "dog"

;; passing objects by reference
<i>(define (fill-box b) (set-box! b "chinchard"))</i>  â†’   fill-box

<i>(fill-box schrÃ¶dinger )</i> 
<i>(unbox schrÃ¶dinger )</i>  â†’   "chinchard"
</pre>



<h2 id = "delay">Promises - (delay â€¦) & (force â€¦)</h2>
<p>Delay and force implement lazy evaluation by means of <i>promises</i> objects.</p>
<h4 id='delay'>(<b>delay </b><i>expression</i>) â› a promise to eval expression</h4>
<h4 id='force'>(<b>force </b><i>promise</i>) â› force and cache evaluation</h4>
<h4 id='promise?'>(<b>promise? </b><i>promise</i>) â› is <i>promise</i> a promise? #t or #f</h4>
<p><small>Promises are displayed as 'promise:' - waiting to be forced - or 'promise!' - forced and cached - </small></p>

<pre>
<i>(define aard-work (delay (+ 21 21)))</i>  
<i>aard-work </i>  â›   #[promise: (#+ 21 21)]
<i>(force aard-work)</i>  â›   42
<i>aard-work</i>  â›   #[promise! 42]
<i>(promise? aard-work)</i>  â›   #t

<i>(promise? 42)</i>  â›   #f

<i>(define (prom m) 
	(delay (begin 
		(write "computing next prime " m) 
		(next-prime m))))</i>  â›   prom
		
<i>(define next1000 (prom 1000))</i>  
<i>next1000</i>  
	â›   #[promise: (#begin (#write "computing next prime " m) (#next-prime m))]

<i>(force next1000)</i>  â›  "computing next prime " 1000  1009
<i>next1000</i>  â›   #[promise! 1009] ;; cached value
<i>(force next1000)</i>  â›   1009
</pre>


<h2 id = "streams">Streams</h2>
<p>Lists are pairs of values  (first-value . rest-value) : rest-value is either a list or the empty null list. Values can be extracted  by the first (synonym car) and rest (synonym cdr) procedures.
<br> Streams can be seen as pairs (first-value . rest-value) which can be extracted by the stream-first and stream-rest procedures. The difference with a list is that rest-value is either a stream, or a procedure which returns a stream. The computation of rest-value is <b>delayed</b>, and forced only if needed. This allow to - recursively - construct infinite streams.<br>
Like for lists, a constructor - stream-cons - is provided, and various operations such as map, filter, .. can be performed on (infinite) streams.
<br>make-stream is used to build a stream from a function which takes a state in input and returns a pair (value . new state).
<br><br>
<b>empty-stream</b> is a pre-defined object, which evaluates to itself, the equivalent of <b>null</b> for lists.</p>
<br>
<h4 id='stream?'>(<b>stream? </b><i>object</i>) is object a stream? â› #t or #f</h4>
<h4 id='stream-empty?'>(<b>stream-empty? </b><i>object</i>) is object the empty-stream ? #t or #f</h4>
<h4 id='stream-cons'>(<b>stream-cons </b><i>first-value rest-stream</i>) â› new stream ( first . rest-stream)</h4>
<h4 id='stream-cons'>(<b>stream-cons </b><i>first-value rest-proc</i>) â› new stream (first . (delay rest-proc))</h4>
<h4 id='stream-cons'>(<b>stream-cons </b><i>first-value</i> empty-stream) â› new stream ( first-value . empty)</h4>
<br>
<h4 id='make-stream'>(<b>make-stream </b><i>state-proc initial-state</i>) â›  a new stream, formed by calling state-proc successively.
Each call is <i>(state-proc state)</i>, it should return a pair, the first item (car) being the value for the stream, and the rest (cdr) being the new state for the next call. For the first call, state is the given initial-state. At the end of the stream, proc should return some non-pair object. <a href="https://www.gnu.org/software/guile/manual/html_node/Streams.html">[Ref]</a></h4>
<br>
<h4 id='stream-first'>(<b>stream-first </b><i>stream</i>) â› first-value</h4>
<h4 id='stream-rest'>(<b>stream-rest </b><i>stream</i>) â› empty-stream or new stream = (force rest-value)</h4>
<br>
<h4 id='stream-add'>(<b>stream-add </b><i>stream_1 stream_2</i>) â› new stream, sum of stream_i</h4>
<h4 id='stream-mul'>(<b>stream-mul </b><i>stream_1 stream_2</i>) â› new stream, product of stream_i</h4>
<h4 id='stream-map'>(<b>stream-map </b><i>  proc:2 stream_1 stream_2</i>) â› new stream, delivering (proc stream_1 stream_2)</h4>
<h4 id='stream-filter'>(<b>stream-filter </b><i>  fiter-proc:1 stream</i>) â› new stream, delivering  elements of <i>stream</i> filtered by (filter-proc elem) = #t</h4>
<br>
<h4 id='stream-ref'>(<b>stream-ref </b><i>stream n</i>) â› nth value of stream (forces eval of values 0 ... n)</h4>
<h4 id='stream->list'>(<b>stream->list </b><i>stream </i>) â› list of values -  âœ‹ careful if infinite stream !</h4>
<h4 id='stream->list'>(<b>stream->list </b><i>stream  limit </i>) â› list of n first values, n = min(limit, stream-length)  </h4>
<h4 id='stream->list'>(<b>take </b><i>stream  limit </i>) â› same as (stream->list stream limit)  </h4>
<br>
<h4 id='stream-iterate'>(<b>stream-iterate </b><i>stream</i>) â› destructive operation, delivering (stream-first <i>stream</i>) at each successive call, and replacing <i>stream</i> by (stream-rest <i>stream</i>), until the stream is empty.</h4>
<br>
<h3 id= "predefined-sequences">Built-in streams & iterations</h3>
<p>See <a href="#for">for</a> constructs, for usage of sequences/streams as iterators.</p>
<h4 id='in-cycle'>(<b>in-cycle </b><i>list</i>) â› infinite list delivering again and again the contents of <i>list</i></h4>
<br>
<h4 id='in-naturals'>(<b>in-naturals </b><i>[start]</i>) â› stream delivering 0,1,... âˆ or start,start+1,... âˆ</h4>
<h4 id='in-range'>(<b>in-range </b><i>end</i>) â› stream delivering 0,1,... end-1</h4>
<h4 id='in-range'>(<b>in-range </b><i> start end</i>) â› stream delivering start, start+1,..,end-1</h4>
<h4 id='in-range'>(<b>in-range </b><i> start end step</i>) â› stream delivering start,...,end-1 by increments of step. Start,end,step do not need to be integers.</h4>
<h4 id='in-range+'>(<b>in-range+ </b><i> start [end [step]]</i>) â› stream delivering start .. end . <small>Same as in-range, but end value is included in sequence</small>
<br>
<h4 id='in-permutations'>(<b>in-permutations </b><i>n</i>) â› stream delivering the n! permutations of the list (0 ... n-1). Requires the '<a href= "#list.lib">list</a>' library : (load 'list).
<h4 id='in-primes'>(<b>in-primes </b><i>n</i>) â› infinite stream delivering successive primes from n. Requires the '<a href= "#math.lib">math</a>' library : (load 'math).

<pre>
;; using make-stream
<i>(define odds (make-stream 
     (lambda (state) (cons state (+ state 2)))   
     1))</i>  â†’   odds
<i>(stream-first odds)</i>  â†’   1
<i>(stream-first (stream-rest odds))</i>  â†’   3
<i>odds</i>  â†’   #stream:id:2 first: 1
<i>(for ((i 9)) (write (stream-iterate odds)))</i>
     1 3 5 7 9 11 13 15 17
<i>odds</i>  â†’   #stream:id:2 first: 19 ;; modified stream

;; using stream-cons
<i>(define (integers-starting-from n)
     (stream-cons n
     (integers-starting-from (+ n 1))))</i>  â†’   integers-starting-from
<i>(define n666 (integers-starting-from 666))</i> 
<i>n666</i>  â†’   #stream:id:12 first: 666
<i>(stream->list n666 10)</i>  â†’   (666 667 668 669 670 671 672 673 674 675)
<i>n666</i>  â†’   #stream:id:12 first: 666

<i>(define fibs
	(stream-cons 0
		(stream-cons 1
			(stream-add (stream-rest fibs) fibs))))</i>  â†’   fibs
<i>(stream->list fibs 10)</i>  â†’   (0 1 1 2 3 5 8 13 21 34)

;; built-in numerical streams
<i>(define a (in-range 5 9 1/3))
(stream->list a 7)</i>  â†’ (5 16/3 17/3 6 19/3 20/3 7)

;; sequence
<i>(define inf (in-cycle '( a b c)))</i>  
<i>(take inf 10)</i>  â†’   (a b c a b c a b c a)

;; usage in a (for ...) loop
<i>(for/list ((i (in-range+ 2 12 2))) i)</i> â†’ (2 4 6 8 10 12)
</pre>


<h2 id="plist">Property lists</h2>
<p>A property list (plist for short) is a hash table of (key value) pairs associated with a symbol. A key is either a symbol or a string. There are no duplications among the keys; a property list may only have one property at a time with a given key. Plists are slightly deprecated and may be remplaced by <a href= "#hash.lib">hash</a> tables. </p>

<h4 id='plist-keys'>(<b>plist-keys </b><i>symb</i>) â› sorted list of keys in hash table </h4>
<h4 id='putprop'>(<b>putprop </b><i>symb value key</i>) â› adds or replace value for key </h4>
<h4 id='getprop'>(<b>getprop </b><i>symb key</i>) â› value or #f</h4>
<h4 id='get'>(<b>get </b><i>symb key</i>) â› same as getprop</h4>
<h4 id='remprop'>(<b>remprop </b><i>symb key</i>) removes property 'key'. â› #t if found</h4>

<h4 id='symbol-plist'>(<b>symbol-plist </b><i>symb</i>) â› gets the whole plist</h4>
<h4 id='set-plist!'>(<b>set-plist! </b><i>symb ((key<sub>1</sub> value<sub>1</sub></i>)(key<sub>2</sub> value<sub>2</sub>) ..)) â› sets the whole plist</h4> 

<pre>
<i>(putprop 'simon 66 'age)</i>  â†’   66
<i>(putprop 'simon '(my-life me-and-Sigmund) 'books)</i>  â†’   (my-life me-and-Sigmund)

<i>(get 'simon 'age)</i>  â†’   66
<i>(get 'simon "age")</i>  â†’   66
<i>(get 'simon 'books)</i>  â†’   (my-life me-and-Sigmund)
<i>(putprop 'simon 'antoinette 'wife)</i>  â†’   antoinette
<i>(symbol-plist 'simon)</i>  
    â†’   (("age" 66) ("books" (my-life me-and-Sigmund)) ("wife" antoinette))
    
<i>(plist-keys 'simon)</i> â†’ ("age" "books" "wife")
<i>(for ((k (plist-keys 'simon))) (writeln k (get 'simon k)))</i>
   "age"     66    
   "books"     (my-life me-and-Sigmund)    
   "wife"     antoinette    

<i>(remprop 'simon 'wife)</i>   â†’   #t ;; ğŸ˜¡ divorce
<i>(get 'simon 'wife)</i>  â†’   #f
</pre>


<h2 id = "hash.lib">Hash tables - hash.lib</h2>
<p>Hash tables - hash for short - extend property lists. A hash object is a set of unordered  (key . value) pairs. A key is either a symbol, a number, or a string or a list of [symbol|number|string]. There are no duplications among the keys; a hash may only have one value at a time with a given key.
<br>Keys are tested with equal? predicate, i.e '(a b c) and (cons a '( b c)) are the same key, although not the same object in memory.
</p>

<h4 id='make-hash'>(<b>make-hash </b>) â› new hash</h4>
<h4 id='hash?'>(<b>hash? </b><i>obj</i>) is obj a hash ? â› #t or #f</h4>
<h4 id='hash-clear!'>(<b>hash-clear! </b><i>hash</i>) â› clears all (key . value) in hash</h4>
<h4 id='hash-count'>(<b>hash-count </b><i>hash</i>) â› # of keys in <i>hash</i></h4>
<h4 id='hash-set'>(<b>hash-set </b><i>hash key value</i>)  sets or replaces (key . value) in <i>hash</i>  â› value </h4>
<h4 id='hash-ref'>(<b>hash-ref </b><i>hash key</i>) â› value for key, or #f</h4>
<br>
<h4 id='hash-ref!'>ğŸ‘€  (<b>hash-ref! </b><i>hash key set-expr)</i>) â› returns value for key, or, if not found, sets value to (eval <i>set-expr</i>) - <small>Note that <i>set-expr</i> is not evaluated if value is found, and may be a constant, like #f ,"NOT YET DEFINED" , ... </small></h4>
<h4 id='hash-ref!'>ğŸ‘€  (<b>hash-ref! </b><i>hash key set-proc:1:n)</i>) â› returns value for key, or, if not found, sets value to (<i>set-proc</i> key) - <small>Note that <i>set-proc</i> is not evaluated if value is found. If key is a list (key<sub>1</sub> key<sub>2</sub> ...) (<i>set-proc</i> key<sub>1</sub> key<sub>2</sub> ...) is evaluated. </small></h4>
<br>
<h4 id='hash-get-key'>(<b>hash-get-key </b><i>hash value</i>) â› one key for value, or #f. <small>Note: values are compared with equal?. This search by value is linear: â„¦(n)</small> </h4>
<h4 id='hash-get-keys'>(<b>hash-get-keys </b><i>hash value</i>) â› list of all keys  for value, or null.</small> </h4>
<br>
<h4 id='hash-remove!'>(<b>hash-remove! </b><i>hash key</i>) removes (key . value) from <i>hash</i>. â› <i>hash</i></h4>
<h4 id='hash-map'>(<b>hash-map </b><i>hash proc:2:2</i>) call (proc key value) for all (key . value) in <i>hash</i> â›  list of all results</h4>
<h4 id='hash-for-each'>(<b>hash-for-each </b><i>hash proc:2:2</i>) call for side-effect (proc key value) for all (key . value). â›  void</h4>
<h4 id='hash->list'>(<b>hash->list </b><i>hash</i>) â› new list, <i>hash</i> converted to a list of (key . value), in unspecified order.</h4>
<h4 id='list->hash'>(<b>list->hash </b><i>list hash</i>) add/replace all (key . value) of <i>list</i> into <i>hash</i>. â› <i>hash</i></h4>
<br>
<h4 id='hash-keys'>(<b>hash-keys </b><i>hash</i>) â› list of all keys, in unspecified order.</h4>
<h4 id='hash-values'>(<b>hash-values </b><i>hash</i>) â› list of all values, in unspecified order.</h4>

<br>
<h4 id='hash-make-index'>(<b>hash-make-index </b><i>hash</i>) -> caches an internal index of <i>hash</i> (key . value) pairs. Returns hash.count = (hash-count hash)</h4>
<h4 id='hash-index-key'>(<b>hash-index-key </b><i>hash</i>) -> key for index <i>index</i> in [0...hash.count]</h4>
<h4 id='hash-index-value'>(<b>hash-index-value </b><i>hash</i>) -> value for index <i>index</i> in [0...hash.count]</h4>
<br>
<h4 id='hash'>(<b>hash </b><i>object</i>) â› an integer in [0..2<sup>32</sup>-1]. <small>Note. (unhash integer)  â›  object is not yet implemented</small>


<pre>
(lib 'hash)

<i>(doc #t)</i>  â†’   #t
<i>(define H (make-hash))</i>  â†’   H

<i>(list->hash '((simon . antoinette) (georges . ludwig) ((antoinette simon) . (jeremy kevin)) (2015 . wedding)) H)</i>  â†’   #hash:5 ;; 5 elements in H

<i>(hash-ref H 'simon)</i>  â†’   antoinette
<i>(hash-ref H '(antoinette simon))</i>  â†’   (jeremy kevin) ;; keys and values may be lists
<i>(hash-set H 'elvis "the king")</i>
<i>(hash-ref H 'elvis)</i>  â†’   "the king"

<i>(hash->list H)</i>  â†’   ((simon . antoinette) (georges . ludwig) ((antoinette simon) jeremy kevin) (2015 . wedding) (elvis . "the king"))
<i>H</i>  â†’   #hash:5

;; Using hash to cache (remember) a function values
<i>(define DISTANCES (make-hash))
(define (dist x y) 
	(writeln 'compute:dist x y) 
	(sqrt (+ (* x x) (* y y))))</i>

<i>(hash-ref! DISTANCES '(3 4) dist)</i>  
		compute:dist     3     4  ;; value is computed
		â†’   5 
<i>(hash-ref! DISTANCES '(3 4) dist)</i>  â†’   5 ;; value is cached

;; retrieving keys
<i>(hash-get-key H '(jeremy kevin))</i>  â†’   (antoinette simon)
<i>(hash-get-key H 'wedding)</i>  â†’   2015

;; indexing
<i>(hash-make-index H)</i>  â†’   5
<i>(hash-index-key H 3)</i>  â†’   2015
<i>(hash-index-value H 3)</i>  â†’   wedding
<i>(hash-index-value H 333)</i>
ğŸ˜¡ error: hash-index-value : index out of range : 333

;; iterating with (for ..)
;; (first element) is key
;; (rest  element) is value
<i>(for ((element H)) (write (first element)))</i>
 â†’  simon georges (antoinette simon) 2015 elvis 
 
;; hash values
<i>(hash 'Simon)</i> â†’ 4297711
<i>(hash "Simon")</i> â†’ 1598507
</pre>

<h2 id = 'sql.lib'>Tables - SQL.LIB</h2>
<p>Tables are ordered collections of rows - records - , the contents of which are array-like values of consecutive fields - slots, columns - inside a row. Table may be filled with instances of <a href="struct.lib">structures</a> or list of values. A table is associated with a structure, which give names to the fields.
<br>Tables may be indexed - sorted - and searched by row-number, or contents of fields. The <i>select</i> SQL statement allows elaborate searchs, selections, and grouping.
<br>
<h4 id='make-table'>(<b>make-table </b><i>struct</i>) â› new table, from <i>struct</i> as returned by (struct name (field-name ...))</h4>
<h4 id='table?'>(<b>table? </b><i>object</i>) is <i>object</i> a table ? â› #t or #f</h4>
<h4 id='table-count'>(<b>table-count </b><i>table</i>) â› number of rows in <i>table</i></h4>
<h4 id='table->list'>(<b>table->list </b><i>table</i>) â› contents of table in list form : (row<sub>0</sub> row<sub>1</sub> ..), where row<sub>i</sub> is (field<sub>0</sub> field<sub>1</sub> ...) .</h4>
<h4 id='list->table'>(<b>list->table </b><i>list table</i>) â› appends the contents of <i>list</i> to <i>table</i> ;<small> <i>list</i> is a list of rows, in list format. Missing ending fields in a row are filled with #f. </small></h4>
<br>
<h4 id='table-print'>(<b>table-print </b><i>table [nfrom [nto]]</i>) tabular printing of rows<sub>nfrom</sub> (default 0) to row<sub>nto</sub> (default table-count)â› void</h4>
<h4 id='table->html'>(<b>table->html </b><i>table </i>) â› html source string : "&lt;table&gt; &lt;tr&gt;  ..&lt;/table&gt;" filled with table contents.</h4>
<br>
<h4 id='table-insert'>(<b>table-insert </b><i>table struct</i>) â› inserts a new row, row<sub>n</sub>, the contents of which is given by an instance of structure, and returns n.  <small>Insertion is made by reference, <i>struct</i> and row<sub>n</sub> share the same data.</small></h4>
<h4 id='table-insert'>(<b>table-insert </b><i>table list-of-values</i>) inserts a new row, row<sub>n</sub>, the contents of which is given by <i>list-of-values</i>, and returns n.</h4>
<br>
<h4 id='table-ref'>(<b>table-ref </b><i>table row-index</i>) â› a structure instance = table[row-index] or #f. <small>row-index in [0.. table-count[</small></h4>
<h4 id='table-xref'>(<b>table-xref </b><i>table row-index col-index</i>) â› a value = table[row-index][col-index] or #f. <small>col-index in [0 ... # of columns[</small></h4>
<h4 id='table-set!'>(<b>table-set! </b><i>table row-index struct</i>) replaces - by reference - table[row-index] by <i>struct</i> â› <i>struct</i></h4>
<h4 id='table-xset!'>(<b>table-xset! </b><i>table row-index col-index value</i>) replaces table[row-index][col-index] by <i>value</i> â› value</h4>
<br>
<h4 id='table-sort'>(<b>table-sort </b><i>table sort-proc:2:2</i>) â› sorts table according to sort-proc. <small><i>sort-proc</i> compares two instances of structures, a and b, and returns a number < 0 (a lesser than b), 0 (equal), or > 0 (a greater than b).</small></h4>
<br>
<h4 id='table-make-index'>(<b>table-make-index </b><i>table field-name</i>) â› indexes table on field-name</h4>
<h4 id='table-search'>(<b>table-search </b><i>needle table field-name</i>) â› row-num = the first row for which row[field-name] = needle or #f . <small>eq? predicate is used. The table is indexed on field-name, if not already done.</small></h4>

<pre>
Example in <a href="http://rosettacode.org/wiki/Table_creation/Postal_addresses#EchoLisp">Rosetta code</a>
</pre>

<br>
<h3>Select</h3>
<pre>
	(<b>sql-select</b> [<b>distinct</b>] fields <b>from</b> table [where-clause] [order-clause] [group-clause] [into-clause] [<b>limit</b> num-records])
	
	fields := field-name [ field-name ..] | * | (aggregate-function field-name) ...
	field-name := field-number | structure-name.slot-name
	aggregate-function := <b>min|max|sum|count</b>
	where-clause := <b>where</b> (where-proc:1) | where (where-proc:2 arg<sub>2</sub>)
	order-clause := <b>order-by</b> field-name [asc|desc] ...
	group-clause := <b>group-by</b> field-name ...
	into-clause := <b>into</b> <i>table</i>
	
	where-proc := a procedure which will be given a record - instance of structure - as first argument, and must return #t or #f. Inside a where-proc, the (<b>row-num</b>) function returns the current record row number.
	
	(sql-select ..) returns a list of records or a list of groups , each group being a list of records. If the <b>into</b> option is used, sql-select stores the results - append mode - in the output table.
	
	(<b>sql-delete</b>  <b>from</b> table [where-clause]) deletes all records for which (where-proc record [arg<sub>2</sub>]) is #t. Delete all records if no where-clause. Returns <i>table</i>.

</pre>

<pre>
Example in <a href="http://rosettacode.org/wiki/Top_rank_per_group#EchoLisp">Rosetta code</a>
</pre>


<h2 id = "alist">Association lists</h2>
<p>An association list (alist for short) ia a list of (key value) pairs. Keys need not to be unique. The look-up procedure return #f or the <b>first</b> found pair matching a key. </p>

<h4 id='alist?'>(<b>alist? </b><i>object</i>) â› is object an association list? â› #t or #f</h4>
<h4 id='assoc'>(<b>assoc </b><i>key alist</i>) â› (key<sub>i</sub> value<sub>i</sub>) with (equal? key key<sub>i</sub>), or #f</h4>
<h4 id='assq'>(<b>assq </b><i>key alist</i>) â› (key<sub>i</sub> value<sub>i</sub>) with (eq? key key<sub>i</sub>), or #f</h4>
<h4 id='assv'>(<b>assv </b><i>key alist</i>) â› (key<sub>i</sub> value<sub>i</sub>) with (eqv? key key<sub>i</sub>), or #f</h4>
<h4 id='association-procedure'>(<b>association-procedure </b><i>predicate selector</i>) â› a custom look-up procedure using <i>selector</i> to extract keys, and <i>predicate</i> to compare keys.</h4>

<pre>
<i>(define echolalie '((ceo simon) (engineer antoinette) (programmer jean-albert)))</i>  â†’   echolalie
<i>(alist? echolalie)</i>  â†’   #t
<i>(assoc 'ceo echolalie)</i>  â†’   (ceo simon)
<i>(assoc 'engineer echolalie)</i>  â†’   (engineer antoinette)
<i>(assoc 'ludwig echolalie)</i>  â†’   #f

<i>(set! echolalie (cons '(ceo antoinette) echolalie))</i>  â†’   echolalie
<i>echolalie</i> 
    â†’   ((ceo antoinette) (ceo simon) (engineer antoinette) (programmer jean-albert))
<i>(assoc 'ceo echolalie)</i>  â†’   (ceo antoinette)

;; use second item (= cadr) as key
<i>(define by-value (association-procedure equal? cadr))</i>  â†’   by-value
<i>(by-value 'simon echolalie)</i>  â†’   (ceo simon)
</pre>

<h2 id = "style">Styles</h2>
<p>CSS styles may be applied to classes of objects (error, string, ..) or particular symbols. Use the function <b>style</b> to specify a style.</p>
<h4>(<b>style</b>) â› all styles list, in (key-string value-string) format.</h4>
<h4 id='style'>(<b>style </b><i>class-id</i>) â›  style for this class or #f</h4>
<h4 id='style'>(<b>style </b><i>object</i>) â›  style for this object or #f</h4>
<h4 id='style'>(<b>style </b><i>class-id css-style</i>) â› set style for all objects of class</h4>
<h4 id='style'>(<b>style </b><i>object css-style</i>) â› set style for this object</h4>


<pre>
;;; CLASSES and DEFAULT STYLES

<i>(style)</i> ->
 (("<span style='color:gray'>echo</span>" "<span style='color:darkslategray'>color:gray</span>")
 ("<span style='color:red'>error</span>" "<span style='color:darkslategray'>color:red</span>")
 ("<span style='color:magenta'>jserror</span>" "<span style='color:darkslategray'>color:magenta</span>")
 ("<span style='color:orangered'>warning</span>" "<span style='color:darkslategray'>color:orangered</span>")
 ("<span style='color:gray'>trace</span>" "<span style='color:darkslategray'>color:gray</span>")
 ("<span style='color:green'>store</span>" "<span style='color:darkslategray'>color:green</span>")
 ("<span style='color:darkslategray'>string</span>" "<span style='color:darkslategray'>color:darkslategray</span>")
 ("<span style='color:blue'>function</span>" "<span style='color:darkslategray'>color:blue</span>")
 ("<span style='color:red'>mark</span>" "<span style='color:darkslategray'>color:red</span>")
 ("<span style='color:brown'>complex</span>" "<span style='color:darkslategray'>color:brown</span>")
 ("<span style='color:green'>bigint</span>" "<span style='color:darkslategray'>color:green</span>")
 ("<span style='color:black'>javascript</span>" "<span style='color:darkslategray'>color:black</span>") 
 
 ("<span style='color:blue;font-weight:bold'>lambda</span>" "<span style='color:darkslategray'>color:blue;font-weight:bold</span>")
 ("<span style='color:blue;font-weight:bold'>Î»</span>" "<span style='color:darkslategray'>color:blue;font-weight:bold</span>"))
 
<i>I</i>
  â†’ <span style='color:goldenrod'>0+i</span>
<i>(style "complex" "color:red")</i>
  â†’ "<span style='color:red'>complex</span>"
<i>I</i>
  â†’ <span style='color:red'>0+i</span>
<i>(style "string" "text-transform: capitalize")</i>
  â†’ "<span style='text-transform: capitalize'>string</span>"
<i>'("albert" "ludwig" "elvis")</i>
  â†’ ("<span style='text-transform: capitalize'>albert</span>" "<span style='text-transform: capitalize'>ludwig</span>" "<span style='text-transform: capitalize'>elvis</span>")

<i>(style 'elvis "font-size:24px;color:red")</i>
<i>'(albert elvis antoinette)</i>  
  â†’ (Albert <span style='font-size:24px;color:red'>elvis</span> Antoinette)
</pre>


<h2 id="errors">Errors</h2>
<h3>"All warnings are orange, except a few errors" (Ludwig Wittgenstein)</h3>
<p> Errors, either EchoLisp or user generated,  are displayed in <span style="color:red"><b>red color</b></span> and stop program execution, i.e return to top-level. Javascript detected error are displayed in <span style="color:magenta"><b>magenta color</b></span> and stop execution. ğŸ“« Please, be so kind to <a href="mailto:echolalie@echolalie.com?subject=EchoLisp-JSBogue" title = "Ecrire">report</a> these  magenta errors. Warnings are displayed in <span style="color:orange"><b>orange color</b></span> and do not stop program execution.<br>
Results of input/output operations, either successful or not, are displayed in <span style="color:green"><b>green color</b></span> and generally do not stop program excecution.
</p>
<h4 id='error'>(<b>error </b><i>message-string object</i>) â› generates an error.</h4>

<pre>
<i>(+ 8 9))))</i>
	ğŸ˜ <span style="color:orange">warning: reader : too many right parenthesis: ')'</span>
	â†’ 17
	
<i>(for ((i 99999999)) (if (= i 666) (error "bad number:" i)))</i>
	ğŸ’¬ <span style="color:red">error: bad number: 666 </span>
</pre>


<h2 id="debug">Debugging</h2>
<h4 id='trace'>(<b>trace </b><i>function-id</i>) -> argument values, [stack depth] and return value for f</h4>
<h4 id='untrace'>(<b>untrace </b><i>function-id</i>)</h4>
<br>
<h4 id='assert'>(<b>assert </b><i>expression</i>) â› error if expression evals to #f</h4>
<h4 id='assert'>(<b>assert </b><i>expression message-string</i>)</h4>
<h4 id='check-expect'>(<b>check-expect </b><i>expression value</i>) â› warning if (not (equal? expression value))</h4>
<br>
<h4 id='time'>(<b>time </b><i>expression</i>) â› time (msec) to eval expression</h4>
<br>
<h4 id='debug'>(<b>debug </b><i>option</i>) â› sets debug option (0 is default = none). The debug options - which may be ORed - are: 
<br>1 = print compilation output
<br>2 = print syntax expansion output. </h4>
<br>
<h4 id='js-eval'>(<b>js-eval </b><i>javascript-expression-string</i>) evaluates js expression â› number or string</h4>
<br>
<h4 id='console-log'>(<b>console-log </b><i>message object</i>) â› message and lisp representation of <i>object</i> to javascript debugger console</h4>
<h4 id='console-dir'>(<b>console-dir </b><i>object</i>) â› javascript representation of <i>object</i> to debugger console</h4>
<h4 id='console-trace'>(<b>console-trace </b><i>message object</i>) â› functions calls history trace to javascript console</h4>
<h4 id='jsonify'>(<b>jsonify </b><i>object</i>) â› string : <i>object</i> translated to JSON.</h4>


<pre>
<i>(define (f n) (if (<= n 0) 2 (* n (f (- n 2)))))</i>  â†’   f
<i>(trace 'f)</i>  â†’   #t
ğŸ’¡ [0]     --> f _n 9
ğŸ’¡ [1]         --> f _n 7
ğŸ’¡ [2]             --> f _n 5
ğŸ’¡ [3]                 --> f _n 3
ğŸ’¡ [4]                     --> f _n 1
ğŸ’¡ [5]                         --> f _n -1
ğŸ’¡ [5]                         f <-- 2
ğŸ’¡ [4]                     f <-- 2
ğŸ’¡ [3]                 f <-- 6
ğŸ’¡ [2]             f <-- 30
ğŸ’¡ [1]         f <-- 210
ğŸ’¡ [0]     f <-- 1890
<i>(f 9)</i>  â†’   1890
<i>(untrace 'f)</i>  â†’   #f


<i>(console-log "here" 333)</i>  
javascript console : EchoLisp[0] here  333         sysfun.js (ligne 1037)

<i>(js-eval "window.location.href")</i> â†’ "file:///Users/echolalie/www/glisp/index.html"

<i>(define (f n) (for/sum ((i n)) i))</i>  â†’   f
<i>(f 10)</i>  â†’   45
<i>(time (f 1000000))</i>  â†’   
	499999500000
	773 ;; milli seconds
	
<i>(debug 1)</i> 
<i>(define (f u) (lambda(x) (+ u x)))</i> ;; ğŸ”‘  f is closing the free variable u
  compiled :: (ğŸ”‘ Î» (_u) (Î» (_x) (#+ u _x)))
<i>(f 444)</i>
  compiled :: (f 444)
  â†’ (ğŸ”’ Î» (_x) (#+ u _x)) ;; ğŸ”’ and returns a closure 


<i>(define (f x) (abs (sin( * x PI))))</i> ;; â­•ï¸ = compiled function composition
  compiled :: (Î» (_x) (â­•ï¸ #abs (#sin (#* _x 3.141592653589793))))
<i>(debug 0)</i> ;; finished
</pre>

<h2>Popup boxes</h2>
<h4 id='alert'>(<b>alert </b><i>alert-string</i>) shows alert popup box  â› void</h4>
<h4 id='confirm'>(<b>confirm </b><i>confirm-string</i>) shows confirm popup box  â› #t (OK button) or #f (Cancel button)</h4>

<h2  id="read"> Read operations</h2>
<h3>Read input from stdin</h3>
<h4 id='input-expr'>(<b>input-expr </b><i>proc:1 prompt-string</i>) â†’ (void). Sets the prompt to <i>prompt-string</i>, prepare to parse the next user input line as an expression, and to return (eval (proc expr)). Beware that this is an asynchronous operation. <i>proc</i> is the associated callback procedure.</h4>
<br>
<h4 id='input-string'>(<b>input-string </b><i>proc:1 prompt-string</i>) â†’ (void). Sets the prompt to <i>prompt-string</i>, prepare to read the next user input line as a string, and to return (eval (proc string)). </h4>
<pre>
<i>(define (i-adder list) (cons + list))
(input-expr i-adder "Please, enter a list of numbers")
8 9 6</i>
    â†’ 23

<i>(define (input-number num) 
	(if (number? num) 
		(do-something num) 
		(input-expr input-number "number ???")) (void))
		
(input-expr input-number "Please, enter a number")</i>
</pre>

<h3 id="read-from-string">read-from-string</h3>
<p>(read-from-string input-string) parses <i>input-string</i> and return a symbolic expression. The top level loop may be described as : 
<br>(writeln (eval (read-from-string user-input-line))).</p>
<pre>
<i>(read-from-string "(+ 1 2)")</i>  â†’   (+ 1 2)
<i>(eval (read-from-string "(+ 1 2)"))</i>  â†’   3
</pre>

<h3>read</h3>
<p>(read), (read-string) (read-number) and (read-list) use the browser prompt mechanism. They return #f if the user cancels  the operation.</p>
<h4> (<b>read</b>) â›  expression = number, symbol, list etc.</h4>
<h4 id='read'>(<b>read </b><i>default-value</i>)</h4>
<h4 id='read'>(<b>read </b><i>default-value prompt-string</i>) prompts with prompt-string dialog title, and default value</h4>
<br>
<h4 id='read-string'>(<b>read-string </b><i>[default-value-string [ prompt-string]]</i>) â› returns a string</h4>
<h4 id='read-number'>(<b>read-number </b><i>[default-value-number [ prompt-string]]</i>) â› returns a number</h4>
<h4 id='read-list'>(<b>read-list </b><i>[default-value-string [ prompt-string]]</i>) parses user input :  space or "," separators  -  no "(" , no ")"  needed - â› returns a list</h4>


<pre>
<i>(let ((age (read 32 "Elvis age?"))) 
   (if (number? age) age 
       (error "not a number" age)))</i>  â†’    â€¦

<i>(read-string "gallubert" "your name?")</i>  â†’   user string

<i>(read-list "42 666" "Please, enter two numbers")</i>  â†’  a list
</pre>

<h2 id="write">Write operations</h2>
<p>The write/display operations write to stdout. They all return (void).</p>
<h4 id='decimals'>(<b>decimals </b>) â› get number of shown decimals  ( 0 = default = all)</h4>
<h4 id='decimals'>(<b>decimals </b><i>n</i>) â› set number of shown decimals </h4>
<h4 id='write'>(<b>write </b><i>object<sub>1</sub> ..object<sub>i</sub> ..</i>) â› to stdout, on same line</h4>
<h4 id='writeln'>(<b>writeln </b><i>object<sub>1</sub> ..object<sub>i</sub> ..</i>) â› to stdout, on next line</h4>
<h4 id = "newline">(<b>newline</b>) â› flushes stdout and starts a new line</h4>
<h4 id='display'>(<b>display </b><i>object</i>) â› display format : unquoted strings, etc. </h4>
<h4 id='display'>(<b>display </b><i>object css-style-string</i>) â› styled display</h4>

<pre>
<i>(for ((i 5)) (write i))</i> â†’  0 1 2 3 4
<i>(display 2015 "color:blue;font-size:24px")</i> â†’  
	<span style="color:blue;font-size:24px">2015</span>
<i>(write "Longtemps je me suis couchÃ©")</i> â› "Longtemps je me suis couchÃ©"
<i>(display "de bonne heure.")</i> â› de bonne heure.
</pre>

<h3 id="printf">Formatted print - printf</h3>
<p>The format-string contains a text - pattern- to be filled with arguments values.<br>
It can optionally contain embedded format specifiers that are replaced by val<sub>i</sub> arguments values and formatted as requested. A format specifier follows this prototype: <br>
<center>%[width][.precision]specifier or  ~[width][.precision]specifier</center>
</p>
<p>
The specifiers are the following :
<ul>
<li> s or S : string value</li>
<li> d or D : numeric decimal value</li>
<li> x or X : numeric hexadecimal value</li>
<li> a or A : any type value</li>
<li> n : new line</li>
<li> t : tabulation</li>
<li> % : prints '%'</li>
</ul>
<br>
</p>

<h4 id='format'>(<b>format </b><i>format-string val<sub>1</sub> val<sub>2</sub> ... val<sub>n</sub></i>)  â›  formatted string</h4>
<h4 id='printf'>(<b>printf </b><i>format-string val<sub>1</sub> val<sub>2</sub> ... val<sub>n</sub></i>) prints formatted string and returns void</h4>
<pre>
(printf "percents : %.2d %%" 12.45678)  â†’  percents : 12.46 %
(printf "hexa: %x" PI)  â†’  hexa: 0x3.243f6a8885a3

(printf "~20a ~20a%n~20a ~20a" "simon" "gallubert" "elvis" "presley")  â†’  
               simon            gallubert
               elvis              presley

;; tab width 12. (default is 16)
(printf "digits: %12t%d %t%d %t%d" 5 6 7)  â†’  digits:    5          6          7
</pre>

<h3 id="html-print">HTML formatting</h3>
<h4>(<b>html-print </b><i>html-string</i>) Clears the stdout area, and replaces its contents - innerHTML - with <i>html-string</i> â› void</h4>
<pre>
(html-print "&lt;img src='http://www.quotehd.com/imagequotes/authors5/ludwig-wittgenstein-quote-the-limits-of-my-language-mean-the-limits.jpg'
height = 400&gt;")

<img src='./images/ludwig-limits.jpg' height=400 width=400>

(lib 'sql)
	(html-print (table->html my-table))
</pre>

<h3 id="pretty-print">Pretty printing</h3>
<p>Requires the <b>print</b> library. Remember that also exist <a href="#array-print">array-print</a> and <a href="#table-print">table-print</a> in matrix.lib and sql.lib</a>.
<h4>(<b>pretty-print </b><i>expression  [max-line-length]</i>) Evaluates <i>expression</i> and pretty prints the result â› void. <small>Default <i>max-line-length</i> is 140. All sub-expressions which fit on a line are not indented.</small></h4>
<h4>(<b>pp </b><i>expression</i>) Synonym for pretty-print</h4>
<pre>
(lib 'print)

<i>(define V (make-vector 3 (make-vector 2 (iota 8))))
(pp V 80)</i>
#( #( { 0 1 2 3 4 5 6 7 } { 0 1 2 3 4 5 6 7 })
     #( { 0 1 2 3 4 5 6 7 } { 0 1 2 3 4 5 6 7 })
     #( { 0 1 2 3 4 5 6 7 } { 0 1 2 3 4 5 6 7 }))
     
<small>
<i>(define (add-level node chain  target  nums (new))
"add nodes in Knuth's power tree"
(vector-push chain (node-datum node))
(cond [(node-leaf? node)(for [(prev chain)] (set! new (+ prev (node-datum node)))(when (= new target) (power-hit target chain ))#:continue (vector-search* new nums)(node-add-leaf node new)(vector-insert* nums new))][else (for [(son  (node-sons node))](add-level son chain target nums )) ])(vector-pop chain))</i>
	
<i>(pp add-level)</i>
( add-level (_node _chain _target _nums _new)
     "add nodes in Knuth's power tree" 
     (#vector-push _chain (node-datum _node))
     ( #cond
          ( (node-leaf? _node)
                    ( #for ((prev _chain))
                         (#set! _new (#+ prev (node-datum _node)))
                         (#when (#= _new _target) (power-hit _target _chain))
                              #:continue (#vector-search* _new _nums)
                         (node-add-leaf _node _new)
                         (#vector-insert* _nums _new)) )
          (else (#for ((son (node-sons _node))) (add-level son _chain _target _nums))))
     (#vector-pop _chain))
</small>
</pre>


<h2 id = "io">Input/output</h2>
<h3 id = "stdin">stdin - Input from keyboard</h3>
<h4 id='autocomplete-delay'>(<b>autocomplete-delay </b><i>0</i>) â› cancel autocomplete</h4>
<h4 id='autocomplete-delay'>(<b>autocomplete-delay </b><i>msec</i>) â› set delay - default = 40</h4>

<h3 id = "meta">stdin - Meta keys</h3>
<p>The use of meta keys allows to map  a key-press: modifier+letter or modifier+digit to a string which will be inserted at the cursor position.<br>
The modifier is one of ["alt"|"ctrl"|"cmd"], as known by the browser. Use "alt" for "option".
</p>
<h4>(<b>define-modifier-key</b> ["alt"|"ctrl"|"cmd"|null])  â› sets the modifier to use; null if no meta keys (this is the default).</h4>
<h4>(<b>meta-key</b> [1-letter-string|1-digit-string] [replace-string|null])  â› sets the mapping for letter or digit.</h4>
<h4>(<b>meta-keys</b>) â› return the current mapping.

<pre>
;; shows the default mapping : GREEK ALPHABET
<i>(meta-keys)</i> â†’ 
Modifier: null
(("0" "âŒ") ("1" "â—ï¸") ("2" "â“") ("3" "âœ”ï¸") ("4" "â›”ï¸") ("5" "âœ…") ("6" "ğŸš©") ("7" "âŒšï¸") ("8" "ğŸ") ("9" "ğŸ˜œ") ("a" "Î±") ("b" "Î²") ("g" "Î³") ("d" "Î´") ("e" "Îµ") ("z" "Î¶") ("h" "Î·") ("t" "Ï„") ("i" "Î¹") ("k" "Îº") ("l" "Î»") ("m" "Î¼") ("n" "Î½") ("x" "Î¾") ("q" "Î¿") ("p" "Ï€") ("r" "Ï") ("w" "Ï‚") ("s" "Ïƒ") ("u" "Ï…") ("f" "Ï†") ("c" "Ï‡") ("y" "Ïˆ") ("o" "Ï‰") ("A" "Î‘") ("B" "Î’") ("G" "Î“") ("D" "Î”") ("E" "Î•") ("Z" "Î–") ("H" "Î—") ("T" "Î¤") ("I" "Î™") ("K" "Îš") ("L" "Î›") ("M" "Îœ") ("N" "Î") ("X" "Î") ("Q" "ÎŸ") ("P" "Î ") ("R" "Î¡") ("S" "Î£") ("U" "Î¥") ("F" "Î¦") ("C" "Î§") ("Y" "Î¨") ("O" "Î©"))

;; use the Control key as modifier
<i>(define-modifier-key "ctrl")</i>
;; typed:    ctrl-P,ctrl-A, etc...
    â†’  Î¦Î‘Î¡Î©Î£

<i>(meta-key "A" "Antoinette")
(meta-key "d" "(define "))</i>

;; typed: ctrl-d, ctrl-A , 0 ,  ")"
  â†’  (define Antoinette 0)
  
<i>(meta-key "d" "(date->date-string (current-date))")</i>
;; typed : ctrl-d + Enter
  â†’ "26/8/2015"
</pre>




<h3 id="stdout">Customizing a cell input/output fields : stdin/stdout</h3>
<h4 id = "stdin-hide">(<b>stdin-hide</b> [#t|#f]) â†’  hides/shows stdin</h4>
<h4 id='stdin-background'>(<b>stdin-background </b><i>color-string</i>) â› set stdin background color</h4>
<h4 id='stdin-color'>(<b>stdin-color </b><i>color-string</i>) â› set stdin text color</h4>
<h4 id='stdin-font'>(<b>stdin-font </b>) â› get stdin text font (default "Verdana")</h4>
<h4 id='stdin-font'>(<b>stdin-font </b><i> font-id-string</i>) â› set stdin text font</h4>
<h4 id='stdin-font-size'>(<b>stdin-font-size </b>) â› get stdin text size in px units (default around "12px")</h4>
<h4 id='stdin-font-size'>(<b>stdin-font-size </b><i>size-number</i>) â› set stdin text size in px units. <small>Numeric value, without "px".</small></h4>
<br>
<h4 id = "stdout-hide">(<b>stdout-hide</b> [#t|#f]) â†’  hides/shows stdout</h4>
<h4 id='stdout-clear'>(<b>stdout-clear </b>) â› clears stdout and returns (void)</h4>
<h4 id='stdout-background'>(<b>stdout-background </b><i>color-string</i>) â› set stdout background color</h4>
<h4 id='stdout-color'>(<b>stdout-color </b><i>color-string</i>) â› set stdout text color</h4>
<h4 id='stdout-font'>(<b>stdout-font </b>) â› get stdout text font (default "Verdana")</h4>
<h4 id='stdout-font'>(<b>stdout-font </b><i> font-id-string</i>) â› set stdout text font</h4>
<h4 id='stdout-font-size'>(<b>stdout-font-size </b>) â› get stdout text size in px units (default around "12px")</h4>
<h4 id='stdout-font-size'>(<b>stdout-font-size </b><i>size-number</i>) â› set stdout text size in px units</h4>

<pre>
<i>(stdin-color "magenta")</i>
<i>(stdout-color "#8866dd")</i>
<i>(stdout-font)</i>  â†’   "Lucida Sans Typewriter,Verdana,Arial,Helvetica,sans-serif"
<i>(stdout-font "Monospace")</i> ;; useful for tabulated output
<i>(stdout-font-size 18)</i>

<i>(define (preferences)
	(stdout-font "Monospace")
	(stdin-font-size 16))</i>
</pre>


<h2 id = "load">Local files and server files access</h2>
<p>Files are loaded <u>asynchronously</u>. Server default location : the source file names located on the server are in the ".lib" directory, suffixed by ".glisp". For local file loading - use full path - or the <span style="border:1px solid black">&nbsp;Load&nbsp;</span> button.
<br>
<small>The default file path may be changed using the *home* global variable. E.g. (set! *home*  "file:///Users/echolalie/www/glisp/lib/") </small></p>

<h4 id='load'>(<b>load </b>) â› read and eval local file selected using the browser file dialog. Same as click on the <span style="border: 1px solid green">&nbsp;Load&nbsp;</span> button.
<h4 id='load'>(<b>load </b><i>filename</i>) â› read and eval file <i>./lib/filename.glisp</i> located on server.
<pre>
<i>(load 'combinations)</i>
<span style = "color:green">Loaded : ./lib/combinations.glisp</span>
<span syle=color:green">usage: (define mylist ... ) (comb-next mylist p)</span>

(load "foo.txt")
<span style = "color:red">[404] Cannot load : ./lib/foo.txt</span>
(load 'curves)
(load 'todo)

<small>The following will work if EchoLisp is locally installed.
(load "file:///Users/echolalie/www/glisp/lib/calc.glisp")</small>

<small>You can load cross-domains files by disabling the browser security.
For Chrome/Mac OS, run the following command :
/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --disable-web-security</small>
<small>
<b>The <a href = "https://addons.mozilla.org/fr/firefox/addon/cors-everywhere/">cors-everywhere</a> Mozilla add-on allows to bypass cross-domain checking under Firefox.</b></small>
</pre>

<h3 id = "file->string">File to string</h4>
<p>Converts a local file or URL to a string. The file contents is displayed in a new cell.</p>
<h4 id='file->string'>(<b>file->string </b><i>success-proc</i>) â› read as text a local file selected using the browser file dialog, and calls (<i>success-proc</i> file-name text)</i>.
<h4 id='file->string'>(<b>file->string </b><i>success-proc file-name</i>) â› read as text a file located on server, and calls (<i>success-proc</i> file-name text).

<pre>
(define (success file-name text) (writeln 'OK file-name text ))
(file->string success)  â†’ #t ;; browser file selection dialog
	<span style="color:green">T1.txt -> string</span>
	OK     "T1.txt"     "What is it?"     
	
;; with cors-everywhere active
(file->string success "http://www.google.com")
</pre>

<h3 id = "save-as">Saving on disk</h4>
<p><b>save-as</b> uses the browser download mechanism to save the printed - text - representation of an object into a file located in the browser download disrectory. <i>Filename</i> must have the extensions .txt (default) or .htm, .html. According to the browser, successive occurences ot the same file will be labelled filename(1), filename(2), etc.
</p>
<h4 id = 'save-as'>(<b>save-as</b> <i>object filename</i>) â› #t or #f


<h2 id = 'local'> ğŸ“— Local storage - Local database </h2>
<p>The local database persistently store and retrieve values (lisp objects) or functions definitions (strings) inside the browser's local storage.
<br>The local data base is organized into named stores, each store remembering pairs of (symbol value). The starting stores are 'user' - which is the default - , 'system', 'noteboook, 'reader' and 'words'. The user can add/delete stores and their contents.
<br>A qualified symbol/function name <i>store-name.symbol-name</i> denotes a symbol in store <i>store-name</i>. The default store is "user".


<h4 id='local-verbose'>(<b>local-verbose </b>[#t|#f]) -> messages on|off</h4>
<h4 id='local-stores'>(<b>local-stores </b>[<i>filter</i>]) -> list of names of local stores, possibly filtered by the <i>filter</i> string</h4>
<h4 id='local-make-store'>(<b>local-make-store </b><i>store</i>) -> new store <i>store</i></h4>
<h4 id='local-delete-store!'>(<b>local-delete-store! </b><i>store</i>) -> delete store and contents and keys</h4>
<h4 id='local-keys'>(<b>local-keys </b><i>[store]</i>) -> list of all keys in <i>store</i>. Default store is "user"</h4>

<pre>
<i>(local-stores)</i>  â†’   ("system" "user" "words" "reader" "test" "foo" "gee" "books")
<i>(local-stores "o")</i> â†’ ("words" "books"  "foo")
<i>(local-delete-store! 'foo)</i>  â†’   "foo"
<i>(local-delete-store! 'user)</i>  â†’   #f
ğŸ“™ local-db: Cannot delete: user
<i>(local-make-store 'french)</i>  â†’   "french"
</pre>

<h3 id='local-store'>Local stores - Symbols value access</h3>
<p>Symbols bindings and procedure definitions - strings - may be stored/retrieved into/from a local store. In the following, <i>symbol</i> is the name of a bound symbol, or of a prodedure.</p>

<h4 id='local-symbol?'>(<b>local-symbol? </b><i>[store.]symbol</i>) -> is  symbol <i>symbol</i> stored in <i>store-id</i> ? #t or #f</h4>
<h4 id='local-put'>(<b>local-put </b><i>[store.]symbol</i>) -> saves - replaces -  <i>symbol</i> binding into <i>store</i>. </h4>
<h4 id='local-add'>(<b>local-add </b><i>[store.]symbol</i>) -> saves <i>symbol</i> binding into <i>store</i>. Error if <i>symbol</i> already known. </h4>
<h4 id='local-get'>(<b>local-get </b><i>[store.]symbol</i>) -> retrieves and returns value - null if none found - and bind it to <i>symbol</i>.</h4>

<pre>
;; working in "user" store
<i>(define friends '( elvis ludwig broderick))</i>  â†’   friends
<i>(local-put 'friends)</i>  â†’   friends
<i>(define friends null)</i>
<i>(local-get 'friends)</i>  â†’   (elvis ludwig broderick) 
<i>friends</i>  â†’   (elvis ludwig broderick) ;; new binding
<i>(local-keys )</i>  â†’   ( "*meteo*" "*todo*" "aalert" "alert" <mark>"friends"</mark> "pi" "preferences" "xalert")
<i>(local-symbol? 'friends)</i>  â†’   #t

;; working in "french" store
<i>(define french.friends '(albert (antoinette ornella) simon))</i>  â†’   french.friends
<i>(local-put 'french.friends)</i>  â†’   french.friends
<i>(local-keys 'french)</i>  â†’   (<mark>"friends"</mark>)
<i>(define french.friends 333)</i>
<i>(local-get 'french.friends)</i>  â†’   (albert (antoinette ornella) simon)
<i>french.friends</i>  â†’   (albert (antoinette ornella) simon) ;; new binding

<i>(local-get 'foo)</i>  â†’   null
<span style="color:red">ğŸ“• local-db: Undefined key : "user.foo"</span>

</pre>

<h3 id='key-value'>Local stores - (key value) access</h3>
<p>Local stores may be used for (key value) access. Keys are either user defined or are integer numbers automatically generated and incremented.<br>
In the following, <i>key</i> is either a symbol name, string, number - user key -, or one of 0, 'auto, #:auto which all mean auto-increment.
</p>
<h4 id='local-add-value'>(<b>local-add-value </b><i>key value [store]</i>) -> adds new (key value) in store. Error if key already exitsts. Returns key (user or auto-incremented)</h4>
<h4 id='local-put-value'>(<b>local-put-value </b><i>key value [store]</i>) -> adds/replaces (key value) in store. Returns key (user or auto-incremented)</h4>
<h4 id='local-get-value'>(<b>local-get-value </b><i>key [store]</i>) ->retrieves value for key. Returns null if unknown key</h4>
<h4 id='local-delete'>(<b>local-delete </b><i>key store</i>) -> deletes (key value) from store. No default value for store.</h4>

<pre>
;; The books data base
;; First, we need to create the books store
<i>(local-make-store 'books)</i>  â†’   "books"

;; Book structure definition
;; Store it, with key "book-record"
<i>(define book-record (struct book (name title date)))</i>  â†’   book-record
<i>(local-put-value 'book-record book-record 'books)</i>  â†’   "book-record"

;; Add a few books. Use auto-increment keys
<i>(local-put-value #:auto (book 'ludwig 'tractatus 1918) 'books)</i>  â†’   1
<i>(local-delete 1 'books)</i>  â†’   #t
<i>(local-put-value #:auto (book 'Wittgenstein 'Tractatus 1918) 'books)</i>  â†’   2
<i>(local-put-value #:auto (book 'McCarthy 'Lisp 1960) 'books)</i>  â†’   3

;; inspect all keys in store
<i>(local-keys 'books)</i>  â†’   (2 3 "book-record")

;;; A few days later ...
;; Important to get the structure back
<i>(local-get-value 'book-record 'books)</i>   â†’ #struct:book [name title date]
<i>(book-name (local-get-value 2 'books))</i>  â†’ Wittgenstein
<i>(book-title (local-get-value 3 'books))</i> â†’ Lisp

<i>(local-verbose #t)</i> â†’ #t
<i>(local-get-value 42 'books)</i>
<span style="color:red">ğŸ“• local-db: Undefined key : "books.42"</span>  â†’ null
</pre>




<h2 id = "packages"> ğŸ“— Local storage - Definitions - Packages</h2>
<p>The user defined <b>preferences</b> function is automatically evaluated at boot time, and automatically saved in the 'user' package.</p>

<br>
<h4 id='preferences'>(<b>define </b><i>(preferences) â€¦</i>) ;; user preferences function</h4>
<br>
<h4 id = "definitions">(<b>definitions</b>) -> lists all functions definitions in memory, as strings</h4>
<h4 id='undefine'>(<b>undefine </b><i>function-symb</i>) -> reset definition</h4>
<h4 id='edit'>(<b>edit </b><i>function-symb</i>) -> writes the definition to a new cell for editing</h4>
<br>
<h4 id='save-package'>(<b>save-package </b><i>store</i>) -> saves all symbols/functions definitions named <i>store.name</i> into <i>store</i>. Returns list of symbols or functions names. (*) </h4>
<h4 id='load-package'>(<b>load-package </b><i>store</i>) -> loads the whole store into memory; Returns list of symbols or function names. (*) </h4>
<p><small>(*)store may not be one of : system, user, reader, or words.</small></p>

<pre>
<i> (define (preferences) 
	(stdout-font-size 14)
	(lib 'struct)
	(lib 'plot))</i> ;; a preferences function
	

;; our package for f(x) = ax<sup>2</sup> + bx + c polynomials

<i>(define (quad.roots a b c) ;; returns 2 roots 
	(let* [(a (* 2 a)) 
		  (delta (/ (sqrt (- (* b b) (* 2 a c))) a)) 
		  (b (- (/ b a)))] 
		  	(list (+ b delta ) (- b delta))))</i>  â†’   quad.roots
<i>(quad.roots 1 0 1)</i>  â†’   (0+i 0-i)
<i>(quad.roots 1 0 -1)</i>  â†’   (1 -1)

<i>(define (quad.value x a b c) (+ (* a x x) (* b x) c))</i>  â†’   value at x

<i>(define (quad.plot a b c xmin)</i> ;; plot ax<sup>2</sup> + bx + c 
	<i>(let ((f (lambda(x) (+ ( * a x x) ( * b x) c )))) 
	(plot f xmin )
	(plot-grid 1 1)
	(plot-axis 0 0 'red)))</i>  
	
<i>(define quad.errmess  "not quadratic (a = 0)")</i>

;;Look for definitions in memory
<i>(definitions)</i><span style="color:green">
  preferences : (define (preferences) (lib 'timer) (lib 'struct))
  quad.roots : (define (quad.roots a b c) ;; returns 2 roots [...])
  quad.value : (define (quad.value x a b c) (+ (* a x x) (* b x) c))
  quad.plot : (define (quad.plot a b c xmin) ;; plot ax<sup>2</sup> + bx + c [...])</span>

;; saving the quad.* symbols and functions
<i>(save-package 'quad)</i>  â†’   (quad.roots quad.value quad.plot quad.errmess)

;; loading and using the package
<i>(load-package 'quad)</i>
	â†’ (quad.plot quad.errmess quad.value quad.roots)
<i>(quad.roots 3 -2 -1)</i>  â†’ (1 -1/3)
<i>(quad.plot 3 -2 -1 -2)</i>  â†’   
<img src = "./images/plot-quad.png" width = "300" height="300">

;; Editing a function
<i>(edit 'quad.roots)</i>
 (define (quad.roots a b c) 
  <mark>(when (= a 0) (error quad.errmess 0))</mark> ;; added
 	 (let* â€¦)))
 <i>(save-package 'quad)</i>
</pre>

<h2 id="reader">Lisp reader</h2>
<h4 id='reader-set-prompt!'>(<b>reader-set-prompt! </b><i>[symbol|string]</i>)  â†’ sets a new prompt text for the input field.
<p>A <i>reader-procedure</i> pre-processes the raw list of symbols, strings, lists ... emitted by the lisp reader, before any evaluation. If takes in input a list of one or more tokens, and must return a list of one or more expressions to be evaluated. The reader-procedure is removed when it returns (#f) .
<br>See, or load <a href="./lib/calc.glisp">calc.glisp</a> for an example of use : a calculator in infix notation.
</p>

<h4 id='reader-set-proc!'>(<b>reader-set-proc! </b><i>reader-procedure prompt-string</i>)  â†’  installs a new reader procedure, with <i>prompt-string</i> as placeholder</h4>
<h4 id="reader-rem-proc">(<b>reader-rem-proc</b>)  â†’  reverts to the last reader procedure - standard reader if none -</h4>

<small>
<p>The reader translation table allows to translate <u>characters or strings</u> at read time. Use (reader-translate old-string null) to reset an entry in the table.</p>
<h4 id='reader-translate'>(<b>reader-translate </b><i>old-string new-string</i>)  â†’  old string - which may be a regular expression - is replaced by new-string everywhere in the input stream</h4>
<pre>
<i>(reader-translate "," " ")</i> ;; ignore commas
<i>'[ a, b, c]</i>  â†’  (a b c)</i>
<i>(reader-translate "," null)</i> ;; revert to normal processing
</pre>
</small>

<small>
<p>The reader dictionary, an associative list of (key value), allows to translate <u>symbols names</u> at read time. Keys and values must be strings.</p>
<h4 id='reader-dict-new'>(<b>reader-dict-new </b><i>key-value-list</i>)  â†’  new reader dictionary from list of (key value)</h4>
<h4 id='reader-dict-set!'>(<b>reader-dict-set! </b><i>key value</i>)  â†’  adds an entry to the dictionary</h4>
<h4 id='reader-dict-set!'>(<b>reader-dict-set! </b> <i>key</i> #f)  â†’  removes entry from the  dictionary</h4>
<h4 id  ="reader-dict">(<b>reader-dict</b>)  â†’  current reader dictionnary</h4>
<h4 id='load-reader-dict'>(<b>load-reader-dict </b><i>dict-id</i>)  â†’  load from local storage</h4>
<h4 id='save-reader-dict'>(<b>save-reader-dict </b><i>dict-id</i>)  â†’  saves the dictionary into local storage</h4>
</small>

<pre>
<i>(load 'calc)</i>
(calc) â†’ #t ;; installs the reader proc to eval infix notation
The new prompt : <span style="color:gray">Calc expression here - $ to quit -</span>
1 + cos(PI) â†’ 0
prime? (101) â†’  1 ;; YES
$  â†’  calc:quit ;; un-installs

;; changing the prompt 
<i>(reader-set-prompt!  "My own personal prompt")</i>

;; ğŸ’£ Careful here ğŸ’£
<i>(reader-dict-new ' (("PERFORM" "apply")))
(PERFORM + (iota 11))</i> â†’ 55
</pre>

<p>Text can be parsed - exploded into a list of strings - either using the default separators :  <span style="color:green">()+-.;;,?!'"</span> , or by providing a string of separators. Spaces,tab and newline are always separators.</p>
<h4 id='text-parse'>(<b>text-parse</b> <i>text-string</i>)  â†’  list of strings. <small>The separators are included in the list, as 1-character strings.</small></h4>
<h4 id='text-parse'>(<b>text-parse</b> <i>text-string separators</i>)  â†’  list of strings</h4>

<pre>
<i>(define mytext "Longtemps, je me suis couchÃ© de bonn'heur; A peine ma bougie Ã©teinte, je m'endormais!!.")</i>

<i>(text-parse mytext)</i>
   â†’ ("Longtemps" "," "je" "me" "suis" "couchÃ©" "de" "bonn" "'" "heur" ";" "A" "peine" "ma" "bougie" "Ã©teinte" "," "je" "m" "'" "endormais" "!" "!" ".")
   
<i>(text-parse mytext ";,")</i>
   â†’ ("Longtemps" "," "je" "me" "suis" "couchÃ©" "de" "bonn'heur" ";" "A" "peine" "ma" "bougie" "Ã©teinte" "," "je" "m'endormais!!.")
</pre>


<h2 id = "quoting">Quoting</h2>
<p>â€œBackquoteâ€ or â€œquasiquoteâ€ expressions are useful for constructing a list structure when most but not all of the desired structure is known in advance.</p>
<h4 id='quote'>(<b>quote </b><i>object</i>) -> object</h4>
<h4 id='quasiquote'>(<b>quasiquote </b><i>template</i>) -> template, with unquote/unquote-splicing evaluated. Other items are "quoted" : unchanged.</h4>
<h4 id ="unquote">(<b>unquote</b> <i>object</i>) -> evaluates inside a template</h4>
<h4 id='unquote-splicing'>(<b>unquote-splicing </b><i>object</i>) -> object must evaluates to a list. The list contents are inserted - ( and ) "stripped" away- inside the template.</h4>

<pre>
<i>(define boys '(elvis simon albert))</i>  â†’   boys
<i>(define girls '(antoinette ornella))</i>  â†’   girls

<i>(quote boys)</i>  â†’   boys
<i>(quasiquote girls)</i>  â†’   girls

<i>(quasiquote ( boys girls))</i>  â†’   (boys girls)
<i>(quasiquote ( family boys (unquote girls)))</i>  â†’   (family boys (antoinette ornella))
<i>(quasiquote (family boys (unquote-splicing girls)))</i>  â†’   (family boys antoinette ornella)
</pre>
<h4><b>macro-characters</b></h4>
<ul>
<li>&nbsp;'<i>object</i> is identical to (quote <i>object</i>)</li>
<li>&nbsp;`<i>template</i> is identical to (quasiquote <i>template</i>)</li>
<li>&nbsp;,<i>object</i> is identical to (unquote <i>object</i>)</li>
<li>&nbsp;,@<i>object</i> is identical to (unquote-splicing <i>object</i>)</li>
</ul>

<pre>
<i>''ludwig</i>  â†’  'ludwig
<i> `(list ,(+ 1 2) 4) </i>  â†’   (list 3 4)

<i>'(boys girls)</i>  â†’   (boys girls)
<i>`(boys girls)</i>  â†’   (boys girls)

<i>`( boys ,@boys girls girls (+ 2 2))</i> â†’  
ğŸ’¡ expands:     (#quasiquote (boys (#unquote-splicing boys) girls girls (+ 2 2)))
 		  â†’  (boys elvis simon albert girls girls (+ 2 2))
 		
<i>`( boys ,boys girls ,girls ,(+ 2 2))</i>  â†’   (boys (elvis simon albert) girls (antoinette ornella) 4)
<i>`( boys ,@boys girls ,@girls ,(+ 2 2))</i>  â†’   (boys elvis simon albert girls antoinette ornella 4)

<i>(let ((name 'elvis)) `(list ,name ',name))</i>   â†’   (list elvis 'elvis)

<i>(list 1 2 ,3 4)</i>
	<span style="color:red">ğŸ˜–ï¸ error: unquote : misplaced ',' : 3</span>
</pre>


<h2 id="syntax">Syntax rules</h2>
<p>The syntax rules allow macro transformations from <i>patterns</i> to <i>templates</i>, before top-level evaluation. The syntax rules apply only to function calls. They perform hygienic transformations,  i.e. local - let - variables are internally renamed, in order to prevent names clashes.<br>
A clause is a couple (pattern template), pattern is a list which begins by an identifier. A pattern may only match lists which begin with the same identifier.
</p>
<h4 id='define-syntax-rule'>(<b>define-syntax-rule </b><i>pattern template</i>)  â†’  Transforms <i>pattern</i> according to <i>template</i> if a match is found..</h4>
<br>
<h4 id='define-syntax'>(<b>define-syntax </b><i>function-id</i> (syntax-rules <i>keywords-list clause<sub>1</sub> ... clause<sub>n</sub></i>))  â†’ 
<br> If a match is found between a call (function-id args ..) with a clause (<i>pattern<sub>i</sub></i> <i>template<sub>i</sub></i>), transforms the call according to <i>template<sub>i</sub></i>. Else raises an error.</h4>

<pre>
;; We miss the ++ operator
<i>(define-syntax-rule (++ n) (set! n (1+ n)))</i>  â†’   ++
;; this rule will match expressions beginning with ++
;; n, inside template, will be replaced by the corresponding symbol inside the matching expression.

<i>(define my-number 665)</i>  
<i>(++  my-number)</i> 
<i>my-number</i>  â†’   666

<i>(debug 2)</i> ;; to see the expansion
<i>(++ my-number)</i>
syntax :: ( set! my-number (1+ my-number))
<i>my-number</i>  â†’   667
<i>(debug 0)</i> ;; stops seeing

<i>(define-syntax-rule (swap x y)  
   (let ([tmp x]) (set! x y) (set! y tmp)))</i>

<i>(define simon 'gallubert)</i>
<i>(define antoinette 'de-gabolde)</i>
<i>(swap simon antoinette)</i>
<i>simon</i>  â†’  de-gabolde
<i>antoinette</i> â†’  gallubert

;; hygienic macro
;; <i>tmp</i> inside the swap macro is replaced by the anonymous <i>#:tmp_1</i>
<i>(let ([tmp 42] [other 666]) (swap tmp other) (list tmp other))</i>
;; syntax expansion ::
	(let ((tmp 42) (other 666))
          (ğŸ“Œ let ((#:tmp_1 tmp)) (set! tmp other) (set! other #:tmp_1)) 
          (list tmp other))
;; result
    â†’ (666 42)
    
;; We miss the Common Lisp <mark>defun</mark>
<i>(define-syntax-rule 
	(defun foo (params ...) expr ...) 
	(define ( foo params ... ) expr ...))
	
	(defun gee ( a b) (+ a b) (* a b)) </i>
	syntax expansion :: (ğŸ“ define (gee a b) (+ a b) (* a b))
	<i>(gee 6 7)</i>  â†’ 42

;; let's improve the ++ operator : 0 ,1 or n increments
<i>(define-syntax ++ 
	(syntax-rules () 
		((++ a)(set! a (1+ a))) 
		((++ a n)(set! a (+ a n))) 
		((++ a n ...)(set! a (+ a n ... )))))</i>
		
(++ my-number 100 200 300) â†’   1267

(++)  â†’ <span style="color:red">ğŸ’¥ error: syntax-rules : no match pattern : (++)</span>
</pre>

<h3 id='syntax-id'>Syntax-id rules</h3>
<p>Syntax rules allow to transform lists into lists. Syntax-id rules allow to transform identifiers - symbols - into lists.</p>
<h4 id='syntax-ids'>(<b>syntax-ids</b>) â†’ list of all known sysntax-id identifiers.</h4>
<br>
<h4 id='define-syntax-id'>(<b>define-syntax-id</b> <i>id expr</i>) The symbol <i>id</i> is replaced by <i>expr</i>. <small>(define-syntax-id id null) to remove a definition</small></h4>
<p>Dot notation : pattern matching and replacement occur when the pattern id is _.suffix or prefix._</p>
<h4 id='define-syntax-id'>(<b>define-syntax-id</b> <i>_.suffix expr</i>) Matches any symbol with id = some-prefix.<i>suffix</i> . The placeholder _ will be replaced by the symbol prefix inside the template. </h4>
<h4 id='dalida'>(<b>define-syntax-id</b> <i>prefix._ expr</i>) Matches any symbol with id = <i>prefix</i>.some-suffix . The placeholder _ will be replaced by the symbol suffix inside the template.</h4>

<pre>
<i>(define-syntax-id a.bump (begin (set! a (1+ a)) a))
(define a 42)
a.bump </i> â†’ 43
<i>(+ a.bump a.bump)</i> â†’ 89
<i>a</i> â†’ 45

;; more general
<i>(define-syntax-id <mark>_.bump</mark> (begin (set! _ (1+ _)) _))
(define beast 666)
beast.bump</i>
beast â†’ 667

ğŸ’¡ğŸ’¡ğŸ’¡ <i>' somethig.bump</i> ;; quoted, to see the expansion
    â†’ (begin (set! somethig (1+ somethig)) somethig)

<i>(define-syntax-id <mark>show._</mark> (writeln '_ 'is _))
show.beast</i>
	beast     is     667    
	
;; with <a href="#struct.lib">structures</a>
<i>(lib 'struct)
(struct singer (name hit))
(define dalida (singer 'Dalida "Mourir sur scÃ¨ne"))
(define-syntax-id _.hit (struct-get _ #:singer.hit)) ;; or (struct-get _ 1)

dalida.hit</i>
    â†’ Mourir sur scÃ¨ne
</pre>

<h2 id = "lib">Libraries</h2>
<p>A library - located on the server -  is a javascript extension, bringing new native functions.  The following describes all functions in each library. Libraries names may be written without the ".lib" suffix. Is is good practice to load the needed libraries at the beginning of the session, may be in the (<a href="#packages">preferences</a>) function.</p>
<h4 id='lib'>(<b>lib </b><i>library</i>)  â†’  loads library from server</h4>
<h4 id='require'>(<b>require </b><i>library</i>|<i>(library<sub>0</sub> ...)</i>)  takes a name or a list of names in input;  â†’  raises an error if library not loaded</h4>
<h4 id='lib-functions'>(<b>lib-functions </b><i>library</i>)  â†’  all functions in library</h4>

<pre>
<i>(require 'math)</i>
	ğŸ’¥ error: require : missing lib : math.lib
<i>(lib 'math.lib)</i>
 Lib: math.lib loaded.
<i>(lib 'math)</i>
 Lib: math.lib already here.

<i>(lib-functions 'math)</i>  â†’   #(cpoly croot cserie deriv fractal g-iterate integrate math-precision normal nth-prime poly poly->string poly-add poly-mul poly-mul-k poly-pow primes-pi root serie standard-normal )
</pre>


    
<h2 id="struct.lib">Struct.lib - Structures</h2>
<p>Structures objects generate instances of structures, which are vector-like objects with named fields or slots. Structures can inherit fields from  super structures. Access functions are generated for each field; the field values may be any lisp object. A list of structures instances may be saved/restored into/from local storage. See <a href="./lib/todo.glisp">todo.glisp</a> for an example of use. See <a href="http://rosettacode.org/wiki/Object_serialization">Rosetta</a> code for saving/restoring self-referencing structures.
<br>
In the following, &lt;struct&gt; is to be replaced by the name of a newly defined structure.
</p>
<h4>(lib 'struct.lib) â› loads the struct library</h4><br>
<p>Fields have a name, an optional initial value - 0 is the default - and may have options. A field descriptor may be :
<ul>
<li>field-name</li>
<li>(field-name initial-value)</li>
<li>(field-name initial-value #:onchange change-proc:3)</li>
</ul>
<p><i>change-proc</i> is a user defined procedure which must return a new value for a field. It may be used to check and/or change the targeted field value. It is triggered by a call to a set-<struct>-<field-name>! procedure and has the following signature :
<center>
<h4 id='change-proc'>  âœ’ï¸ (define (change-proc instance old-value tentative-new-value) <i>body</i>)</h4>
</center>
</p>

<h4 id='struct'>(<b>struct </b> <i>&lt;struct&gt;  [super] (field-desc â€¦</i>) [options ...]) Defines a new structure with name '&lt;struct&gt;'. Binds the descriptor symbol struct:&lt;struct&gt; to this structure, and generates the following creation and access functions : </h4>

<br>
<pre>
<h4 id='struct'>(<b>&lt;struct&gt; </b><i>field-value â€¦</i>) constructor â› new instance of &lt;struct&gt;. <small>If the structure has n fields, one can provide only the first m < n first values.</small> </h4>
<h4 id='struct'>(<b>list->&lt;struct&gt; </b><i>list-of-field-values</i>) â› new instance of &lt;struct&gt;</h4>
<h4 id='struct'>(<b>&lt;struct&gt;? </b><i>obj</i>) â› Is obj an instance of &lt;struct&gt; ?  #t or #f </h4>
<h4 id='struct'>(<b>&lt;struct&gt;-field-name </b><i>instance</i>) â› getters for each field are generated.</h4>
<h4 id='struct'>(<b>set-&lt;struct&gt;-field-name! </b><i>instance value</i>) â› setters for each field are generated.</h4>
</pre>
<p>
Options :
</p>
<h4 id='struct'>(<b>struct </b><i>&lt;struct&gt; super-struct (field-desc<sub>0</sub> â€¦ field-desc<sub>n-1</sub></i>)) â› new structure &lt;struct&gt; which inherits of super-struct fields. <small>If super-struct has m fields, generates a structure with m + n fields.</small></h4>
<br>
<h4 id='struct'>(<b>struct </b><i>&lt;struct&gt; (field-name â€¦.) <mark>#:initialize </mark>init-proc:1)</i></h4>
<p><i>init-proc</i> is a user defined procedure which will be called by the constructor at the end of the instance creation.. It may be used to check and/or sets fields values. It has the following signature : </p>
<center>
<h4 id='init-proc'>  âœ’ï¸ (define (init-proc &lt;struct&gt;:instance) <i>body</i>)</h4>
</center>
<br>
<br>
<h4 id='struct'>(<b>struct </b><i>&lt;struct&gt; (field-name â€¦.) <mark>#:tostring</mark> string-proc)</i></h4>
<p><i>string-proc</i> is a user defined procedure which overrides the default structure.tostring procedure. It returns an expression which will be converted to string by the output writer. Signature: </p>
<center>
<h4 id='string-proc'> âœ’ï¸ (define (string-proc &lt;struct&gt;:instance) <i>body</i>)</h4>
</center>

<pre>
;; simple structure definition
<i>(struct animal (legs eyes))</i>  

<i>struct:animal</i>
   â†’ #struct:animal [legs eyes]

<i>(define fifi (animal))</i>  â†’   fifi ;; constructor
<i>fifi</i>  â†’   #&lt;animal&gt; (0 0)
<i>(animal-legs fifi)</i>  â†’   0  ;; getter
<i>(set-animal-legs! fifi 4)</i>  â†’   4  ;; setter
<i>fifi</i>  â†’   #&lt;animal&gt; (4 0)

;; initialize an instance
<i>(animal 8 12) </i> â†’   #&lt;animal&gt; (8 12)

;; struct initializer
(struct animal ((legs 0) (eyes 0)) #:initialize animal-init)
(define (animal-init a)  (writeln 'animal-init) (set-animal-legs! a 4))

;; super-structure
(struct cat animal ((tails 9)) #:initialize cat-init #:tostring cat-show)
(define (cat-show cat:c) (format "ğŸ± %d %d %d" c.legs c.eyes c.tails))
(define (cat-init cat:c) (writeln 'cat-init) (set-cat-eyes! c 3/2))</i>  

<i>(define felix (cat))</i>  â†’   felix
    â†’  animal-init    ;;  super initializer called
    â†’  cat-init  ;;  initializer  called
<i>felix</i>  â†’   ğŸ± 4 3/2 9

</pre>
<h4 id='struct-copy'>(<b>copy </b><i>instance</i>) â› new deep copy of <i>instance</i>

<pre>
;; See <a href="http://rosettacode.org/wiki/Polymorphic_copy#EchoLisp">polymorphic copy</a>
</pre>

<h3>Structures - Types - Methods</h3>
<p>A structure defines a <a href="#types.lib">type</a>. Methods can be defined which use a struture type. Note that you can use the dot notation - name.slot-name - inside a method using structure type(s).</p>
<pre>
<i>(lib 'types)

(struct dog animal ((tails 1)))
(define-method (run animal:a ) (writeln 'animal a 'running))
(define-method (run cat:c) (writeln 'cat c 'running 'with c.tails 'tails ))
(define-method (run cat:c number:speed) (writeln 'cat c 'running-at speed)) 
(define-method (run dog:d) 
			(call-super run d)
			(writeln 'dog d 'running))

(define milou (dog))
(define felix (cat))</i>

;; (run milou)  method call with a dog type argument
;; (run felix 333) method call with a cat type argument and number argument
<i>(run milou)</i>
    animal     #<dog> (4 0 1)     running    
    dog     #<dog> (4 0 1)     running    
<i>(run felix)</i>
    cat     ğŸ± 4 3/2 9     running     with     9     tails    
<i>(run felix 333)</i>
    cat     ğŸ± 4 3/2 9     running-at     333
</pre>

<h3>Structures - Low level procedures</h3>
<p>A <b>struct</b> declaration generates the constant keywords #:&lt;struct&gt;.&lt;slot-name&gt; which are bound to the corresponding slots numbers.</p>
<h4 id='struct-get'>(<b>struct-get </b><i>instance slot-number</i>) â› value for slot <i>slot-number</i> of structure instance <i>instance</i>. No validity checks performed for arguments. Slots are numbered 0,1, ...</h4>
<br>

<pre>
(struct writer (name age books))
(define simon (writer "Gallubert" 66 '(my-life me-and-Wittgenstein)))

<i>(struct-get simon #:writer.name)</i>  â†’  "gallubert"
<i>(struct-get simon 1)</i>   â†’  66 
<i>#:writer.books</i>  â†’  2 ;; slot number
</pre>

<h2 id = 'match'>Matching - Match.lib</h2>
<h4> (<b>match</b><i> expr clause clause .. [(else body)]</i>) â†’  error if no match and no <i>else</i> clause, else returns the value of the first matching clause, or the value of the <i>else</i> body.</h4>
<br>
<h4> (<b>check-match</b><i> expr pattern [proc:1] </i>) â†’  #t if matching is successful. Else if <i>proc</i> is present, returns (proc expr). Else raises an error.</h4>


<p>A clause is a couple (pattern body) , where body in a sequence of expressions. The value of a clause is the evaluation of the body, in the pattern environment bindings.
<p>A pattern is a matcher or a list of patterns. Identifiers in a pattern are bound to the matched value. All bindings of an identifier must be the same inside the same pattern. Identifiers must begin with a letter. 
<br>A matcher matches a value - which may be any lisp object - according to the following rules :</p>

<p>
<th>matcher :=</th>
<table id = "tb-match">

<tr>
<td><i>id</i></td>
<td>matches anything and binds id to matched value</td>
</tr>
<tr>
<td>_</td>
<td>matches anything</td>
</tr>
<tr>
<td><i>(m<sub>1</sub> m<sub>2</sub> ...) </td>
<td>matches list (v<sub>1</sub> v<sub>2</sub> ..) iff m<sub>i</sub> matches v<sub>i</sub></td>
</tr>
<tr>
<td><i>(S m<sub>1</sub> m<sub>2</sub> ...) </td>
<td>matches an instance of structure S iff m<sub>i</sub> matches slot<sub>i</sub></td>
</tr>
<tr>
<td>'<i>m-value</i></td>
<td>matches iff (eq? m-value value)</td>
</tr>
<tr>
<td>(? <i>proc:1</i>)</td>
<td>matches if (proc value) is #t</td>
</tr>
<tr>
<td>(? <i>proc:1 id</i>)</td>
<td>matches if (proc value) is #t and binds id to matched value</td>
</tr>
<tr>
<td>(? <i>"/regexp/" [id]</i>)</td>
<td>regexp matches and binds id to matched value</td>
</tr>
<tr>
<td><i>id</i> ...</td>
<td>matches 1 or more consecutive values and binds id to the matched sub-list</td>
</tr>
<tr>
<td>other</td>
<td>matches (eq? other value)</td>
</tr>
</table>
</p>

<pre>
(lib 'match)

;; matching lists
<i>(match '( 11 22 33) [( a b c) (list c a b)])</i>  â†’   (33 11 22)
<i>(match '(B C D E F)
      [('A a ...) a]
      [('B b ...) b])</i>  â†’ (C D E F)
      
;; predicates
<i>(match "42" 
     [(? string? a) (list 'STRING a)]
     [(? number? a) (list 'NUMBER a)] 
     [else 'OTHER])</i>   â†’ (STRING "42")

;; matching structures
;; see <a href="http://rosettacode.org/wiki/Pattern_matching">pattern matching</a> at rosetta.org

;; matching formal expressions
;; see <a href= "http://rosettacode.org/wiki/Check_Machin-like_formulas#EchoLisp">Machin formulas </a> at rosetta.org
</pre>

<h3 id = 'macros'>Reader macros</h3><p>Reader macros replace <i>patterns</i> by <i>templates</i> - using the match mechanism : variable replacement, etc. - inside an input expression, before any evaluation.
</p>
<h4 id='define-macro'>(<b>define-macro </b><i>name pattern template</i>) -> new reader macro</h4>
<h4 id='define-macro'>(<b>define-macro </b><i>name null</i>) -> delete macro <i>name</i></h4>
<h4 id='macro?'>(<b>macro? </b><i>name</i>) -> #f or macro contents</h4>
<h4 id='reader-macros'>(<b>reader-macros </b>) -> list of installed macros</h4>
<pre>
(lib 'match)
<i>(define-macro m-or (a || b) (or a b))</i>  â†’   m-or
<i>(define-macro m-and (a && b) (and a b))</i>  â†’   m-and

<i>(reader-macros)</i>  â†’   (("m-and" (a && b) (and a b)) ("m-or" (a || b) (or a b)))
<i>(macro? 'm-and)</i>  â†’   ((a && b) (and a b))

<i>(3 && 9)</i>  â†’   9
<i>(3 || 9)</i>  â†’   3
</pre>

<h2 id = 'infix.lib'>Infix EchoLisp - infix.lib</h2>
<p>Infix - standard math notation - expressions may be used in functions bodies using infix blocks, or directly read by the top-level read-eval-print loop.
</p>
<p>Syntax :
<ul>
<li>infix-block := (#:infix statement <big><b>;</b></big> statement ; ...)</li>
<li>statement := expression | assign-statement</li>
<li>assign-statement := id <big><b>:=</b></big> statement</li>
<li>expression := conditional | math-expression</li>
<li>conditional := <b><big>if</big></b> ( expression) block [<b><big>else</big></b> block] | <b><big>while</big></b> (expression) block | <b><big>when</big></b> (expression) block</li>
<li>block := expression | {expression ; expression ; ..}</li>
<li>expression := math/logical expression using +, -, *, /, //, ^ , &&, ||, <, <=, ()  operators and terminal values</li>
<li>terminal := constant | number | id | [++|--] id | id [++|--] | function-call | ' expression</li>
<li>function-call := id (expression [<b><big>,</big></b> expression , ..])</li>
<li>id := symbol name or function parameter name</li>
</ul>
</p>

<pre>
(lib 'infix)
<i>
(define (f x y)
    (define r 0) (define alpha 0) (define beta 0)
    [#:infix
        r:= sqrt(x*x + y*y) ;
        alpha := acos (x / r) ;
        beta := asin(y / r) ; ]
    (writeln 'rho r  'alpha alpha  'beta  beta))
</i>
(f 2 2)
    â†’ Ï     2.8284     Î±     0.7854     Î²     0.7854    
(f 4 4)
    â†’ Ï     5.6569     Î±     0.7854     Î²     0.7854    
  
</pre>

<h3 id = 'infix'>Infix EchoLisp - Top level</h3>
<h4 id='use-infix'>(<b>use-infix </b> #t) -> switch to top-level infix mode</h4>
<h4 id='use-infix'> <b>use-infix </b>(#f) -> quit top-level infix mode</h4>

<pre>
(lib 'infix)
<i>(define-values (a b x ) '(0 0 0))</i>  

<i>(use-infix #t)</i>  â†’   #t
<i>a:= 1 + 10*10</i>  â†’   101
<i>prime? (a)</i>  â†’   #t

<i>if (a > 10) 'vrai else 'faux</i>  â†’   vrai
<i>while (a-- > 90) write(a)</i>  â†’   #f
100 99 98 97 96 95 94 93 92 91 90

<i>x:= cos(PI)</i>  â†’   -1
<i>a*x*x + b*x + 42</i>  â†’   131

<i>a:=2 ; b := 20; a^b</i> 
	[2] â†’   1048576 ;; use of &i variables
	<i>&2 + &2</i> 
	[3] â†’ 2097152
use-infix(#f)
</pre>

<h2 id="gloops.lib">Gloops.lib - Classes, Generics, Methods, Instances</h2>
<p>
<small>Gloops stands for "<b>G</b>loops <b>l</b>ibrary for <b>o</b>bject <b>o</b>riented <b>p</b>rogramming, <b>s</b> at end".</small>

<pre>
<a href="http://rosettacode.org/wiki/Classes#EchoLisp">Example</a> : classes, instanciation and methods.
Example : a class of large <a href="http://rosettacode.org/wiki/Bernoulli_numbers#EchoLisp">Rational</a> numbers.
</pre>


<h2 id = 'plot.lib'>Plot.lib - Plotting and Drawing</h2>
<h4>(lib 'plot.lib) â› loads the plot library.</h4>
<h4 id='plot-on'>(<b>plot-on</b>) or ğŸ“Š  button â› shows the drawing area - canvas - ant its controls.</h4>
<h4 id='plot-off'>(<b>plot-off</b>)  or ğŸ“Š  button â› hides the drawing area </h4>

<p>Plot controls - sliders - are used to modify the appearance of a bit-map. Description, in order of appearance: 
<ul>
<li>Time slider : Set the t parameter value in interval [0...1] (*)</li>
<li>Hue rotation slider : rotate colors in the HSV color space</li>
<li>Hue adjust slider</li>
<li>Light saturation adjust slider</li>
<li>Brightness adjust slider</li>
<li>Curve levels adjust slider : reduces the number of colors : pixellates</li>
<li>Zoom slider : multiplies interval by 0.1 to 10.(*)</li>
<br>
<li>Mouse : Shows (x,y) coordinates and function value at (x,y).</li>
</ul>
</p>

<p>
<small>(*) â³ Time warning : The curve is re-computed. âŒ›ï¸ </small>
</p>
<p>In the following, f<sub>x</sub> is a function of x (real), f<sub>xy</sub> is a real function of (x,y) , f<sub>n</sub> is a function of the integer n, fx<sub>u</sub> is a function of the parameter u which returns a value for x, anf f<sub>z</sub> is a function of the complex z, which returns a complex value.<br>
A <mark><i>range</i></mark> defines an interval for drawing. A <i>range</i> may be an interval : (-5 +10), or a short-cut : -3 means (-3 3), and 6 means (0 6).<br>
A <i>color</i> is a string : CSS name ("lightgreen", "white", â€¦) or CSS <a href="http://www.w3schools.com/cssref/css_colors.asp">color hexa value</a> : "#rrggbb".
<br>
ğŸ“Œ Points P<sub>i</sub>(x<sub>i</sub>,y<sub>i</sub>) are defined in the grid x/y-minmax coordinates (not pixels). 
</p>


<h4 id='plot-size'> (<b>plot-size </b>[<i>pixels</i>])â› gets/sets the drawing area to a (size x size) bit-map. Default is  410x410 pixels</h4>
<h4 id='plot-init'>(<b>plot-init</b>) â› reset ALL plot parameters</h4>
<h4 id='plot-undo)'>(<b>plot-undo) </b>â› undo last drawing : curve, grid, text, â€¦</h4>
<h4 id='plot-clear'>(<b>plot-clear</b>) â› clears area and resets the undo stack</h4>


<h3>Drawing parameters</h3>
<h4 id='plot-color'>(<b>plot-color </b><i>color</i>) â› sets the drawing color</h4>
<h4 id='plot-background'>(<b>plot-background </b><i>color</i>) â› sets the background color</h4>
<h4 id='plot-fill-color'>(<b>plot-fill-color </b><i>color</i>) â› sets the fill color</h4>
<h4 id='plot-line-width'>(<b>plot-line-width </b><i>n</i>) â› sets the line width (default 2)</h4>
<br>
<h4 id='make-gradient'>(<b>make-gradient </b><i>x<sub>0</sub> y<sub>0</sub> x<sub>1</sub> y<sub>1</sub></i>) â› new linear gradient from P<sub>0</sub> to P<sub>1</sub></h4> 
<h4 id='make-circular-gradient'>(<b>make-circular-gradient </b><i>x<sub>0</sub> y<sub>0</sub> r<sub>0</sub> x<sub>1</sub> y<sub>1</sub> r<sub>1</sub></i>) â› new circular gradient from circle (P<sub>0</sub>, r<sub>0</sub>) to circle (P<sub>1</sub>, r<sub>1</sub>). <small>r<sub>i</sub> in pixels unit.</small></h4> 
<h4 id='gradient-add-stop'>(<b>gradient-add-stop </b> <i>gradient x color</i>) â› adds stop color to <i>gradient</i>. Sets plot fill color to <i>gradient</i>.</h4>
<br>
<h4 id='plot-minmax'>(<b>plot-minmax </b>) â›  gets current ((xmin xmax) (ymin ymax))
<h4 id='plot-x-minmax'>(<b>plot-x-minmax </b><i>range</i>) â› sets xmin and xmax for the grid (default: auto, initial values (-1,1))</h4>
<h4 id='plot-y-minmax'>(<b>plot-y-minmax </b><i>range</i>) â› sets ymin and ymax for the grid (default: auto, initial values (-1,1))</h4>
<h4 id='plot-x-minmax'>(<b>plot-x-minmax </b><i> 'auto</i>) â› sets automatic (computed) value for xmin, xmax</h4>
<h4 id='plot-y-minmax'>(<b>plot-y-minmax </b><i> 'auto</i>) â› sets automatic (computed) value for ymin, ymax</h4>


<h3>Drawing objects</h3>
<h4 id='plot-edit'>(<b>plot-edit</b>) â› to be used after a sequence of drawings, to take a snapshot and enable the plot controls.</h4>
<br>
<h4 id='plot-segment'>(<b>plot-segment </b><i>x<sub>0</sub> y<sub>0</sub> x<sub>1</sub> y<sub>1</sub></i>) â› draws line segment from P<sub>0</sub> to P<sub>1</sub>, with current plot-color and plot-line-width.</h4>
<h4 id='plot-rect'>(<b>plot-rect </b><i>x<sub>0</sub> y<sub>0</sub> x<sub>1</sub> y<sub>1</sub></i>) â› draws and fills rectangle, corners (P<sub>0</sub>, P<sub>1</sub>)</h4>
<br>
<h4 id='plot-circle'>(<b>plot-circle </b><i>x<sub>0</sub> y<sub>0</sub> R</i>) â› draws and fills circle, center at P<sub>0</sub>, radius R - R in pixels units -</h4>
<h4 id='plot-arc'>(<b>plot-arc </b><i>x<sub>0</sub> y<sub>0</sub> R &alpha; &beta; [#t|#f]</i>) â› draws and strokes arc, center at P<sub>0</sub>, radius R - R in pixels units - , from angle &alpha; to &beta;. Counter-clockwise if #t (default), clockwise if #f.</h4>
<br>
<h4 id='plot-square'>(<b>plot-square </b><i>x<sub>0</sub> y<sub>0</sub> W</i>) â› draws and fills square centered at P<sub>0</sub>, width W  - W in pixels units </h4>
<h4 id='plot-axis'>(<b>plot-axis </b>[x<sub>0</sub> [y<sub>0</sub> [color]]]) â› draw two axis at point (x<sub>0</sub>,y<sub>0</sub>) - Defaults : x<sub>0</sub> = 0 ,y<sub>0</sub> =  x<sub>0</sub>. </h4>
<h4 id='plot-grid'>(<b>plot-grid </b>[x-unit [y-unit [color]]]) â› draws grid by steps of x-unit, y-unit. Defaults : 10 steps subdivision.</h4>
<h4 id='plot-font'>(<b>plot-font </b><i>font</i>) â› font for text to draw. Default: <span class = "textplot">"16px verdana"</span></h4>
<h4 id='plot-text'>(<b>plot-text </b><i>string x<sub>0</sub> y<sub>0</sub> [color]</i>) â› draws text "string" at (x<sub>0</sub>,y<sub>0</sub>)</h4>

<pre>
(lib 'plot)
<i>(define g (make-circular-gradient 0 0 20 0 0 400))
(gradient-add-stop g 0 "yellow")
(gradient-add-stop g 1 "red")
(plot-rect -1 -1 1 1)</i> ;; [-1 1] is the default plotting values interval
(plot-text "(make-circular-gradient 0 0 20 0 0 400)" -0.9 -0.9 "black")

<img src="./images/gradient.png" width = 300 height=300 >
</pre>

<h3> ğŸ“ˆ Curves plotting procedures</h3>
<h4 id='plot-steps'>(<b>plot-steps </b><i>steps</i>) â› number of sampling steps. Default 500</h4>
<h4 id='plot'>(<b>plot </b><i>f<sub>x</sub> x-range</i>) â› plots f<sub>x</sub> , x in x-range</h4>
<h4 id='plot-xy'>(<b>plot-xy </b><i>f<sub>xy</sub> x-range y-range</i>) â› plots f<sub>xy</sub> , x in x-range, y in y-range</h4>
<h4 id='plot-sequence'>(<b>plot-sequence </b><i>f<sub>n</sub> n-range</i>) â› plots sequence f<sub>n</sub>(i), i in n-range</h4>

<pre>
<i>(lib 'plot.lib)</i>

<i>(plot-size 600)</i> ;;  â†’ 600x600px canvas
<i>(plot sin -PI)</i>  â†’   (("x:auto" -3.14 3.14) ("y:auto" -1.1 1.1))
<i>(plot-axis 0 0 "red")</i>  â†’   (204 204)
<i>(plot-grid 0.5 0.5)</i>  â†’   #t

<img src="./images/plot-sin.png" width = 300 height=300 >

;; <a href="http://fr.wikipedia.org/wiki/Conjecture_de_Syracuse">Collatz</a> sequence
(define (collatz n) 
	(if (zero? n) *seed*
	(let [(prec (collatz (1- n)))]
		 (if (even? prec)
		 	 (/ prec 2) 
		 	 (1+ (* 3 prec)))))) â†’  collatz
(define *seed* 101) â†’  *seed*
(plot-sequence collatz 100)  â†’  (("x:auto" 0 100) ("y" 0 100))
(plot-grid 20 10)
<img src="./images/plot-sequence.png" width = 300 height=300 >

;; Ellie : a nice elliptic curve
<i>(define (Ellie x y t) (- (* x x x) (* y y) x t))</i> ;; x<sup>3</sup> - y<sup>2</sup> - x - t
<i>(plot-xy Ellie -3 -3)</i>
<i>(plot-animate 10)</i>;; do vary t in [0...1]

See <a href="http://rosettacode.org/wiki/Elliptic_curve_arithmetic#EchoLisp">elliptic curve aritmetic</a> in Rosetta code.
</pre>
<center>
<img src="./images/plot-ellie.png" width = "300" height="300">
<img src="./images/elliptic-add.png" width = "300" height="300">
</center>
<pre>
See or load <a href="./lib/plot-xy.glisp">plot-xy.glisp</a> for other nice f(x,y) functions.
</pre>

<h3>Parametric curves</h3>
<h4 id='plot-param'>(<b>plot-param </b><i>fx<sub>u</sub> fy<sub>u</sub> u-range</i>) â› plot paremetric curve x= fx<sub>u</sub>(u), y=fy<sub>u</sub>(u), u in u-range.</h4>
<h4 id='plot-polar'>(<b>plot-polar </b><i>rho<sub>u</sub> theta<sub>u</sub> u-range</i>) â› plot polar curve rho = rho<sub>u</sub>(u), theta = theta<sub>u</sub>(u), u in u-range.</h4>

<pre>
<i>(plot-clear)</i>  â†’   #t
<i>(define (fx u) (sin (* 11 u))) (define (fy u) (cos (* 19 u)))</i>   â†’   fx fy
<i>(plot-param fx fy 10)</i>  â†’   (("x:auto" -1.1 1.1) ("y:auto" -1.1 1.1))
<img src="./images/plot-param.png" width = 300 height=300 >


<i>(define (rho u) (- (* u u) u 1))</i>  â†’ rho
<i>(define (theta u) (+ 1 (* u u)))</i>  â†’ theta
<i>(plot-line-width 4</i>) â†’ 4
<i>(plot-polar rho theta 3)</i>  â†’   (("x:auto" -5.06 2.34) ("y:auto" -2.99 3.67))

<i>(plot-font "64px Helvetica")</i>  â†’   "64px Helvetica"
<i>(plot-text "EchoLisp" 0 0 "red")</i>  â†’   #t
<i>(plot-undo)</i> ;; bad position - undo and try another one
<i>(plot-text "EchoLisp" -5 0 "red")</i>  â†’   #t
<img src="./images/plot-polar.png" width = 300 height=300 >
</pre>

<h3>Animation</h3>
<p>Animation can be performed by adding a time parameter to the plotted function(s). t will be set in the [0..1] range by the plot-animate function, or manually, using the time slider.</p>
<h4 id='plot-animate'>(<b>plot-animate </b><i>seconds</i>) â› re-plots, varying t in [0â€¦1].</h4>

<pre>
<i>(plot-line-width 3)</i>  â†’   3
<i>(define (f x t) (sin (+ x t)))</i>  â†’   f
<i>(plot f -PI)</i>      ;; plot before animating
<i>(plot-animate 6)</i> ;; 6 seconds


<i>(define (fx u t) (* t (sin u)))</i>  â†’   fx
<i>(define (fy u t) (* (1- t) (cos u)))</i>  â†’   fy
<i>(plot-x-minmax -1)</i>  â†’   (("x" -1 1) ("y:auto" 0 0))
<i>(plot-y-minmax -1)</i>  â†’   (("x" -1 1) ("y" -1 1)) ;; set grid size for animation
<i>(plot-param fx fy 2PI)</i>  
<i>(plot-animate 5)</i>  â†’   ((-1 1) (-1 1))
</pre>

<h3>Complex functions</h3>
<p>Domain coloring of complex values is performed using the plot-z functions.</p>
<h4 id='plot-z-arg'>(<b>plot-z-arg </b><i>f_z x-range y-range</i>) â› complex values. hue = function (arg), light = function (modulus)</h4>
<h4 id='plot-z-mod'>(<b>plot-z-mod </b><i>f_z x-range y-range</i>) â› complex values. hue = function (modulus), light = function (arg)</h4>
<pre>
<i>(plot-z-arg identity -2 -2)</i> ;; complex plane. hue = function (arg)
<img src="./images/plot-z-arg-id.png" width = 300 height=300 >

<i>(plot-z-mod identity -2 -2)</i> ;; complex plane. hue = function (modulus)
<i>(plot-grid 1 1)</i>
<img src="./images/plot-z-mod-id.png" width = 300 height=300 >


<i>g : (define (g n) (/ (1+ (* n I))))</i>
<i>f : (define (f z) (cserie g z 100))</i>
<i>(plot-z-mod f -1.5 -1.5)</i>
<img src="./images/plot-z-mod.png" width = 300 height=300 >
</pre>


<h3>Interpolation functions</h3>
<h4 id='fminmax'>(<b>fminmax </b><i>f<sub>x</sub> x-range</i>) â†’  (min-of-f<sub>x</sub> max-of-f<sub>x</sub>) approximative values</h4>
<h4 id='linear'>(<b>linear </b><i>x xmin xmax </i>) â†’   (x-xmin)/(xmax-xmin) : mapping [xmin xmax] to [0 1]</h4>
<h4 id='linear'>(<b>linear </b><i>x xmin xmax ymin ymax</i>)  â†’  ymin + (x-xmin)*(ymax-ymin)/(xmax-xmin) : mapping [xmin xmax] to [ymin ymax]</h4>
<h4 id='smoothstep'>(<b>smoothstep </b><i>x</i>)  â†’ -2x<sup>3</sup> + x<sup>2</sup> smooth interpolation  between 0 and 1</h4>
<h4 id='s-curve'>(<b>s-curve </b><i>x gamma</i>)  â†’  x<sup>&gamma;</sup> interpolation between 0 and 1. Slope = function of gamma parameter.</h4>

<pre>
(plot smoothstep '(0 1))
(plot-axis 0.5 0.5)
(plot (lambda(x) (s-curve x 3)) '(0 1))
<img src="./images/smooth.png" width = 300 height=300 >
</pre>

<pre>
<i>(fminmax sin -PI)</i>  â†’   (-1 1)
</pre>


<h3>Pixels</h3>
<p>Color components (r=red,g=green,b=blue,a=alpha) , g=gray or (h=hue,s=saturation,v=value) must be float numbers in range [0..1]. The (rgb ..) and (hsv ..) functions return a color which can be drawn on screen, at (x,y) by the (plot-rgb ..) function.<br>
Notation: rgb-fun<sub>xy</sub> is a function of (x,y) which returns an rgb-color, i.e. the color pixel at (x,y). </p> 
<h4 id='gray'>(<b>gray </b><i>g</i>) â› rgb-gray-color from 0=black to 1=white</h4>
<h4 id='rgb'>(<b>rgb </b><i>r g b</i>) â› rgb-color</h4>
<h4 id='rgb->list'>(<b>rgb->list </b><i>rgb-color</i>) â› list (r g b a) , integers in [0..255]</h4>
<h4 id='rgba'>(<b>rgba </b><i>r g b a</i>) â› rgb-color with transparency a (1 = opaque)</h4>
<h4 id='hsv->rgb'>(<b>hsv->rgb </b><i>h s v</i>) â› converts (h s v) color to (r g b) color</h4>
<h4 id='hsv->rgb'>(<b>hsva->rgb </b><i>h s v a</i>) â› converts (h s v a) color to (r g b a) color</h4>
<h4 id='plot-rgb'>(<b>plot-rgb </b><i>rgb-fun<sub>xy</sub> x-range y-range</i>)</h4>

<pre>
<i>(rgba 1 0 0 0)</i>  â†’   255 ;; red
<i>(rgb 1 1 1)</i>  â†’   -1 ;; white
<i>(hsv->rgb 0 0 1)</i>  â†’   -1 ;; white
<i>(rgba 0.5 0.8 0.5 1.0)</i>  â†’   -8401793

<i>(define (pixel x y) 
	(rgba-abs (atan x) (atan y) 0 (+ (sin x) (sin y))))</i>
<i>(plot-rgb pixel -2 -2)</i>
<img src="./images/plot-rgb.png" width = 300 height=300 >

;; the hue color circle 
;; angle [-PI ... PI] is mapped onto hue [0 ... 1]
<i>(define (colors x y) (let [(z (complex x y))] 
   (if ( <= (magnitude z) 1 )</i> ;; inside circle ?
       <i>(hsv->rgb (linear (angle z) -PI PI) 1 1)
       0 )))
(plot-rgb colors -1 -1)</i>
   
<img src="./images/plot-hue-colors.png" width = 300 height=300 >          
</pre>

<h3>Integer functions. Mapping <b>N</b> to <b>N</b>*<b>N</b></h3>
<p>Notation: rgb-fun<sub>n</sub> is a function of n which returns an rgb-color, i.e. the color pixel at (ix,iy), where (ix,iy) are the integer values mapped to n. rgb-fun<sub>n</sub> has the following signature : 
<br> âœ’ï¸  (define (my-pixel-color-at-n n [nmax [ time]]) body ) 
<br>The parameters nmax and time are optional. Use time in [0...1] to animate the picture.</p>
</p>
<h4 id='plot-spiral'>(<b>plot-spiral </b><i>rgb-fun<sub>n</sub> n-range</i>) -> plots rgb-fun(n) onto a spiral</h4>
<h4 id='plot-hilbert'>(<b>plot-hilbert </b><i>rgb-fun<sub>n</sub> n-range</i>) -> plots rgb-fun(n) onto an <a href="http://en.wikipedia.org/wiki/Hilbert_curve">Hilbert</a> curve</h4>

<pre>
;; <b> 64 shades of gray - Hilbert curve</b>
(define (pixel n) (gray (// (% n 64) 63)))
(plot-hilbert pixel 4096)

<img src = "./images/plot-gray-64-hilbert.png" width = "300" height="300">

;; <a href="http://fr.wikipedia.org/wiki/Spirale_d%27Ulam">Ulam</a> spiral
(define *red* (rgb 1 0 0))
(define (ulam n nmax) (if ( prime? n) *red* (gray (// n nmax))))
(plot-spiral ulam 1000) ;; range [0...1000]

<img src = "./images/ulam-1000.png" width = "300" height="300">

(plot-spiral ulam '(100000 110000)) ;; other n-range
</pre>

<h2 id="data-series">Data series - Time series</h2>
<h3>"Time series are also data series" - <small>Simon Gallubert in 'Temps, espace et fantaisie'</small> -</h3>
<p>Data series are lists or vectors of couples of values (x<sub>i</sub> y<sub>i</sub>). Time series are lists or vectors of couples (date<sub>i</sub> y<sub>i</sub>). Couples may be lists: ( x y), vectors of dimension 2:  #(x y) or pairs: ( x . y).Series can be home made or imported using the JSON library.
<br> The canonical - most compact - form is a vector of pairs :<br> #((x<sub>0</sub> . y<sub>0</sub> )(x<sub>1</sub> . y<sub>1</sub>) ...)
<br>
In a time serie, the date<sub>i</sub> are date objects, or strings convertible to dates -  "2021-11-28"  -  or numbers : dates in <a href="#date->seconds">seconds</a>. All data-serie functions applies to time series. A date-range is either a list (date-from date-to) , or a simple date : date-from, meaning [date-from .. now] .
</p>

<h4 id='data-serie'>(<b>data-serie </b><i>[list|vector]</i>) -> sorts, and converts to canonical form </h4>
<h4 id='time-serie'>(<b>time-serie </b><i>[list|vector]</i>) -> sorts, checks dates, and converts to canonical form </h4>
<h4 id='data-serie-get'>(<b>data-serie-get </b><i>x-value</i>) -> y-value at x. Performs  linear interpolation between x<sub>i</sub>, x<sub>i+1</sub> or d<sub>i</sub>,d<sub>i+1</sub></h4>
<br>
<h4 id='data-serie-x'>(<b>data-serie-x </b><i> serie i</i>) -> x-value of n-th point. Same as (car (vector-ref serie n))</h4>
<h4 id='data-serie-y'>(<b>data-serie-y </b><i> serie i</i>) -> y-value of n-th point. Same as (cdr (vector-ref serie n))</h4>
<br>
<h4 id='plot-dots'>(<b>plot-dots </b><i>data-serie string</i>) -> Draws the text "string" , centered at each (x<sub>i</sub>,y<sub>i</sub>) point.</h4>
<h4 id='plot-time-serie'>(<b>plot-time-serie </b><i>time-serie [ interval [ date-range]]</i>) -> draws the curve x<sub>i</sub> = f(d<sub>i</sub>) <br> Sampling is given by <i>interval</i> in <u>seconds</u> - default 1 DAY = 3600*24; default date range is [d<sub>0</sub> d<sub>n</sub>]</h4>

<pre>
(lib 'plot)
(define (r-dots n) (for/list ((i n)) (list (random 100) (random 100)))) ;; n random dots

(plot-dots (r-dots 10) "ğŸŠ")
(plot-dots (r-dots 10) "ğŸ“Œ")
...
<img src = "./images/stats-2015.png" width = "300" height="300">
</pre>

<h2 id = "bit-map">Canvas, bit-maps  and typed vectors</h2>
<p>The following allow to map a <a href= "#vlib.lib">typed</a> vector onto a bit-map - canvas - retrieve/modify pixels, and (re)draw the canvas. Requires the vlib.lib library.
<h4>(<b>plot-clear</b>) â†’ clears the canvas - all bytes set to 0.
<h4 id='plot-size'>(<b>plot-size </b>) â†’ (width . height) , canvas dimensions in pixel units.</h4>
<h4 id='plot-size'>(<b>plot-size width height</b>) â†’ (width . height) , sets canvas dimensions in pixel units.</h4>

<br>
<h4 id='pixel->uint8-clamped-vector'>(<b>pixels->uint8-clamped-vector</b>) â†’ new bit-map = (big) vector of length width*height*4, image of canvas contents. Each 8-bits element is a rgba componet, in order r, g, b, a, clamped to [0..255]</h4>
<br>
<h4 id='pixels->int32-vector'>(<b>pixels->[u]int32-vector</b>) â†’ new  bit-map = (big) vector of length width*height, image of the canvas contents. Each 32-bits element is an unsigned/signed rgba color.</h4>
<br>
<h4 id = 'pixel-ref'>(<b>pixels-ref</b> <i>bit-map x y</i>) â†’ rgba color at x + y*width</h4>
<h4 id = 'pixel-set!'>(<b>pixels-set!</b> <i>bit-map x y rgba-color</i>) â†’  sets pixel at x + y*width</h4>
<h4 id = 'pixels-map'>(<b>pixels-map</b> <i>proc:2:2 bit-map</i>)  â†’  sets bit-map[i] to (proc x y), i = x  + width*y, x in [0...width[, y in [0...height[.</h4>
<br>
<h4 id = 'make-region'>(<b>make-region</b> <i>in-region:3:3 bit-map x0 y0</i>) â†’ recursively colors orthogonal adjacent pixels with color at (x0,y0), starting from pixel (x0,y0). <b>(in-region bit-map x y)</b> is a predicate used to select pixels which belongs to the region.</h4>
<br>
<h4 id='vector->pixels'>(<b>vector->pixels </b><i>bit-map</i>) draws bit-map contents onto the canvas. â†’ number of bytes written</h4>
<pre>
(lib 'plot)
(lib 'vlib)
<i>
(define (plot-pix (blue 0))
	(define width (first (plot-size))) ;; get canvas dimensions
	(define height (rest (plot-size)))
	(define PIX (pixels->int32-vector)) ;; get canvas image
	(define (pcolor x y) ;; color at (x,y)
		(rgb (sin (// x width)) (sin (// y height)) blue))
	(pixels-map pcolor PIX)
	(vector->pixels PIX)) ;; draw canvas image
</i>
(plot-pix)   â†’   672400 ;; no blue 
(plot-pix 0.6)   â†’   672400 ;; shade of blue
(plot-pix 1.0)
</pre>
<center>
<img src = "./images/types-1.png"  width = "200" height="200">
<img src = "./images/types-2.png"  width = "200" height="200">
<img src = "./images/types-3.png"  width = "200" height="200">
</center>
<pre>
See also <a href="http://rosettacode.org/wiki/Percolation/Mean_cluster_density#EchoLisp">percolation</a> in Rosetta code.
See also <a href="http://rosettacode.org/wiki/Munching_squares#EchoLisp">munching squares</a> in Rosetta code.
</pre>
<center>
<img src = "./images/rosetta-clusters-400.jpg"  width = "200" height="200">
<img src = "./images/color-munch.png"  width = "200" height="200">
</center>

<h2 id = 'plot-3d.lib'>Plot-3d.lib - 3D plotting</h2>
<p>The plot-3d library uses the Three.js library for rendering 3D surfaces. Surfaces can be defined as z = f(x,y) functions, parametric equations, implicit equations f(x,y,z) = 0 , or complex functions. 
</p>
<p><h4>(lib 'three.lib) â› loads the three.js library.</h4>
<p><h4>(lib 'plot-3d.lib) â› loads the plot library.</h4>
<h4 id='plot-3d-show'>(<b>plot-3d-show</b>) or ğŸ¥ button â› shows the drawing area - Web GL renderer - and its controls. Use the ğŸ¨ button to hide/show the controls.</h4>
<h4 id='plot-3d-hide'>(<b>plot-3d-hide</b>)  or âšªï¸ button â› hides the drawing area </h4>
<br>
<h4><b>Buttons</b></h4>
<ul class = "a">
<li>ğŸ¨ : hide/show palette
<li>ï¸ğŸ” : revert to starting position
<li>ğŸ¬ : start/stop animation
<li>âŒšï¸ : sets t value for functions (f x ..t)
</ul>

<h3 id='scene-3d'>3D scene parameters</h3>
<h4 id='scene-3d-reset'>(<b>scene-3d-reset </b>) â› Sets all parameters to their default values.
<h4 id='scene-3d'>(<b>scene-3d </b> <i>param<sub>1</sub> value<sub>1</sub>  param<sub>2</sub> value<sub>2</sub> </i> ...) â› Sets scene parameters. Param<sub>i</sub>, value<sub>i</sub> are not evaluated.

<pre>
(define (f x y) x ) ;; define the  plane z = x
(scene-3d xminmax 20 yminmax -12) ;;     set these parameters
(scene-3d material phong segments 60) ;; and these parameters
(scene-3d axis #t) ;; and this one
(plot-3d f ) ;; then draw
</pre>

<ul class = "a">
<li> xminmax : range for x values. <small> A range is a positive number : 3 -> [0..3], a negative number : -7 -> [-7 .. 7], or a list (xmin xmax).</small>
<li> yminmax : range for y values. Default : xminmax.
<li> zminmax : range for z values. Default : yminmax. If null, the z range is automatically computed when plotting f(x,y)  â› z .</li>
<br>
<li> uminmax : range for u values when plotting a parametric function, e.g f<sub>x</sub>(u,v) â› x. Default = interval [0..1]
<li> vminmax : range for v values. Default = interval [0..1]</li>
<br>
<li> segments : number of sampling points along each axis. Default : 100. <small>Implicit curves - f(x,y,z) = 0 -  generate <b>segments<sup>3</sup></b> vertices, other generate segments<sup>2</sup> vertices.</small></li>
<br>
<li><i>material</i> parameter values : </li>
<ul>
<li>phong : Unicolor material, with spotlights reflections. (1)</li>
<li>lambert : Unicolor material, colored by ambient and directional light (1).
<li>colored : Color of point P  (x,y,z) is function of |z|.</li> (2)
<li>normal : Color of point  P (x,y,z) is function of the normal vector at P.</li>
</ul>
<br>
<li>material-color : a color for (1)</li>
<li>texture : a texture for (1)</li>
<li>gradient : (color-zmin  color-z-is-zero color-zmax) : a list of 3 gradient colors for (2) 
<li>wireframe : #t or #f : show triangles or rectangles
</ul>

<h3 id='plot-3d'>3D drawing functions</h3>
<p>All these functions return the bounding box used for drawing.</p>
<h4 id = "plot-3d-box">(<b>plot-3d-box </b>) â› ((xmin xmax) (ymin ymax) (zmin zmax))</h4>
<br>
<h4 id = "plot-3d">(<b>plot-3d </b> f<sub>xy</sub>) â› plots z = (f<sub>xy</sub> x y)</h4>
<h4 id = "plot-3d-xyz">(<b>plot-3d-xyz </b> f<sub>xyz</sub>) â› plots poins (f<sub>xyz</sub> x y z) = 0 - Implicit surface definition, using marching cubes.</h4>
<h4 id = "plot-3d-param">(<b>plot-3d-param </b> f<sub>x</sub>  f<sub>y</sub>  f<sub>z</sub>) â› plots   point x = (f<sub>x</sub> u v), y = (f<sub>y</sub> u v), z = (f<sub>z</sub> u v).  - Parametric surface definition.</h4>
<h4 id = "cplot-3d">(<b>cplot-3d </b> f<sub>cxy</sub>) â› plots  |cz| = |(f<sub>cxy</sub>  x + iy)| - Complex surface definition. Points are colored according to &theta; = arg(cz), red if &theta; = 0 ( cz real).</h4>
<br>
<h4 id = "plot-3d-blob">(<b>cplot-3d-blob </b> <i>(isolevel blob-definition blob-definition ...)</i>) </h4>

<h3 id='plot-3d'>3D drawing decorations</h3>
<h4><b>Parameters/values</b></h4>
<p>A color may be a string : "yellow" or an hexa number : 0x808080 , medium gray. Default colors are 0x666666 : dark gray. Phong or lambert or textured material may need an ambient color and/or lights. Textures are defined by textures names : water, metal-i, stone-i, rain-i, wood-i, floral-i, vichy-i, mosaic-i, brick-i, 1 <= i <= 6 . </p>
<ul class = "a">
	<li>ambient-color : ambient color of scene - default 0x666666</li>
	<li>anim-bounce : animation type and speed - 0 = no animation</li>
	<li>anim-rotate</li>
	<li>anim-scale</li>
	<li>axis : #t|#f : draw Oxyz axis</li>
	<li>background : background color - default black</li>
	<li>controls : mouse control for camera "track"|"orbit" - default : "track"</li>
	<li>directional-color : color of directional light(s)</li>
	<li>directional-lights : number of directional lights - default 0, or 1 is material= phong or lambert </li>
	<li>line-color : color for grids and lines - default blue</li>
	<li>light-theta : angle (radians) : lights azimuth - default 45Â°</li>
	<li>material : lambert|normal|phong|colored</li>
	<li>material-color</li>
	<li>point-color :  color of point lights</li>
	<li>point-lights : number of point lights</li>
	<li>plane-color : walls colos</li>
	<li>plane-repeat : texture repeat number for walls - default 2 </li>
	<li>plane-texture : walls texture</li>
	<li>plane-width : width/height of each wall</li>
	<li>plane-x : #f or vertical wall at x = plane-x</li>
	<li>plane-y : #f or vertical wall at y = plane-y</li>
	<li>plane-z : #f or horizontal wall at z = plane-z</li>
	<li>segments : number of sgements to generate mesh - default 100</li>
	<li>shadow : shadow on walls - default #f</li>
	<li>shininess : of phong material - default 30</li>
	<li>specular-color : of phong material - default material-color/2</li>
	<li>spot-color : color of spot lights</li>
	<li>spot-lights : number of spot lights</li>
	<li>texture : of surface material</li>
	<li>texture-repeat : default 2</li>
	<li>tminmax : âŒšï¸  range for t parameter - default is 1 --> [0..1] </li>
	<li> xgrid,ygrid,zgrid  : #t | #f  : display orthogonal grids - default #f</li>
</ul>

<h3>3D objects</h3>
<p>The following are used to add objects to the surface being drawn : To Be Completed Later</p>




<h3 >3D advanced</h3>
<p>Custom functions may be defined for surface coloring, or surface transformation. All these functions are <a href="#inline">inline</a> functions</p>
<ul class = "a">
	<li>color-rgb = function(x,y,z) - Color of point (x,y,z) . Returns rgb(r,g,b)</li>
	<li>color-hsl = function(x,y,z) - Color of point (x,y,z) . Returns hsl(h,s,l)</li>
	<br>
	<li>xform = function (x,y,z) - Returns new x value for each surface point.</li>
	<li>yform = function (x,y,z) - Returns new y value for each surface point.</li>
	<li>yform = function (x,y,z) - Returns new z value for each surface point.</li>
</ul>


<h2 id='math.lib'>Math.lib</h2>
<h4 id='number->list'>(<b>number->list </b><i>n</i>) â› list of decimal digits = explode</h4>
<h4 id='list->number'>(<b>list->number </b><i>list</i>) â› implode list of digits|strings into number</h4>

<h3>Arithmetic</h3>
<h4 id="mean">(<b>mean </b><i>values-sequence</i>) â› mean value of <i>values-sequence</i>  which is a list, vector, <a href="#sequences.lib">sequence</a> or finite procrastinator.
<h4 id="sigma">(<b>sigma </b><i>f:1 nfrom nto</i>) â› &Sigma; (f n),  n in [nfrom...nto]</h4>
<h4 id="sigma">(<b>sigma-2 </b><i>f:2 nfrom nto mfrom mto</i>) â› &Sigma;&Sigma; (f n m),  n in [nfrom...nto], m in [mfrom .. mto]</h4>
<h4 id="product">(<b>product </b><i>f:1 nfrom nto</i>) â› &Pi; (f n),  n in [nfrom...nto]</h4>
<br>

<h4 id='egcd'>(<b>egcd </b><i>m n</i>) extented gcd â› (g a b) such as a*m + b*n = g = gcd(a,b)</h4>
<h4 id='crt-solve'>(<b>crt-solve </b><i>a-list m-list</i>) chinese remainder theorem â›  x such as x = a[i] (mod m[i]). m[i] and m[j] must be co-primes.</h4>
<br>
<h4 id='divides?'>(<b>divides? </b><i>a b</i>) â› #t if b exactly divides a, else #f.</h4>
<h4 id=num-divisors'>(<b>num-divisors </b><i>n</i>) â› number of integer divisors (n excluded)</h4>
<h4 id='sum-divisors'>(<b>sum-divisors </b><i>n</i>) â› sum of integer divisors (n excluded)</h4>
<h4 id='nth-prime'>(<b>nth-prime </b><i>n</i>) â› nth prime (small n)</h4>
<h4 id='primes-pi'>(<b>primes-pi </b><i>n</i>) â› number of primes <= n</h4>
<h4 id='in-primes'>(<b>in-primes </b><i>n</i>) â› infinite stream delivering successive primes from n</h4>
<br>
<h4 id="bernoulli">(<b>bernoulli </b><i>n</i>) â› Bernoulli number[n]. B<sub>0</sub>=1, B<sub>1</sub>=<b>1/2</b>, B<sub>odd</sub>=0, B<sub>2</sub>=1/6, ...
<pre>
<i>(lib 'math.lib)</i>
<span style="color:green">Lib: math.lib loaded.</span>

<i>(egcd 42 666)</i> â†’ (6 16 -1) ;; 42*16 - 666 = 6
<i>(crt-solve '(2 3 2) '(3 5 7))</i> â†’ 23

<i>(crt-solve '(2 3 2) '(5555 5 7))</i>
<span style= "color:red">âŒ error: mod[i] must be co-primes : assertion failed : 5555</span>

<i>(nth-prime 10000)</i>  â†’   104729
<i>(primes-pi 104729)</i>  â†’   10000

(lib 'bigint)
<i>(for ((p (in-primes 1000000000))) (write p) #:break (> p 1000000099))</i>
  â†’  1000000007 1000000009 1000000021 1000000033 1000000087 1000000093 1000000097 1000000103 
  
See also <a href="http://rosettacode.org/wiki/Faulhaber's_formula#EchoLisp">Faulhaber</a> formula and Bernoulli numbers in Rosetta code.
</pre>

<h3 id="contfract">Continued fractions</h3>
<p>A <a href="http://fr.wikipedia.org/wiki/Fraction_continue">continued fraction</a> is a list - finite or infinite -  of coefficients (a<sub>0</sub> a<sub>1</sub> a<sub>2</sub> ...) which compute the following :
</p>
<center>
<img src = "./images/contfract.png" width = "202" height="135">
</center>
<p>
In Lisp form :
<br>
<center>
	<span style="border:1px solid black;padding:20px">
	(+ a<sub>0</sub> (/ ( + a<sub>1</sub> (/ ( + a<sub>2</sub> (/ ( + a<sub>3</sub> ...)))))
	</span>
	</center> 
<br>
</p>
<p>
a<sub>0</sub> is the integer part of the continued fraction. The rest evaluates to the fractional part. The fraction is periodic iff its value is a quadratic irrational number : âˆš2, âˆš5, âˆš2015, ... 
</p>

<h4 id='number->contfract'>(<b>number->contfract </b><i>number [n]</i>) -> converts number to a continued fraction. n (optional) is the maximum number of terms. </h4><br>
<h4 id='contfract->number'>(<b>contfract->number </b><i>continued-fraction [n] </i>) -> value of <i>continued-fraction</i>, up to n terms. If no n, precision is 1e-12 .</h4><br>
<h4 id='convergents'>(<b>convergents </b><i>continued-fraction [n]</i>) -> list of n first convergents = rational numbers which approximate the continued fraction value. If no n, stops when precision < 1.e-10 </h4>
<pre>
<i>(number->contfract 22/7)</i>  â†’   (3 7) ;; 22/7 = 3 + 1/7

<i>(number->contfract 7/111)</i>  â†’   (0 15 1 6)
;; checking the result :
<i>(+ 0 ( / ( + 15 (/ ( + 1 ( / ( + 6 0)))))))</i>  â†’   7/111

<i>(define ones (circular-list 1))</i>   â†’   ( 1 1 1 â€¦ âˆ)
<i>(contfract->number ones)</i>  â†’   1.61803398875 ;; 1 + 1 / (1 + 1 / (1 + 1 / ( ...)))
<i>(/ (1+ (sqrt 5)) 2)</i>  â†’   1.61803398875 ;; = (1 + âˆš5)/2 = &Phi; = <span style="color:orange">Golden ratio</span>

<i>(number->contfract (sqrt 2015))</i>  â†’   ( 44 1 7 1 88 1 7 1 88 â€¦ âˆ)
<i>(number->contfract (sqrt 2))</i>  â†’   ( 1 2 2 2 2 â€¦ âˆ)
<i>(number->contfract (sqrt 3))</i>  â†’   ( 1 1 2 1 2 1 2 â€¦ âˆ)

<i>(number->contfract PI 20)</i>  â†’   (3 7 15 1 292 1 1 1 2 1 3 1 14 3 3 23 1 1 7 4 35) ;; PI is transcendant : no periodicity
<i>(convergents (number->contfract PI 20) 10)</i>  â†’   (3 22/7 333/106 355/113 103993/33102 104348/33215 208341/66317 312689/99532 833719/265381) ;; better and better approximations of PI by rationals.

<i>(number->contfract E 16)</i>  â†’   (2 1 2 1 1 4 1 1 6 1 1 8 1 1 10 1 1) ;;  ğŸ© Euler
</pre>


<h3 id="poly">Polynomial</h3>
<p>A polynomial P is a list of coefficients from a<sub>0</sub> - lowest term - to a<sub>n</sub>, the value of which at x is &Sigma; a<sub>i</sub>x<sup>i</sup>. Polynomials can be combined with add, mul and power operations - See <a href="http://rosettacode.org/wiki/AKS_test_for_primes#EchoLisp">Rosetta</a> code for an example.  <br>Use (poly x P) to compute the value of a real polynomial at x (real). Use (cpoly z P) to compute the value of a real or complex polynomial at z (complex).<br>Computation of polynomial is a quick operation, so it is good practice to use them in plotting or other time-consuming functions.
<br>
For example (poly x '(1 2 3 4)) is far better - and shorter - than (+ (* 4 x x x ) (* 3 x x) (* 2 x ) 1) .
</p>

<h4 id='poly->string'>(<b>poly->string </b><i> var-id P</i>) â› string : a<sub>0</sub> + a<sub>1</sub>x + a<sub>2</sub> x^2 + â€¦</h4>
<h4 id='poly->string'>(<b>poly->string </b><i> var-id P Q</i>) â› string : a<sub>0</sub> + a<sub>1</sub>x + a<sub>2</sub> x^2 + â€¦ / b<sub>0</sub> + b<sub>1</sub>x + b<sub>2</sub>x^2 + â€¦</h4>
<h4 id='poly->html'>(<b>poly->html </b><i> var-id P  [Q] </i>) â› string : a<sub>0</sub> + a<sub>1</sub>x + a<sub>2</sub> x<sup>2</sup> + â€¦</h4>
<br>
<h4 id='poly'>(<b>poly </b><i>x P</i>) â› value of real poly P(x) at x</h4>
<h4 id='poly'>(<b>poly </b><i>x P Q</i>) â› value of P(x) / Q(x) at x</h4>
<h4 id='cpoly'>(<b>cpoly </b><i>z Pz</i>) â› value of complex poly P(z) at z</h4>
<h4 id='cpoly'>(<b>cpoly </b><i>z Pz Qz</i>) â› value of P(z) / Q(z) at z</h4>
<br>
<h4 id='poly-add'>(<b>poly-add </b><i>P Q</i>) -> new poly P + Q</h4>
<h4 id='poly-sub'>(<b>poly-sub </b><i>P Q</i>) -> new poly P - Q</h4>
<h4 id='poly-mul'>(<b>poly-mul </b><i>P Q</i>) -> new poly P * Q</h4>
<h4 id='poly-mul-k'>(<b>poly-mul-k </b><i>P k</i>) -> new poly k * P</h4>
<h4 id='poly-pow'>(<b>poly-pow </b><i>P n</i>) -> new poly P<sup>n</sup></h4>
<h4 id='poly-div'>(<b>poly-div </b><i>A B</i>) -> new polys (Q R) such as A = B * Q + R , and R = 0 or  dÂ°(R) < dÂ°(B). </h4>

<pre>
<i>(define P '(1 -3 4 -2))</i>  â›   P
<i>(poly->string 'x P)</i>  â›   "-2x^3 +4x^2 -3x +1 "
<i>(poly->string 'Y P)</i>  â›   "-2Y^3 +4Y^2 -3Y +1 "

<i>(poly 1 P)</i>  â›   0
<i>(poly -1 P)</i>  â›   10
<i>(cpoly I P)</i>  â›   -3-i

<i>(define Q '(3 -3 2))</i>  â›   Q
<i>(poly->string 'x P Q)</i>  â›   "-2x^3 +4x^2 -3x +1 / 2x^2 -3x +3 "
<i>(poly 4 P Q)</i>  â›   -3.260869565217391
<i>(cpoly 0+2i P Q)</i>  â›   0.2459016393442623-2.2950819672131146i

<i>(define P '( 1 2 3 4))</i>  â†’   P
<i>(define Q '(-1 -2 5 -3))</i>  â†’   Q
<i>(poly->string 'x P)</i>  â†’   4x^3 +3x^2 +2x +1 
<i>(poly->string 'x Q)</i>  â†’   -3x^3 +5x^2 -2x -1 

<i>(poly->string 'x (poly-add P Q))</i>  â†’   x^3 +8x^2 
<i>(poly->string 'x (poly-mul P Q))</i>  â†’   -12x^6 +11x^5 +x^4 -3x^3 -2x^2 -4x -1 
<i>(poly->string 'x (poly-mul-k P 1.5))</i>  â†’   6x^3 +4.5x^2 +3x +1.5 

<i>(poly->html 'x (poly-pow Q 7))</i>  â†’
 -2187x<sup>21</sup> +25515x<sup>20</sup> -137781x<sup>19</sup> +451332x<sup>18</sup> -985257x<sup>17</sup> +1472688x<sup>16</sup> -1461558x<sup>15</sup> +812705x<sup>14</sup> +7420x<sup>13</sup> -389200x<sup>12</sup> +252497x<sup>11</sup> -245x<sup>10</sup> -73759x<sup>9</sup> +23898x<sup>8</sup> +9987x<sup>7</sup> -5922x<sup>6</sup> -952x<sup>5</sup> +763x<sup>4</sup> +119x<sup>3</sup> -49x<sup>2</sup> -14x -1

;;; timing
<i>(define (f x) (poly x ' (1 2 3 4)))</i>
<i>(define (g x) (+ (* 4 x x x) (* 3 x x ) (* 2 x ) 1))</i>
<i>(time (for ((i 1000000)) (f i)))</i> â†’ 1276 millisec
<i>(time (for ((i 1000000)) (g i)))</i> â†’ 2159 millisec
</pre>

<h3>Analysis</h3>
<h4>(<b>math-precision</b>) â› &epsilon; value</h4>
<h4 id='math-precision'>(<b>math-precision </b><i>value</i>) â› set &epsilon; value</h4>
<h4 id='approx'>(<b>~=</b> <i>a b</i>) â› #t if |a - b| < &epsilon; , else #f

<h4 id='root'>(<b>root </b><i>f xmin xmax</i>) â› x<sub>0</sub> in [xminâ€¦xmax], |f(x<sub>0</sub>)| &lt; &epsilon; , or null if not found.</h4>
<h4 id='roots'>(<b>roots </b><i>f xmin xmax</i>) â› list of all roots,  (x<sub>i</sub>) in [xminâ€¦xmax], |f(x<sub>i</sub>)| &lt; &epsilon;, or null if none.</h4>
<h4 id='croot'>(<b>croot </b><i>f zmin zmax</i>) â› z<sub>0</sub> in rectangle [zminâ€¦zmax], |f(z<sub>0</sub>)| < &epsilon;</h4>
<h4 id='croots'>(<b>croots </b><i>f zmin zmax</i>) â› list of all complex roots, z<sub>i</sub> in rectangle [zminâ€¦zmax], |f(z<sub>i</sub>)| < &epsilon;</h4>

<h4 id='integrate'>(<b>integrate </b><i>f xmin xmax</i>) â› âˆ« f(x) dx , x in [xminâ€¦xmax]</h4>
<h4 id='deriv'>(<b>deriv </b><i>f x<sub>0</sub></i>) â› f'(x<sub>0</sub>)</h4>

<h4 id='serie'>(<b>serie </b><i>f x nmax</i>) â› &Sigma; x<sup>n</sup> * f(n), n = [0..nmax] </h4>
<h4 id='cserie'>(<b>cserie </b><i>f z nmax</i>) â› &Sigma; z<sup>n</sup> * f(n), n = [0..nmax] </h4>

<pre>
(math-precision) â†’ 0.000001
(~= 1/3 0.333333) â†’ #t
(~= 1/3 0.333)  â†’ #f

<i>(define (f x) (- x (cos x)))</i>  â›   f
<i>(root f 0 1)</i>  â›   0.7390851295647751 ;; cos(x) = x

<i>(define (f z) (- (* z z z) 1))
(croots f -2-2i 2+2i)</i>
	â†’  (-0.499999+0.866023i -0.499999-0.866023i 1-0.000003i)

<i>(integrate sin 0 PI/2)</i>  â›   0.9999999980954222
<i>(integrate identity 0 10)</i>  â›   50

<i>(deriv sin 0)</i>  â›   1.000000000;; sin'(0) = cos(0)
<i>(deriv identity 42)</i>  â›   0.999999993 ;; f'(x) = 1

<i>(define (f n) (// (factorial n)))</i>  â›   f ;; f(n) = 1/n!
<i>(serie f 0.5 100)</i>  â›   1.6487212650 ;; e<sup>0.5</sup>
<i>(math-precision 1e-12)</i>  â›   1e-12
<i>(serie f 0.5 100)</i>  â›   1.6487212707
<i>(sqrt E)</i>  â›   1.6487212707

<i>(cserie f I 100)</i>  â›   0.54030230586+0.841470984807i ;; e<sup>i</sup>
<i>(exp I)</i>  â›   0.540302305868+0.84147098480i

;; check that âˆ«<sub>0,1</sub>x<sup>-x</sup> dx =   âˆ‘<sub>1,âˆ</sub> m<sup>-m</sup>
<i>(define (f x) (// (expt x x)))</i>  â†’  f ;; x<sup>-x</sup>
<i>(- (integrate f 0 1) (sigma f 1 1000))</i>  â†’   -0.00000000000000002
</pre>

<h3>Functions</h3>
<h4 id='gamma'>(<b>gamma </b><i>z</i></b>) â› <a href="https://en.wikipedia.org/wiki/Gamma_function#The_gamma_function_in_the_complex_plane">Gamma</a> function value at z (real or complex) : &Gamma;(z)</h4>
<h4>(<b>standard-normal </b><i>x</i>)  â†’  standard <a href="https://en.wikipedia.org/wiki/Normal_distribution">normal</a> distribution at x. &mu; = 0, &sigma; = 1.</h4>
<h4>(<b>normal </b><i>x  &mu; &sigma;</i>)  â†’  normal distribution</h4>
<h4>(<b>normal-2 </b><i> x y &rho; &mu;<sub>1</sub> &sigma;<sub>1</sub> [&mu;<sub>2</sub> [&sigma;<sub>2</sub>]]</i>) -> normal distribution of (x y). &rho; in [-1 1] is the correlation coefficient. Default for &mu;<sub>2</sub>, &sigma;<sub>2</sub> are &mu;<sub>1</sub> ,&sigma;<sub>1</sub>.</h4>

<pre>
<i>(math-precision 1.e-9)</i> â†’ 1e-9
<i>(integrate standard-normal -10 10)</i> â†’ 1.0000000000228986

<i>(gamma 0.5)</i> â†’ 1.7724538509055159 ; &Gamma;(1/2) = âˆš&Pi;
<i>(sqrt PI)</i> â†’ 1.7724538509055159

<i>(gamma 10)</i> â†’ 362880.0000000015
<i>(factorial 9)</i> â†’ 362880
</pre>

<h3 id="julia">Fractals</h3>
<h4 id='fractal'>(<b>fractal </b><i>z zc n</i>)  iterates n times z = z<sup>2</sup> + zc. â†’ z<sub>n</sub> or Infinity.</h4>
<h4 id='fractal-p'>(<b>fractal-p </b><i>z zc p n</i>) iterates n times z = z<sup>p</sup> + zc. â†’ z<sub>n</sub> or Infinity. </h4>

<pre>
;;A nice  <a href="http://fr.wikipedia.org/wiki/Fractale">Julia</a> set
<i>(lib 'math)</i>
<i>(lib 'plot)</i>
<i>(define zc 0.3+0.5i)</i>
<i>(define (Julie z) (fractal z zc 50))</i>  
<i>(plot-z-mod Julie -2 -2)</i> 

;; Mandelbrot
<i>(define (mset z) (if (= Infinity (fractal 0 z 200)) Infinity z))
(plot-z-arg mset '(-2.5 1) -1.5)</i>
</pre>
<p>
<img src="./images/julia.png" width = 300 height=300 >
&nbsp;
<img src="./images/mandelbrot.png" width = 300 height=300 >
</p>
<h3  id="matrix">Vector operations</h3>
<p>See <a href="#vector">Vector</a> for creating and manipulating vectors. The arguments of dot-product, cdot-product, cross-product must be two vectors. <small>Vector-a,-b are vectors of real numbers. Vector-za, -zb are vectors of real or complex numbers.</small></p>
<h4 id="dot-product">(<b>dot-product </b><i>vector-a vector-b</i>) â› &Sigma; a<sub>i</sub>*b<sub>i</sub>.</h4>
<h4 id="cross-product">(<b>cross-product </b><i>vector-za vector-zb</i>) â› new vector [a<sub>1</sub>*b<sub>2</sub>-a<sub>2</sub>*b<sub>1</sub> 
a<sub>2</sub>*b<sub>0</sub>-a<sub>0</sub>*b<sub>2</sub> 
a<sub>1</sub>*b<sub>0</sub>-a<sub>0</sub>*b<sub>1</sub>].</h4>
<br>
<h4 id="cdot-product">(<b>cdot-product </b><i>vector-za vector-zb</i>) â› &Sigma; za<sub>i</sub>*zb<sub>i</sub>.</h4>
<h4 id="cdot-product*">(<b>cdot-product* </b><i>vector-za vector-zb</i>) â› &Sigma; za<sub>i</sub>*<span style="text-decoration:overline">zb</span><sub>i</sub>.</h4>

<pre>
<i>(lib 'math)</i>
<i>(dot-product #( 1 2) #(3 4))</i>  â†’   11

;;  Let ğŸ“-length (a) = (&Sigma; a<sub>i</sub>*a<sub>i</sub>) <sup>1/2</sup>
<i>(define-syntax-rule (ğŸ“-length a) (sqrt (dot-product a a)))</i>  
<i>( ğŸ“-length #( 3 4))</i>  â› 5

<i>(define x #(+i -i 1))
(cross-product x x)</i>
   â†’ #( 0+0i 0+0i 0+0i)
</pre>

<h3  id="distances">  ğŸ“ Distances in <b>R</b><sup>n</sup></h3>
<p>vector-a, vector-b are vectors of real numbers. a,b,p are real numbers, p > 0 . The <a href="http://en.wikipedia.org/wiki/Distance">triangle inequality</a> holds for norms-1,-2,-inf , and -p if p > 1.</p>

<h4 id="in-interval?"> (<b>in-interval? </b><i>x a b</i>) Is x inside [a .. b] ? â› #t or #f</h4>
<h4 id="in-open-interval?"> (<b>in-open-interval? </b><i>x a b</i>) Is x inside ]a .. b[ ? â› #t or #f</h4>
<br>
<h4 id="pythagore"> (<b>pythagore </b><i>a b</i>) â› (a*a + b*b)<sup>1/2</sup></h4>
<h4 id="distance"> (<b>distance </b><i>xa ya xb yb</i>) â› ((xa-xb)<sup>2</sup> + (ya-yb)<sup>2</sup>)<sup>1/2</sup></h4>
<br>
<h4 id="point-in-disk?"> (<b>point-in-disk? </b><i>x y disk</i>) Is the point (x y) inside the disk <i>disk</i> ? â› #t or #f. A <i>disk</i> is a vector #(x0 y0 R).</h4>
<h4 id="disk-in-disk?"> (<b>disk-in-disk? </b><i>D1  D2</i>) Is the disk D1 inside the disk <i>D2</i> ? â› #t or #f. A <i>disk</i> is a vector #(x0 y0 R).</h4>
<h4 id="rect-in-disk?"> (<b>rect-in-disk? </b><i>rect disk</i>) Is the rectangle <i>rect</i> inside the disk <i>disk</i> ? â› #t or #f. A <i>rectangle</i> is a vector #(x0 y0 width height) where x0,y0 are the top-left corner coordinates.</h4>
<h4 id="rect-disk-intersect?"> (<b>rect-disk-intersect? </b><i>rect disk</i>) Does the rectangle <i>rect</i> intersects the disk <i>disk</i> ? â› #t or #f. </h4>
<br>
<h4 id="norm-1">(<b>norm-1 </b><i>vector-a vector-b</i>) â› &Sigma; | a<sub>i</sub> - b<sub>i</sub>|  : <i>taxicab</i> distance.</h4>
<h4 id="norm-2">(<b>norm-2 </b><i>vector-a vector-b</i>) â› (&Sigma; (| a<sub>i</sub> - b<sub>i</sub>|)<sup>2</sup>) <sup>1/2</sup> : euclidean distance </h4>
<h4 id="norm-p">(<b>norm-p </b><i>vector-a vector-b p </i>) â› (&Sigma; (| a<sub>i</sub> - b<sub>i</sub>|)<sup>p</sup>) <sup>1/p</sup> </h4>
<h4 id="norm-inf">(<b>norm-inf </b><i>vector-a vector-b </i>) â› Max (| a<sub>i</sub> - b<sub>i</sub>|)  â› limit of the above, for p â› âˆ </h4>

<pre>
<i>(pythagore 216 630)</i> â†’ 666 ;; ğŸ© 

;; Let's work in a 100 dimensions space.
<i>(define a (vector-map random (make-vector 100 10)))</i>
<i>(define b (vector-map random (make-vector 100 100)))</i>
<i>(define c (vector-map random (make-vector 100 1000)))</i>

<i>(norm-1 a b)(norm-1 b c)(norm-1 a c)</i> â†’ 4486 47780 51878
<i>(norm-p a b 1.33)(norm-p b c 1.33)(norm-p a c 1.33)</i> â†’ 1536.6049 16197.2366 17459.6099
<i>(norm-2 a b)(norm-2 b c)(norm-2 a c)</i> â†’ 533.5635 5563.5401 5938.744
<i>(norm-inf a b) (norm-inf b c) (norm-inf a c)</i> â†’ 93 954 988

;; Chess - How many moves for a King to go from a1 to h5 ?
<i>(norm-inf #(1 1) #(8 5))</i> â†’ 7

;; Geometry : see <a href= "http://rosettacode.org/wiki/Total_circles_area">Circles area</a>.

</pre>



<h2 id="matrix.lib">2D-arrays and matrices - Matrix.lib</h2>
<p> An array A (n p) is a 2D-table of n rows and p columns. Arrays indices start at 0; A[i,j] is the element - any lisp object - located in i-th row, j-th column. Matrices are arrays of <u>real</u> numbers. Arrays operations also apply to matrices. Arrays are implemented as vectors of vectors (rows). See also <a href="#vlib.lib">typed arrays</a> for fast arrays.
</p>
<div align=center>
    <table class="matrix">
        <tr>
            <td>a <sub>0 0</sub></td>
            <td>a <sub>0 1</sub></td>
            <td>a <sub>0 2</sub></td>
            <td>a <sub>...</sub></td>
            <td>a <sub>0 j</sub></td>
             <td>a <sub>...</sub></td>
            <td>a <sub>0 p-1</sub></td>
        </tr>
        <tr>
            <td>a <sub>1 0</sub></td>
            <td>a <sub>1 1</sub></td>
            <td>a <sub>1 2</sub></td>
          
            <td>a <sub>...</sub></td>
            <td>a <sub>1 j</sub></td>
            <td>a <sub>...</sub></td>
            <td>a <sub>1 p-1</sub></td>
        </tr>
         <tr>
            <td>a <sub>... 0</sub></td>
            <td>a <sub>... 1</sub></td>
            <td>a <sub>... 2</sub></td>
            <td>a <sub>...</sub></td>
            <td>a <sub>... j</sub></td>
             <td>a <sub>...</sub></td>
            <td>a <sub>... p-1</sub></td>
        </tr>
        <tr>
            <td>a <sub>i 0</sub></td>
            <td>a <sub>i 1</sub></td>
            <td>a <sub>i 2</sub></td>
            <td>a <sub>...</sub></td>
            <td>a <sub>i j</sub></td>
            <td>a <sub>...</sub></td>
            <td>a <sub>i p-1</sub></td>
        </tr>
            <tr>
            <td>a <sub>... 0</sub></td>
            <td>a <sub>... 1</sub></td>
            <td>a <sub>... 2</sub></td>
            <td>a <sub>...</sub></td>
            <td>a <sub>... j</sub></td>
            <td>a <sub>...</sub></td>
            <td>a <sub>... p-1</sub></td>
        </tr>
         <tr>
            <td>a <sub>n-1 0</sub></td>
            <td>a <sub>n-1 1</sub></td>
            <td>a <sub>n-1 2</sub></td>
            <td>a <sub>...</sub></td>
            <td>a <sub>n-1 j</sub></td>
            <td>a <sub>...</sub></td>
            <td>a <sub>n-1 p-1</sub></td>
        </tr>
    </table>
</div>
<br>
<br>
<h4 id='make-array'>(<b>make-array </b><i>n p</i>) â†’ new array (n p) initialized to 0</h4>
<h4 id='build-array'>(<b>build-array </b><i>n p proc:2:2</i>) â†’ new array (n p) such as a<sub>ij</sub> = (proc i j)</h4>
<h4 id='vectorâ†’array'>(<b>vectorâ†’array </b><i>V n p</i>) â†’ new array (n p) filled - rows first - with successive elements of V</h4>
<h4 id='list->array'>(<b>list->array </b><i>list n p</i>) â†’ new array (n p) filled - rows first - with successive elements of <i>list</i></h4>
<h4 id='array-copy'>(<b>array-copy </b><i>A</i>) â†’ shallow copy of A</h4>
<br>
<h4 id='array-ref'>(<b>array-ref </b><i>A i j</i>) â†’ A<sub>ij</sub></h4>
<h4>(<b>A</b> i j</i>) â†’ A<sub>ij</sub> <small>Short-cut for fast access.</small></h4>
<br>
<h4 id='array-set!'>(<b>array-set! </b><i>A i j value</i>) â†’ A<sub>ij</sub> := <i>value</i></h4>
<h4 id='array-row'>(<b>array-row </b><i>A i</i>) â†’ row vector<sub>i</sub></h4>
<h4 id='array-col'>(<b>array-col </b><i>A j</i>) â†’ column vector<sub>j</sub></h4>
<h4 id='array-set-row!'>(<b>array-set-row! </b><i>A i vector[p]</i>) â†’ sets row vector<sub>i</sub></h4>
<h4 id='array-set-col!'>(<b>array-set-col! </b><i>A j vector[n]</i>) â†’ sets column vector<sub>j</sub></h4>
<br>
<h4 id='array-map'>(<b>array-map </b><i>proc:1:1 A</i>) â†’ new array B such as  B<sub>ij</sub> = (proc A<sub>ij</sub>)</h4>
<br>
<h4 id='array-print'>(<b>array-print </b><i>A</i>) â†’ prints A on stdout, in tabular format</h4>
<h4 id='array->html'>(<b>array->html </b><i>A</i>) â†’ html source string : "&lt;table class='matrix'&gt; .... &lt;/table&gt;" filled with array contents.</h4>

<h3>Matrices</h3>
<h4 id='matrix-row-num'>(<b>matrix-row-num </b><i>M</i>) â†’ n = number of rows</h4>
<h4 id='matrix-col-num'>(<b>matrix-col-num </b><i>M</i>) â†’ p = number of columns</h4>
<h4 id='matrix-ref'>(<b>matrix-ref </b><i>M i j</i>) â†’ M<sub>ij</sub> (<small>synonym of array-ref</small>)</h4>
<h4 id='matrix-set!'>(<b>matrix-set! </b><i>M i j value</i>) â†’ M<sub>ij</sub> := <i>value</i> (<small>synonym of array-set!</small>)</h4>
<br>
<h4 id='matrix-transpose'>(<b>matrix-transpose </b><i>M </i>) â†’ new matrix T (p n), T<sub>ji</sub> = M<sub>ij</sub></h4>
<h4 id='matrix-mult'>(<b>matrix-mult </b><i>M<sub>np</sub> N<sub>pq</sub></i>) â†’ new matrix P<sub>nq</sub> = M * N</h4>
<h4 id='matrix-add'>(<b>matrix-add </b><i>M<sub>np</sub> N<sub>np</sub></i>) â†’ new matrix P<sub>np</sub> = M <big>+</big> N</h4>
<br>
<h4 id='matrix-swap-rows!'>(<b>matrix-swap-rows! </b><i>M i k</i>) â†’ swaps rows i & k inside M .</h4>
<br>
<h4 id='matrix-solve'>(<b>matrix-solve </b><i> M<sub>nn</sub></i> A<sub>nh</sub></i>) â†’ matrix X<sub>nh</sub> such as M * X = A. <small>Uses LU-decomposition</small>.</h4>
<h4 id='matrix-invert'>(<b>matrix-invert </b><i> M<sub>nn</sub></i>) â†’ matrix M<sup>-1</sup><sub>nn</sub> such as M * M<sup>-1</sup> = Id<sub>nn</sub>.</h4>
<br>
<h4 id='matrix-lu-decompose'>(<b>matrix-lu-decompose </b><i> M<sub>nn</sub></i>) â†’ list of three matrices (P<sub>nn</sub> U<sub>nn</sub> L<sub>nn</sub> ) such as P * M = L * U, P is a permutation matrix, U and L are upper and lower matrices.</h4>
<h4 id='determinant'>(<b>determinant </b><i>M<sub>nn</sub></i>) â†’ | M |</h4>

<pre>
(lib 'matrix)
;; See <a href="http://rosettacode.org/wiki/Cramer's_rule#EchoLisp">Cramer's rule</a>.
</pre>


<h2 id="bigint.lib">Bigint.lib</h2>
<p>To perform integer operations on "large"integers, &gt 1.e+9 . âŒšï¸ Operations may run in the background âŒšï¸ </p>
<pre>
<i>(lib 'bigint)</i>
<span style="color:green">Lib: bigint.lib loaded.</span>

<i>(* 123456789123456789 987654321987654321)</i>  
	â†’   121932631356500531347203169112635269
<i>(factorial 1000)</i>  
	â†’   4023872600770937735437024339230039857193748642107â€¦.000000
<i>(next-prime 1.e+20)</i>  â†’   100000000000000000039
<i>(random-prime 1.e+100)</i> 
	â†’ 	24094786158894049197303â€¦.6227618797581442571432539758128420365365478139
	
<i>(prime? (1+ (factorial 115)))</i>  â†’   #f
<i>(prime? (1+ (factorial 116)))</i>  â†’   #t

<i>(prime? 32561123834332170080737147)</i>  â†’   #f
<i>(factor 32561123834332170080737147)</i>  â†’   ;; background operations
â³ factorizing â€¦ 3%
â³ factorizing â€¦ 7%
â³ factorizing â€¦ 11%
(factor 32561123834332170080737147) â› 8404620944833
</pre>


<h2 id = 'sequences.lib'> Sequences.lib : Procrastinators - Iterators - Generators - Sequences</h2>

<h3 id = 'procrastinator'>Procrastinators</h3>
<p>Procrastinators are lazy objects with an internal state (state <i>procrastinator</i>), which wait for a <b>next</b> call to return a value and change their state. Sub-classes of procrastinators are : iterators, sequences, generators, combinators, ... One may iterate over procrastinators with the usual list <a href="#maps">iteration</a> functions : map, fold, every, any, for, <a href="#mean">mean</a>, etc. Procrastinators may generate an infinite set of values. Procrastinators do auto-evaluate.
<br>
(take <i>procrastinator</i> n) will be used to get the first n values of a procrastinator. The state of a procrastinator only changes when calling explicitly (next). Other functions (map, append, ...) do not change the state. Procrastinators may be used as iterators in <b>for</b> loops : (for ((g <i>procrastinator</i>) ...). 
<br>
See <a href = "http://rosettacode.org/wiki/Catalan_numbers#EchoLisp">Catalan numbers</a> in Rosetta code for examples of use.
<br>
<pre>
;; sum of the 10  first even squares
;; the first operante is the infinite sequence [0 1 2 ...]
;; the <a href="#pipeline">pipeline</a> , map, filter, and take operators apply to  infinite sequences.
( ->> [0 ..] (map * _ _ )  (filter even?) (take 10) (apply +))
    â†’ 1140
</pre>

<br>
<center>
NB: the following functions apply to all sub-classes of procrastinators.
</center>
<br>

<h4 id='procrastinator?'>(<b>procrastinator? </b><i>obj</i>) â†’ #t if <i>obj</i> is a procrastinator, else #f</h4>
<h4 id='procrastinator'>(<b>procrastinator </b><i>list|vector</i>) â†’ new procrastinator from <i>list</i> or <i>vector</i></h4>
<h4 id='dup'>(<b>dup </b><i>procrastinator</i>) â†’ new procrastinator, duplicate of initialized <i>procrastinator</i>. </h4>
<small><h4 id='init'>(<b>init </b><i>procrastinator</i>) â†’ re-initializes <i>procrastinator</i></h4></small>
<br>
<h4 id='next'>(<b>next </b><i>procrastinator</i>) â†’ next value or #f if no more values. <small>Changes the procrastinator state.</small></h4>
<h4 id='take'>(<b>take </b><i>procrastinator n</i>) â†’ list of n first values. <small>For compatobility reasons (take object n) may be written as (take n object).</small></h4>
<h4 id='take'>(<b>take </b><i>procrastinator #:all</i>) â†’ list of all values</h4>
<h4 id='drop'>(<b>drop </b><i>procrastinator n</i>) â†’ new procrastinator , duplicate of <i>procrastinator</i> , after dropping the n first values</h4>
<br>
<h4 id='head'>(<b>head </b><i>procrastinator</i>) â†’ first returned value = (nth <i>procrastinator</i> 0) </h4>
<h4 id='tail'>(<b>tail </b><i>procrastinator</i>) â†’ new procrastinator - rest - , skipping the first value of <i>procrastinator</i>. </h4>
<br>
<h4 id='nth'>(<b>nth </b><i>procrastinator n</i>) â†’ nth value, or #f. <small>Calls (next) n + 1 times</small></h4>
<p>
The following functions behave like their <i>list</i> equivalent. They all stop enumerationg when (next ...) return #f.<small> They may not return - endless loop - if the procrastinator has an infinite set of values.</small>
</p>
<h4 id='length'>(<b>length </b><i>procrastinator</i>) â†’ number of values to return before #f, or Infinity.</h4>
<br>
<h4 id='append'>(<b>append</b> <i>p<sub>1</sub> p<sub>2</sub></i></i>) â†’ new procrastinator, delivering the contents of p<sub>1</sub>, then the contents of p<sub>2</sub> </h4>
<h4 id='filter'>(<b>filter </b><i>proc:1:1 procrastinator</i>) â†’ new procrastinator from <i>procrastinator</i>, returning only values such as (proc value) = #t</h4>
<br>
<h4 id='for-each'>(<b>for-each </b><i>proc:1:1 procrastinator</i>) â†’  calls (proc (next <i>procrastinator</i>)) until #f. Returns void. </h4>
<h4 id='for-each'>(<b>for-each </b><i>proc:2:2 p<sub>1</sub> p<sub>2</sub></i></i>) â†’ calls (proc (next <i>p<sub>1</sub></i> )  (next <i>p<sub>2</sub></i> )) until p1 or p2 exhausted. returns void.</h4>
<br>
<h4 id='map'>(<b>map </b><i>proc:1:1 procrastinator</i>) â†’ new procrastinator, returning (proc (next <i>procrastinator</i>)). </h4>
<h4 id='map'>(<b>map </b><i>proc:2:2 p<sub>1</sub> p<sub>2</sub></i></i>) â†’ new procrastinator, returning (proc (next <i>p<sub>1</sub></i> )  (next <i>p<sub>2</sub></i> )) ... )</h4>
<br>

<h4 id='foldl'>(<b>foldl </b><i>proc:2:2 acc procrastinator</i>)  fold left â†’ sets acc to (proc (next <i>procrastinator</i> acc)) until exhausted. Returns acc.</h4>
<h4 id='foldl'>(<b>foldl </b><i>proc:3:3 acc p<sub>1</sub> p<sub>2</sub></i>) â†’ sets acc to (proc (next <i>p<sub>1</sub></i>) (next <i>p<sub>2</sub></i>) acc) until p<sub>1</sub> or p<sub>2</sub> exhausted. Return acc.</h4>
<br>
<h4 id='scanl'> (<b>scanl</b><i> proc:2:2 acc<sub>0</sub> p<sub>1</sub></i>)  scan left â†’ new list or procrastinator accumulating intermediate results :  (acc<sub>0</sub>,  acc<sub>1</sub> = (proc (next p<sub>1</sub>) acc<sub>0</sub>), ... acc<sub>n</sub> = (proc (next p<sub>1</sub>) acc<sub>n-1</sub>)).</h4>
<br>
<h4 id='scanl'> (<b>scanl</b><i> proc:3:3 acc<sub>0</sub> p<sub>1</sub> p<sub>2</sub></i>)  â†’  new list or procrastinator accumulating intermediate results :  (acc<sub>0</sub>,  acc<sub>1</sub> = (proc (next p<sub>1</sub>) (next p<sub>2</sub>) acc<sub>0</sub>), ... acc<sub>n</sub> = (proc (next p<sub>1</sub>) (next p<sub>2</sub>) acc<sub>n-1</sub>)).</h4>
<pre>
<i>(scanl + 42 (iota 7))</i>  â†’   (42 42 43 45 48 52 57 63) ;; scanl of  a list
<i>(take (scanl + 42 [0 .. 1000000000]) 8)</i>  â†’   (42 42 43 45 48 52 57 63) ;; scanl of a lazy sequence
</pre>
<p>
The following functions will take procrastinators (= sequences, maps, filters, ..), or lists or vectors - which are converted into procrastinators -  as arguments. They all stop enumerationg when (next ...) returns #f.
</p>
<h4 id='take/when'>(<b>take/when </b><i> pred:1:1 procrastinator n</i>) â†’ list of first values - at most n -  such as (pred value) is #t</h4>
<h4 id='take/while'>(<b>take/while </b><i>pred:1:1 procrastinator n</i>) â†’ list of first consecutive values - at most n - such as (pred value) is #t. </h4>
<h4 id='drop/while'>(<b>drop/while </b><i>pred:1:1 procrastinator n</i>) â†’ new procrastinator, after dropping at most n consecutive values such as (pred value) is #t.</h4>
<br>
<h4 id='sum'>(<b>sum </b><i>procrastinator [n]</i>) â†’ sum of n first values. Default for n is Infinity (all)</h4>
<h4 id='sum/when'>(<b>sum/when </b><i>pred:1:1 procrastinator [n]</i>) â†’ sum of first n values such as (pred value) = #t. Default for n is Infinity (all).</h4>
<br>
<h4>(<b>min </b><i>procrastinator </i>) â†’ min of values. </h4>
<h4>(<b>max </b><i>procrastinator </i>) â†’ max of values. </h4>

<h3 id = "kons">Lazy lists</h3>
<p>Lazy lists are made of a head - first - element, and a tail - rest - expression. The tail expression is <a href="#delay">delayed</a>, not evaluated until needed, and must evaluate to a list or procrastinator object. The <b>kons</b> operator is the lazy sequences constructor. (kons <i>first</i> <i>rest-expression</i>) is the equivalent of (cons <i>first</i> <i>rest</i>) for lists.
<br>
The infix operator <b>:</b> may be used in place of <b>kons</b>. (a : b) is the same as (kons a b).
<h4 id = "kons">(<b>kons </b><i> first rest-expression</i>) â†’ new lazy list. <i>rest-expression</i> is not (yet) evaluated.</h4>
<h4>(<i>first</i> <b>:</b> <i>rest-expression</i>)  â†’ same as above.

<pre>
<i>(define ints (1 : (map 1+ ints)))</i>  â†’ ints
<i>(take ints 10)</i>
    â†’ (1 2 3 4 5 6 7 8 9 10)
<i>(take (drop ints 8) 10)</i>
    â†’ (9 10 11 12 13 14 15 16 17 18)
(length ints) â†’ Infinity

<i>(define fibs (0 : 1 : (map + fibs (tail fibs))))</i>  â†’ fibs
<i>(take fibs 12)</i>
    â†’ (0 1 1 2 3 5 8 13 21 34 55 89)
<i>(nth fibs 20)</i>
    â†’ 6765
    
<i>(define facts (1 : (map * ints facts)))</i> â†’ facts
<i>(take facts 10)</i>
    â†’ (1 1 2 6 24 120 720 5040 40320 362880)
<i>(factorial 10)</i>
    â†’ 3628800
</pre>


<h3 id = "sequences">Sequences</h3>
<p>Sequences are finite or infinite intervals of integer, rational or real numbers. They are defined by their first , second  - by default = first +/- 1 - and last terms (which may be Infinity). The last term returned is such as (first + k*step) < last for an increasing sequence, (first + k*step) > last for a decreasing sequence (step < 0).
<br>
Sequences are defined by the (sequence ...) function, or by the <b>..</b> infix operator.
</p>
<h4>[start ..] â†’  new  sequence [start start+1 .. Infinity[</h4>
<h4>[start second ..] â†’  new sequence [start start+step .. Infinity[ , with step = second - first.</h4>
<h4>[start .. last] â†’ new  sequence [start start+1 .. last[. <small>Same as (sequence start last)</small></h4>
<h4>[start second .. last] â†’  new sequence [start start+step .. last[ , with step = second - first. <small>Same as (sequence start second last)</small></h4>
<pre>
<i>(take [1 3 .. 10] #:all)</i>    â†’ (1 3 5 7 9)
<i>(for ((n [ 5 10 .. 60])) (write n))</i>    5 10 15 20 25 30 35 40 45 50 55 

<i>(length [0 0 ..])</i>  â†’   Infinity
<i>(length [1 3 .. 100])</i>  â†’   49

<i>(sum [1 2 .. 100])</i>  â†’   4950

<i>(take (map * [1 ..] [10 ..]) 12)</i>  â†’   (10 22 36 52 70 90 112 136 162 190 220 252)
</pre>

<h3 id = "sequences">Strings sequences</h3>
<h4>[from-string .. to-string]  â†’ new  string-sequence [<i>from-string</i> .. <i>to-string</i>]. <small>Same as (sequence from-string to-string)</small>.
<pre>

<i>(take ["a" .. "z"] 10)</i>
    â†’ ("a" "b" "c" "d" "e" "f" "g" "h" "i" "j")
    
<i>(define strseq ["ab" .. "xy"]) â†’ #string-sequence [ab .. xy]
(take strseq #:all)</i>
  â†’ ("ab" "bb" "cb" "db" "eb" "fb" "gb" [ ... ] "rb" "sb" "tb" "[ .. ]" "xx" "ay" "by" "cy" "dy" "ey" "fy" "gy" "hy" "iy" "jy" "ky" "ly" "my" "ny" "oy" "py" "qy" "ry" "sy" "ty" "uy" "vy" "wy" "xy")
</pre>


<h3 id = 'iterators'> Iterators </h3>
<p> Iterators generate (infinite) sequences from a function with one argument. The defining function f of an iterator/n is automatically equipped with a cache, if not already present : see (<a href="#remember">remember</a> f).
</p>
<h4 id='iterator/n'>(<b>iterator/n </b><i>f:1:1 n0</i>) â†’ new iterator returning f(n0), f(n0+1), f(n0+2) .... stops whenever f() returns #f</h4>
<br>
<h4 id='iterator/f'>(<b>iterator/f </b><i>f:1:1 seed</i>) â†’ new iterator returning: seed, (f seed), (f(f seed)), (f(f(f seed))), ... stops whenever f() returns #f</h4>
<br>
<h4 id='iterator->list'>(<b>iterator->list </b><i>iterator</i>) â†’ new list of all values returned by (next <i>iterator</i>). Same as (take <i>iterator</i> Infinity), but truncated if <i>iterator</i> is infinite.


<pre>
(define (f n) (/ (* n n n n))) ;; 1/ n<sup>4</sup>
(define seq (iterator/n f 1))  ;; iterator, starts at n=1

(next seq) â†’ 1
(next seq) â†’ 1/16
(next seq) â†’ 1/81

(take seq 8)
   â†’ (1 1/16 1/81 1/256 1/625 1/1296 1/2401 1/4096)
   
(sum (take seq 1000)) â†’ 1.082323233378306 ;; sum of 1000 first terms
(// (* PI PI PI PI) 90) â†’ 1.082323233711138 = &pi;<sup>4</sup>/90

(scanl + 0 (take seq 10)) ;; intermediate sums
    â†’ (0 1 17/16 1393/1296 22369/20736 14001361/12960000 1.0811235339506173 1.0815400270784807 1.0817841677034807 1.0819365834937567 1.0820365834937566)
    
;; iterator/f
;; See <a href="http://rosettacode.org/wiki/Hailstone_sequence#EchoLisp">Collatz</a> sequence.
</pre>

<h3 id = "indices">Indices</h3>
<p>Given a vector of integer dimensions #(d<sub>0</sub> d<sub>1</sub> d<sub>2</sub> ..), returns all vector indices #(i<sub>0</sub> i<sub>1</sub> i<sub>2</sub> ..) such as 0 <= i<sub>k</sub> < d<sub>k</sub>.
</p>
<h4 id='indices'>(<b>indices </b>dimensions-vector</i>) â†’ new procrastinator returning  #(i<sub>0</sub> i<sub>1</sub> i<sub>2</sub> ..).   </h4>

<pre>
<i>(define indy (indices #(3 2 4)))</i>  â†’   indy
<i>indy</i>  â†’   #indices: #( 0 0 0) dims: #( 3 2 4)
<i>(length indy)</i>  â†’   24
<i>(head indy)</i>  â†’   #( 0 0 0)
<i>(tail indy)</i>  â†’   #indices: #( 0 0 1) dims: #( 3 2 4)
<i>(for [(K indy)] (write K))</i>
    â†’ #( 0 0 0) #( 0 0 1) #( 0 0 2) #( 0 0 3) #( 0 1 0) ... #( 2 1 2) #( 2 1 3) 
</pre>

<h3 id = "combinator">Combinators</h3>
<p>Combinators require the list library : (lib 'list).
</p>
<h4 id='powerset'>(<b>powerset </b>list</i>) â†’ new combinator returning all subsets of <i>list</i>. <small>2<sup>(length list)</sup> subsets</small></h4>
<pre>
(define pwa (powerset ' ( a b c d e f )))
(length pwa)
    â†’ 64
(take pwa 7)
    â†’ (() (a) (b) (a b) (c) (a c) (b c))
    
(define pwb (powerset (iota 30)))
(length pwb)
    â†’ 1073741824
</pre>
<h4 id='combinator'>(<b>combinator </b>list k</i>) â†’ new combinator returning all combinations of k items among <i>list</i> elements</h4>
<h4 id='combinator/rep'>(<b>combinator/rep </b>list k</i>) â†’ new combinator returning all combinations - with repetitions -  of k items among <i>list</i> elements. <small> k may be > (length <i>list</i>)</small></h4>


<pre>
(lib 'list)
(lib 'sequences)

<i>(take (combinator (iota 5) 3) #:all)</i>
    â†’ ((0 1 2) (0 1 3) (0 1 4) (0 2 3) (0 2 4) (0 3 4) (1 2 3) (1 2 4) (1 3 4) (2 3 4))
    
<i>(for ([c (combinator/rep '( a b c) 4] [i 100]) (writeln i c))</i>
0     (a a a a)    
1     (a a a b)    
2     (a a a c)    
3     (a a b b)    
[...]
13     (b c c c)    
14     (c c c c)     
</pre>

<h3 id = 'generators'>Generators</h3>

<p>A generator is build upon a state based procedure - <i>gen-proc</i> which takes a state in input, yields one or several values, and returns either #f - no more values - or the next generator state.</p>

<h4 id='make-generator'>(<b>make-generator </b><i>gen-proc:1 init-state</i>) â†’ new generator, with procedure <i>gen-proc</i> and initial state <i>init-state</i>.</h4>
<h4 id='next'>(<b>next </b><i>generator</i>) â†’ runs - in loop fashion - the generator procedure until next yield, and get next value from the generator.</h4>
<br>
<h4 id='yield'>(<b>yield </b><i>value</i>) stops the generator execution, and returns control and value back to the caller, which is a (next) call.</h4>

<pre>
(define (dups n) ;; n is current state
		(yield n) ;; next value
		;; execution stopped here - wait for (next)
		(yield n)  ;; next value
		;; execution stopped here - wait for (next)
		(set! n (+ 3 n)) 
		n) ;; set next state and loop

(define gegen (make-generator dups 17)) ;; init state 17

(next gegen) â†’ 17
(next gegen) â†’ 17
(next gegen) â†’ 20

(take gegen 10) â†’ (17 17 20 20 23 23 26 26 29 29)

(for ((i 5) (g gegen)) (write (cons i g)))
     â†’  (0 . 17) (1 . 17) (2 . 20) (3 . 20) (4 . 23) 

</pre>

<h2 id= 'tasks.lib'>Tasks.lib</h2>
<h3>Tasks</h3>
<p>
Tasks are procedures with a state, which execute in parallel in the background. The task manager endlessly calls the task-procedures, wich return either #f = stop the task, or the next state for the next procedure call. Task-procedures may signal events to other tasks, They are not interruptible, except by (sleep) or (wait) operations. Inside a task-procedure, the symbol _TASK refers to the current task.
<br>Task manager pseudo code :
</p>
<pre>
   (define (my-task-proc state) |# do someting #| new-state) ;; return new state
   
   (for each-task ;; parallel execution
   		(while (task-state task) ;; stop if #f returned
   			   (set-state! task (my-task-proc (task-state task)))
   		       (idle task-idle-time)))
   			
</pre>
<h4 id='make-task'>(<b>make-task </b><i>task-proc:1 init-state</i>) -> new task, with procedure <i>task-proc</i> and initial state <i>init-state</i>. <small>NB. The task is waiting to be run</small></h4>
<h4 id='task-run'>(<b>task-run </b><i>task [msec]</i>) -> run or restart a task with idle time <i>msec</i> or 1000 (default) .</h4>
<h4 id='task-stop'>(<b>task-stop </b><i>task</i>) -> stops the task, as soon as <i>task-proc</i> returns.</h4>
<h4 id='task-stop-all'>(<b>task-stop-all </b>) -> stops all running tasks. Same as <b>CTRL-C</b> key.</h4>
<br>
<h4 id='state'>(<b>state </b><i>task</i>) -> returns the task state.</h4>

<pre>
(lib 'tasks.lib)

<i>(define (tprime pnext) ;; task-procedure
	(set! pnext (next-prime pnext))
	(writeln 'next-prime= pnext)
	pnext) ;; return next state

(define task-primes (make-task tprime 1000000001))
(task-run task-primes)</i>
    â†’ #task:id:500:running
next-prime=     1000000007    
next-prime=     1000000009    
next-prime=     1000000021    
....  ;; CTRL-C to stop
*stopped*
(task-state task-primes)
    â†’ 1000000093


<i>(define (tprint line ) ;; task-procedure
	(writeln _TASK line)
	#f )</i> ;; runs only one time

<i>(for-each task-run 
	(map (curry make-task tprint) 
			'(Enjoy EchoLisp tasks )))</i>

#task:id:496:running     EchoLisp    
#task:id:495:running     Enjoy    
#task:id:497:running     tasks    
</pre>

<h3 id='semaphores'>Semaphores</h3>
<p>Tasks use semaphores, as depicted in this <a href="http://greenteapress.com/semaphores/downey08semaphores.pdf">book</a>, to synchronize, make mutual exclusions, wait for another task signal, etc. Wait, signal and sleep operations may be called anywhere from the task procedure.<small> NB: and NOT from a procedure called by the task-procedure</small>
<br>
A queue (FIFO) of messages may be associated with a semaphore, and accessed witth push/pop operations.
</p>
<h4 id='make-semaphore'>(<b>make-semaphore </b><i>init-count</i>) -> new semaphore with count <i>init-count</i></h4>
<br>
<h4 id='semaphore-empty?'>(<b>semaphore-empty? </b><i>semaphore</i>) -> #t is the semaphore message queue is empty, else #f.</h4>
<h4 id='semaphore-push'>(<b>semaphore-push </b><i>semaphore message</i>) -> push (FIFO style) message onto the semaphore queue.</h4>
<h4 id='semaphore-pop'>(<b>semaphore-pop </b><i>semaphore</i>) -> #f is the semaphore message queue is empty, else deletes first message from queue, and returns it.</h4>

<br>
<h4 id='wait'>(<b>wait </b><i>semaphore</i>) -> decrements semaphore count. If < 0, sets the caller task waiting for <i>semaphore</i>.</h4>
<h4 id='signal'>(<b>signal </b><i>semaphore</i>) -> increments semaphore count. Awakes one of the tasks waiting for <i>semaphore</i> , if any.</h4>
<br>
<h4 id='sleep'>(<b>sleep </b><i>msec</i>) -> sets the calling task sleeping during <i>msec</i> milli-seconds</h4>

<pre>
</pre>


<h2 id="timer.lib">Timer.lib</h2>
<p>A sound is one of the symbols: <b> ok, ko, tick, tack, woosh, beep, digit </b>.</p>
<h4 id='blink'>(<b>blink</b>) -> changes color of blink indicator</h4>
<h4 id='play-sound'>(<b>play-sound </b><i>sound-id</i>) -> plays a sound</h4>
<br>
<h4 id='at-every'>(<b>at-every </b><i>interval timer-proc-id</i>) -> calls (timer-proc t), every <i>interval</i> milli-seconds ;  t is the current time - milli-seconds ; stops when timer_proc returns #f or user presses CTRL-C ; </h4>
<h4 id='wait'>(<b>wait </b><i>duration timer-proc-id</i>) -> calls (timer-proc), after <i>duration</i> milli-seconds </h4>
<br>
<h4 id='at'>(<b>at </b><i>date alert-proc-id</i>) -> calls once alert-proc when (current-date) > <i>date</i></h4>
<h4 id='at'>(<b>at </b>[<i>multiplier</i>] <i>unit-name alert-proc-id</i>) -> calls once alert-proc at (now + multiplier * unit). See <a href="#date">date</a> for units (day, jour, etc.).
<p> ğŸ’¾ Future alerts and delays are saved in local storage, into the system.calendar global variable. Hitting CTRL-C stops any running (at-every â€¦) operation. Alert-proc is a procedure of 0 argument, or a string to display.</p>

<pre>
<i>(lib 'timer.lib)</i>
<span style="color:green">Lib: timer.lib loaded.</span>

<i>(define (metronom) (blink) (play-sound 'tack))
(at-every 1000 'metronom)</i>

<i>(list->stack '(ok ko tick tack woosh beep digit) 'sounds)</i>  â†’   sounds
<i>(define (play-list n) ;; return #f to stop
	(writeln n) 
	(when (stack-top 'sounds) (play-sound (pop 'sounds))))</i>  â†’   play-list
<i>(at-every 3000 'play-list)</i>  

<i>(at (current-date) " ğŸ COFFEE TIME")</i>  â†’   "17/4/2015 18:08:24"
<span style="color:blue">17/4/2015 18:08:24 : ğŸ COFFEE TIME</span>

<i>(at (date 2016 1 1) " ğŸ”” HAPPY NEW YEAR")</i> 
<i>system.calendar</i>  â†’   ((Fri Jan 01 2016 00:00:00 GMT+0100 (CET) " ğŸ”” HAPPY NEW YEAR"))

;; one hour timer
<i>(define (alert) (play-sound 'beep) (display "CALL ELVIS" "color:red"))</i>  â†’   alert
<i>(at 1 'hour 'alert)</i>  â†’   "17/4/2015 19:14:23"

;;procrastination
(at 'demain "Aller Ã  la banque")  â†’ "19/5/2015 11:33:50"
(at "13/11/2016" "happy birthday")

<i>system.calendar</i>  â†’   ((Fri Apr 17 2015 19:14:23 GMT+0200 (CEST) alert) (Fri Jan 01 2016 00:00:00 GMT+0100 (CET) " ğŸ”” HAPPY NEW YEAR"))
</pre>



<h2 id="web.lib">Web.lib</h2>
<h4 id='send-mail'>(<b>mail </b><i>address-string subject-string expr</i>) -> send mail</h4>
<br>
<h4 id='string->url'>(<b>string->url </b><i>string</i>) â› url encoding for string</h4>
<h4 id='open-url'>(<b>open-url </b><i>url-string</i>) â› open page (or Tab)</h4>
<h4 id='oeis'>(<b>oeis </b><i>list-of-integers</i>) â› look-up in the On-line Encyclopedia of Integer Sequences</h4>
<h4 id='oeis'>(<b>oeis </b><i>string</i>) â› look for sequence or author name in the OEIS
<h4 id='inverter'>(<b>inverter </b><i>a-number</i>) â› look-up in Simon Plouffe's inverter</h4>

<pre>
<i>(lib 'web)</i>
<span style="color:green">Lib: web.lib loaded.</span>

<i>(mail 'georges.brougnard@echolalie.com "my primes" (primes 100))</i>

<i>(open-url (string->url "https://www.google.fr/?gws_rd=ssl#q=echolisp"))</i>  
	â†’   "https://www.google.fr/?gws_rd=ssl#q=echolisp"

<i>(define p2n-pn 
	(map (lambda (n) (- (nth-prime (* n 2)) (nth-prime n))) 
	(range 1 10)))</i>  â†’   p2n-pn
<i>p2n-pn</i>  â†’   (1 4 8 12 18 24 26 34 38)

<i>(oeis p2n-pn)</i>   â†’  

<img src="./images/oeis.png" style="border:1px solid">

<i>(define X 5.859874482048838 </i>  â†’   X
<i>(inverter X)</i> 
 
 <img src="./images/inverter.png" style="border:1px solid">
 
<i>(lib 'bigint.lib)</i>
<i>(lib 'web.lib)</i>

<i>(define mynumber 2305843009213693951)</i>  â›   mynumber
<i>(prime? mynumber)</i>  â›   #t
<i>(log2 (1+ mynumber))</i>  â›   61
<i>(1- (expt 2 61))</i>  â›   2305843009213693951 ;; 2<sup>61</sup>-1

<i>(info 'mynumber "Mersenne prime")</i>  â›  mynumber
<i>(info 'mynumber)</i>  â›   "Mersenne prime"

<i>(info 'mynumber "http://www.mersenne.org/primes/")</i>  â›   mynumber
<i>(open-url (info 'mynumber))</i>  â›   "http://www.mersenne.org/primes/"

<img src = "./images/mersenne.jpg" width="600" height="300" alt="GIMPS primes">
</pre>


<h2 id="json.lib">JSON lib</h2>
<p>To import/export data formatted according to the <a href="http://www.json.org/">JSON</a> data-interchange language. 
<br>The top-level function are <b>export-json</b> - serialize lisp object to JSON string - and <b>json-import</b> from JSON string to lisp object.
</p>

<h4 id='json-import'>(<b>json-import </b><i>JSON-string</i>) -> parses input <i>JSON-string</i> and returns a lisp object</h4>
<h4 id='export-json'>(<b>export-json</b> </i>lisp-obj</i>) -> stringifies <i>lisp-obj</i> and returns a JSON string</h4>
<br>
<pre>
;; JSON standard types : strings, numbers, and arrays (vectors)
<i>(export-json #(6 7 8 9))</i>  â†’   "[6,7,8,9]"
<i>(export-json #("alpha" "beta" "gamma"))</i>  â†’   "["alpha","beta","gamma"]"

<i>(json-import "[6,7,8,9]")</i>  â†’   #( 6 7 8 9)
<i>(json-import #<< ["alpha","beta","gamma"] >>#)</i>  â†’   #( "alpha" "beta" "gamma")

;; EchoLisp types : dates,rational,complex, big int
<i>(export-json 3/4)</i>  â†’   "{"_instanceof":"Rational","a":3,"b":4}"
<i>(json-import #<< {"_instanceof":"Rational","a":666,"b":42} >>#)</i>  â†’   111/7

;; Symbols
<i>(export-json 'Simon-Gallubert)</i>  
    â†’   "{"_instanceof":"Symbol","name":"Simon-Gallubert"}"
<i>(json-import #<< {"_instanceof":"Symbol","name":"Antoinette-de-Gabolde"} >>#)</i>  
    â†’   Antoinette-de-Gabolde
    
;; Lists
<i>(define my-list 
    (export-json '( 43 4 5 ( 6 7 ( 8 9 )))))</i>
    â†’    "{"_instanceof":"List" ,"array":[43,4,5,{"_instanceof":"List",
    "array":[6,7,{"_instanceof":"List",
    "array":[8,9],"circular":false}],"circular":false}],"circular":false}"

<i>(json-import my-list)</i>  â†’   (43 4 5 (6 7 (8 9)))

;; Structures
<i>(struct Person (name pict))</i>  â†’   #struct:Person [name pict]
<i>(define antoinette (Person "antoinette" "ğŸ‘°"))</i>  
    â†’   #<Person:0 > (antoinette ğŸ‘°)

<i>(export-json antoinette)</i>  â†’   
    "{"_instanceof":"Struct", "struct":"Person","id":17,"fields":["antoinette","ğŸ‘°"]}"
<i>(json-import 
    #<< {"_instanceof":"Struct","struct":"Person","id":18,"fields":["simon","ğŸ©"]} >>#)</i>  
	â†’   #<Person:18 > (simon ğŸ©)
</pre>

<h3>jsObjects</h3>
<p>
JSON imported data may be stored - string->json - into EchoLisp jsObjects. It is possible to create new jsObjects, to read/write jsObjects attribute values. jsObjects can be imported from strings or files.
<br>
JsObjects can be exported to JSON strings or to key-value-lists : lists of (key value) pairs. They can be created from key-value-lists, <a href="#plist">plists</a>, association lists.
Keys - aka attributes, properties, names, ... -  are strings.
<p>
Conversion functions are provided to/from basic JSON types: {object}, array, number, string and the more complex EchoLisp types : Rational, List, Struct, Vector, ...</p>
<p>
The functions json-get, json-put, supports the dot key notation for composite objects: 
(json-get somebody "person.adress.number") is the same as (json-get (json-get (json-get somedy "person") "adress" ) "number").</p>
</p>

<h4 id='json?'>(<b>json? </b><i>object</i>) is <i>object</i> a jsObject ?  â†’  #t or #f</h4>
<h4 id='make-json'>(<b>make-json </b><i>key-value-list</i>)  â†’  a new jsObject with same (key value) pairs as the input <i>key-value-list</i></h4>
<h4 id='string->json'>(<b>string->json </b><i>JSON-string</i>)  â†’  unserialize to new jsObject</h4>
<h4 id='json->tring'>(<b>json->string </b><i>jsObject</i>)  â†’  serialize to JSON string</h4>
<br>
<h4 id='json->plist'>(<b>json->plist </b><i>jsObject</i>)  â†’  new key-value-list from <i>jsObject</i>   <span style="color:red">deprecated</span></h4>
<h4 id='json->hash'>(<b>json->hash </b><i>jsObject</i>)  â†’  new hash table from <i>jsObject</i>   <small>Requires hash.lib</small>.</h4>
<h4 id='json->struct'>(<b>json->struct </b><i>jsObject <struct></i>)  â†’  new <struct> instance from <i>jsObject</i>.<small> The <struct> slots names must be a subset of the JSON keys found in <i>jsObject</i></small></h4>
<br>
<small>
<h4 id='json-keys'>(<b>json-keys </b><i>jsObject</i>)  â†’  list of all keys of jsObject</h4>
<h4 id='json-types'>(<b>json-types </b><i>jsObject</i>)  â†’  list of all keys/subkeys in jsObject, with associated type</h4>
<h4 id='json-get'>(<b>json-get </b><i>jsObject key-string </i>)  â†’  value of key in jsObject</h4>
<h4 id='json-put'>(<b>json-put </b><i>jsObject key-string value</i>)  â†’  sets value of key in jsObject, or creates a new key if not existing.</h4>
<br>
<h4 id='json->lisp'>(<b>json->lisp </b><i>jsObject</i>)  â†’  conversion to lisp object</h4>
<h4 id='lisp->json'>(<b>lisp->json </b><i>lisp-object</i>)  â†’  conversion to jsObject</h4>
</small>

<pre>
(lib 'struct)
(lib 'json)

(define cities ;; JSON string
#<<
[{"name":"Lagos", "population":21}, {"name":"Cairo", "population":15.2},
{"name":"Abidjan", "population":4.4}, {"name":"Casablanca", "population":3.98}]
>>#)

;; convert JSON string
<i>(define J (json-import cities))</i> ;; vector of jsObjects
   â†’ #( #[jsObject] #[jsObject] #[jsObject] #[jsObject])
   
;; inspect
<i>(json-keys (vector-ref J 0))</i>
    â†’ ("name" "population")
   
;; structure to import
<i>(struct city (name population))</i> ;; same keys (could be a subset of JSON keys)

;; make a vector of structures
<i>(vector-map (lambda(x) (json-&gt;struct x struct:city)) J)</i>;
   â†’ #( #&lt;city:0 &gt; (Lagos 21) #&lt;city:1 &gt; (Cairo 15.2) #&lt;city:2 &gt; (Abidjan 4.4) #&lt;city:3 &gt; (Casablanca 3.98))
</pre>

<h2 id='idb.lib'>Indexed data base - idb.lib</h2>
<p>The EchoLisp <i>idb</i> library provides access to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Basic_Concepts_Behind_IndexedDB">IndexedDB</a> (indexed data base, or idb for short) implemented in most browsers. Idb is a database of records holding simple values - 3.14 - , EchoLisp objects - lists, instances of structures, vectors, ... - and jsObjects.  Each record consists of a key and some value. Moreover, the database maintains indexes over records it stores.
<br>The EchoLisp developer directly uses the following API to locate records either by their key or by using an index.
<br>The main difference with the <a href="#local">local-database</a> API is that idb operations are <mark>asynchronous</mark>. One must provide onsuccess and onerror procedures to retrieve data base request results.
<br>The "ECHOLISP" data base is automatically created when loading the idb.lib. Adding and deleting stores increment the data base version.
</p>

<h4 id='db-verbose'>(<b>db-verbose </b><i>[#f|#t]</i>) -> messages on operation completion. #f is default.</h4>
<h4 id='db-name'>(<b>db-name</b>) -> name of current idb</h4>
<h4 id='db-version'>(<b>db-version </b>) -> version of current idb</h4>
<h4 id='db-stores'>(<b>db-stores </b>) -> list of stores in current idb</h4>
<h4 id='db-make-store'>(<b>db-make-store </b><i>name</i>) -> new store</h4>
<h4 id='db-delete-store!'>(<b>db-delete-store! </b><i>name</i>) -> deletes store and contents</h4>

<pre>
<i>(lib 'idb)</i>
<span style="color:green">
ğŸ’¾ IDB: db-open: ECHOLISP:1
Lib: idb.lib loaded.
</span>
<i>(db-name)</i>  â†’   "ECHOLISP"
<i>(db-version)</i>  â†’   1
<i>(db-stores)</i>  â†’   ("system" "user" "words")
(db-make-store "test") â†’ #t
<span style="color:green">ğŸ’¾ IDB: db-open: ECHOLISP:2</span>
(db-delete-store! "toast")
<span style = "color:orange">ğŸ’¾ IDB: db-delete-store: toast does not exist</span> â†’ #f
(db-delete-store! "test") â†’ #t
<span style="color:green">ğŸ’¾ IDB: db-open: ECHOLISP:3</span>
</pre>

<p>Asynchronous key-value access require onsuccess and onerror completion routines. They have the following signature:
<br>
<center>
 âœ’ï¸  (define (onsuccess result) body ) 
<br>
 âœ’ï¸  (define (onerror  error-reason) body ) 
</center>
<br>
</p>

<h3 id='db-store'>IDB stores - Symbols value access</h3>
<p>Symbols bindings and procedure definitions - strings - may be stored/retrieved into/from the idb's stores. In the following, <i>symbol</i> is the name of a bound symbol, or of a prodedure. A name may be prefixed by a store name. 'user' is the default store.</p>

<h4 id='db-keys'>(<b>db-keys </b><i>store  onsuccess</i>) â†’ #t. Build list of all keys in store and calls (onsuccess keys-list)</h4>
<h4 id='db-put'>(<b>db-put </b><i>[store.]symbol</i>) â†’ saves - replaces -  <i>symbol</i> binding into <i>store</i>. </h4>
<h4 id='db-get'>(<b>db-get </b><i>[store.]symbol [onsuccess [onerror]]</i>) â†’ retrieves value - null if none found - and bind it to <i>symbol</i>.</h4>

<pre>
<i>(define (success result) (writeln 'ğŸº-OK result)) 
(define (onerror a) (writeln 'ğŸš‘-KO a)) </i>  

;; working with the default 'user' store.
<i>(define mynumber ( + E PI))</i>  
<i>(db-put 'mynumber)</i>  â†’   #t
<i>(db-get 'mynumber success onerror)</i>  â†’   #t
	ğŸº-OK     5.859874482048838    
<i>(db-get 'other success onerror)</i>  â†’   #t
	ğŸš‘-KO     other  
	
;; working with the 'mail' store.
<i>(db-make-store 'mail)</i>  â†’   #t
<span style="color:green">
ğŸ’¾ IDB: db-make-store: ECHOLISP:mail
ğŸ’¾ IDB: db-open: ECHOLISP:17
</span>
<i>(define mail.gb "georges.brougnard@echolalie.com")</i>  â†’   mail.gb
<i>(db-put 'mail.gb)</i>  â†’   #t  

;; default success procedure
<i>(db-get 'mail.gb)</i>  â†’   #t
<span style="color:green">
ğŸ’¾ IDB: mail[gb] : georges.brougnard@echolalie.com
</span>

;; default error procedure
<i>(db-get 'mail.simon)</i>  â†’   #t
<span style="color:orange">
ğŸ’¾ IDB: db-get:unknown symbol: mail.simon
</span>
</pre>

<h3 id='db-store'>IDB stores - (key value) access</h3>
<h4 id='db-put-value'>(<b>db-put-value </b><i>[key|#:auto] value store [onsuccess [onerror]]</i>) 
<br>â†’ stores/replaces a new value in <i>store</i>. The key is either <i>key</i> or auto-incremented. Calls (onsuccess key). </h4>
<br>
<h4 id='db-add-value'>(<b>db-add-value </b><i>[key|#:auto] value store [onsuccess [onerror]]</i>) 
<br>â†’ stores a new value in <i>store</i>. The key is either <i>key</i> or auto-incremented. Calls (onsuccess key) when operation is complete. Calls (onerror key) if key already exists.</h4>
<br>
<h4 id='db-get-value'>(<b>db-get-value </b><i>key store onsuccess [onerror]</i>) 
<br>â†’ gets value infrom <i>store</i>. Calls (onsuccess value) when operation is complete. Calls (onerror key) if key is not found.</h4>
<pre>
<i>(define (success result) (writeln 'OK result))</i>  â†’   success
<i>(define (onerror what) (writeln 'KO what))</i>  â†’   onerror
<i>(db-make-store 'tmp)</i>  â†’   #t
<span style = "color:green">
ğŸ’¾ IDB: db-make-store: ECHOLISP:tmp
ğŸ’¾ IDB: db-open: ECHOLISP:16
</span>
<i>(db-put-value #:auto 33 'tmp success onerror)</i>  â†’   OK     1    
<i>(db-put-value 'mynumber 666 'tmp success)</i>  â†’   OK     "mynumber"    
<i>(db-keys 'tmp success)</i>  â†’   OK     (1 "mynumber")    
<i>(db-get-value "mynumber" 'tmp success onerror) </i>  â†’   OK     666    
<i>(db-get-value 33 'tmp success onerror)</i>  â†’   KO     33    
  
</pre>
<h4 id='db-put-values'>(<b>db-put-values </b><i>imin imax [key-proc|#:auto] value-proc store [oncomplete [onerror]]</i>) 
<br>â†’ <small>Stores multiple values at once. (key-proc i) and (value-proc i) are the (key value) providers for i in [imin imax]. Uses auto-increment keys if key-proc = #:auto.  Calls (oncomplete (keymin keymax)) at operation completion. May be used to populate the data base from a list or vector.</small></h4>
<br>
<h4 id='db-get-range'>(<b>db-get-range </b><i>[keymin|...] [keymax|...] store onsuccess [onerror]</i>) 
<br>â†’ retrieves all values for key interval [keymin ... keymax]. Calls (onsuccess list-of-values)</h4>
<br>
<h4 id='db-select'>(<b>db-select </b><i>selector store onsuccess [onerror]</i>) 
<br>â†’ Selects all values such as (selector key value) is not #f. Calls (onsuccess selected-values-list)</h4>
<h4 id='db-select-count'>(<b>db-select </b><i>selector store onsuccess [onerror]</i>) 
<br>â†’ Counts all records such as (selector key value) is not #f. Calls (onsuccess count)</h4>

<pre>
(lib 'words.fr)
(lib 'dico.fr)
<span style = "color:green">Lib: dico.fr loaded.</span>
(define (success result) (writeln 'OK result))

;; add a few entries from the dictionary into the 'tmp' store
;; using auto-increment
<i>(db-put-values 100000 100100 #:auto word-ref 'tmp success)</i>  â†’   #t
	OK     (103 203)	;; (key-min key-max) are returned

;; get records from key = 193 to last    
<i>(db-get-range 193 ... 'tmp success)</i>  â†’   #t
	OK     ("hospitalisai" "hospitalisaient" "hospitalisais" "hospitalisait" "hospitalisas" "hospitalisation" "hospitalisations" "hospitalise" "hospitalisent" "hospitaliser" "hospitalisera" )

;; select all records which contain 'hors'
<i>(define (success result) (writeln 'found: result))</i> 
<i>(define (selector key value)</i>  ;; selector return #f if substring not found
	<i>(when (string-index value 'hors) (writeln 'selected key value)))</i> 

<i>(db-select selector 'tmp success)</i>  â†’   #t
selected     152     "hors"    
selected     153     "horsain"    
...
selected     166     "horst"    
selected     167     "horstexte"    
	found:     ("hors" "horsain" "horsbord" "horsconcours" "horscote" "horsdoeuvre" "horseguard" "horsepower" "horsepox" "horsin" "horsjeu" "horslaloi" "horsligne" "horspiste" "horst" "horstexte")    
</pre>


<br>
<p>EchoLisp may access several idb's. Only one is current at a time. The following allow to create, open, close, delete indexed data bases.</p>
<h4 id='db-create'>(<b>db-create </b><i>name</i>) â†’ creates an idb, which becomes current</h4>
<h4 id='db-open'>(<b>db-open </b><i>name</i>) â†’ opens idb, make it current</h4>
<h4 id='db-close'>(<b>db-close </b>) â†’ closes the current idb</h4>
<h4 id='db-delete-db!'>(<b>db-delete-db! </b><i>name</i>) â†’ deletes an idb and its contents</h4>


<h2 id='tree.lib'> ğŸŒ´ğŸŒ± - Tree.lib</h2>
<p>A tree is defined by its root node. Each node in a tree may have node sons - which are also nodes - or may have no sons if it is a leaf node.
<br>A <i>datum</i> - any lisp object, except null - is associated with each node. Procedures are provided to create trees, nodes, add/change nodes, add subtrees, search trees, an apply (fold, for-each) functions to each node.
<br> The external representation of a node is (datum son<sub>1</sub> son<sub>2<</sub> ...) . The internal representation is a list of lists, and it probably never change in the future.
<br>(tree-for-each ..) and (tree-fold ..) make a <a href = "https://en.wikipedia.org/wiki/Tree_traversal">pre-order</a> traversal of the tree. 
</p>
<h4 id='tree?'>(<b>tree? </b><i>object</i>)  is <i>object</i> a root node ? â†’ #t or #f</h4>
<h4 id='make-tree'>(<b>make-tree </b><i>datum</i>) â†’ root node</h4>
<h4 id='node-add-leaf'>(<b>node-add-leaf </b><i>node datum</i>) add a leaf to </i>node</i>  â†’ new leaf node</h4>
<h4 id='node-add-tree'>(<b>node-add-tree </b><i>node tree</i>)  add <i>tree</i> as new son of <i>node</i> â†’ <i>tree</i> </h4>
<h4 id='tree-delete-node'>(<b>tree-delete-node </b><i>root node</i>) â†’ deletes <i>node</i> and all its sons</h4>
<h4 id='tree-replace-node'>(<b>tree-replace-node </b><i>root node tree</i>) â†’ replaces <i>node</i> by the tree <i>tree</i></h4>
<pre>
<i>(make-tree 'albert)</i>
   â†’  (ğŸŒ´ albert) ;; root node with datum albert
</pre>
<h4 id='node-leaf?'>(<b>node-leaf? </b><i>node</i>) is <i>node</i> a leaf ? â†’ #t or #f</h4>
<h4 id='node-sons'>(<b>node-sons </b><i>node</i>) â†’ ğŸŒ´ğŸŒ±ğŸŒ´ğŸŒ± forest = list of all sons of <i>node</i> or null if <node> is a leaf</h4>
<h4 id='node-left'>(<b>node-left </b><i>node</i>) â†’ null or leftmost - first - son of <i>node</i></h4>
<h4 id='node-right'>(<b>node-right </b><i>node</i>) â†’ null or rightmost - last - son of <i>node</i></h4>
<h4 id='node-datum'>(<b>node-datum </b><i>node</i>) â†’ datum at <i>node</i></h4>
<h4 id='node-set-datum'>(<b>node-set-datum </b><i>node datum</i>) â†’ sets datum at <i>node</i></h4>

<pre>
See <a href="http://rosettacode.org/wiki/Knuth's_power_tree">Knuth's power tree</a>
</pre>
<h4 id='tree-ref'>(<b>tree-ref </b><i>root datum</i>) â†’ node such as (equal? node.datum <i>datum</i>) or null</h4>
<h4 id='tree-fold'>(<b>tree-fold </b><i>proc:2 acc<sub>0</sub> root</i>) â†’ computes acc<sub>i+1</sub> := proc(node<sub>i</sub>.datum acc<sub>i</sub>) for all nodes - returns acc<sub>last</sub></h4>
<h4 id='tree-for-each'>(<b>tree-for-each </b><i>proc:1 root</i>) â†’ calls (proc node) for all tree nodes</h4>
<h4 id='tree-count'>(<b>tree-count </b><i>root</i>) â†’ pair : (# of nodes . tree-depth). <small>The tree depth is the maximum path length from the root to a leaf node.</small></h4>
<pre>
</pre>

<h2 id = 'bintree.lib'>ğŸŒ± -Binary search trees</h2>
<p>Binary search trees are also trees, so the above functions (for-each, count, etc.) apply also to binary trees. 
<br>The <i>datum</i> at each node is a pair (key . value). Keys are unique. Each node has at most two sons, named left and right. The tree insertion/deletion ensures that left.key &lt; right.key, and each left subtree has keys &lt; any right subtree keys. The tree is automatically reorganized - balanced - when the tree-depth is too high, namely when tree-depth &gt; ceil(log2 (node-count)).
<br>
(tree-for-each ..) and (tree-fold ..) visit the tree in <mark>symmetric</mark> order (<a href="https://en.wikipedia.org/wiki/Tree_traversal">in-order</a> traversal) from smallest key to greatest key. 
</p>

<h4 id='make-bin-tree'>(<b>make-bin-tree </b><i>key value</i>) â†’ root node with datum = (key . value)</h4>
<h4 id='bin-tree-empty?'>(<b>bin-tree-empty? </b><i>root</i>) â†’ #t or #f</h4>
<h4 id='bin-tree-insert'>(<b>bin-tree-insert </b><i>root key value</i>)  adds a new node (key . value) at the right place â†’ key or #f if (key . value) already here</h4>
<h4 id='bin-tree-delete'>(<b>bin-tree-delete </b><i>root key</i>) deletes node located at <i>key</i> â†’ #t if node found, else #f</h4>
<h4 id='bin-tree-search'>(<b>bin-tree-search </b><i>root key</i>) â†’ value for node at <i>key</i> or null</h4>
<h4 id='bin-tree-first'>(<b>bin-tree-first </b><i>root</i>) â†’ (key . value) for smallest key.  â†’ null if empty tree.</h4>
<h4 id='bin-tree-last'>(<b>bin-tree-last </b><i>root</i>) â†’ (key . value) for greatest key.  â†’ null if empty tree.</h4>
<br>
<h4 id='bin-tree-pop-first'>(<b>bin-tree-pop-first </b><i>root</i>) â†’ (key . value) for smallest key, and delete it.  â†’ null if empty tree</h4>
<h4 id='bin-tree-pop-last'>(<b>bin-tree-pop-last </b><i>root</i>) â†’ (key . value) for greatest key, and delete it.  â†’ null if empty tree.</h4>

<br>
<small><h4 id='tree-balance'>(<b>tree-balance </b><i>root</i>) reorganizes the tree to minimize the tree-depth. â†’ (# of nodes . tree-depth). O(n) time, but not in constant space.</h4></small>
<pre>
</pre>

<h3 id="queues">queues</h3>
<p>Queues may be used when appropriate in place of lists, for performance or simplicity reasons. Queues have identifiers - <i>queue-id</i> , are global objects, are not bound to a variable with the same name. Queues pop values FIFO style. Use a heap or a binary tree to implement a priority queue.  Use (queue (gensym)) to get an anonymous queue, with unique name.</p>
<h4 id='queue'>(<b>queue </b><i>queue-id</i>) new empty queue  â›  queue-id</h4>
<h4 id='queue-empty?'>(<b>queue-empty? </b><i>queue-id</i>) â› #t or #f </h4>
<h4 id='queue-length'>(<b>queue-length </b><i>queue-id</i>) â› # of items </h4>
<br>
<h4 id='enqueue'>(<b>enqueue </b><i>queue-id value</i>) enqueue last element  â› value</h4>
<h4 id='q-push'>(<b>q-push </b><i>queue-id value</i>) :: synonym for <i>enqueue</i></h4>
<h4 id='queue-top'>(<b>queue-top </b><i>queue-id</i>) â› value = first element, or #f if queue is empty</h4>
<h4 id='dequeue'>(<b>dequeue </b><i>queue-id</i>) â›  first element , or #f if queue is empty</h4>
<h4 id='q-pop'>(<b>q-pop </b><i>queue</i>)  ::  synonym for <i>dequeue</i></h4>
<br>
<h4 id='queue->list'>(<b>queue->list </b><i>queue-id</i>) â› queue contents, as a list</h4>
<h4 id='list->queue'>(<b>list->queue  </b><i> list queue-id</i>) â› new queue from list</h4>
<pre>
See <a href="http://rosettacode.org/wiki/Averages/Simple_moving_average#EchoLisp">Moving average</a>
</pre>

<h2 id = "heap.lib"> å¨ Heaps - heap.lib</h2>
<p>Heaps are collections of elements ordered by a comparison function, compare-proc(element<sub>i</sub> element<sub>j</sub>) which returns #t iff element<sub>i</sub> is 'before' element<sub>j</sub>, else #f. Elements may be any EchoLisp object and must not be unique.
<br>For example, if compare-proc is '<', the ordering is element<sub>0</sub> <= element<sub>1</sub> <= ...
<br>Functions are provided to quickly - <b>ÎŸ</b>(1) - retrieve or pop the element<sub>0</sub> = top of heap, or insert (push) new elements - <b>ÎŸ</b>(log(n)) - .
</p>
<h4 id='make-heap'>(<b>make-heap </b><i>compare-proc:2</i>)  â› new heap; The <i>compare-proc</i> function defines the heap ordering.</h4>
<h4 id='heap?'>(<b>heap? </b><i>object</i>) is <i>object</i> a heap?  â› #t or #f</h4>
<br>
<h4 id='heap-push'>(<b>heap-push </b><i>heap object</i>)  â› inserts <i>object</i> into heap  â› object</h4>
<h4 id='heap-pop'>(<b>heap-pop </b><i>heap</i>)  â› removes the 'first' element, i.e min, max, .. according to the ordering function, and returns it or #f is the heap is empty.</h4>
<h4 id='heap-top'>(<b>heap-top </b><i>heap</i>)  â› returns the 'first' element without removing it, or #f</h4>
<br>
<h4 id='heap-length'>(<b>heap-length </b><i>heap</i>)  â› number of elements in heap</h4>
<h4 id='heap-empty?'>(<b>heap-empty? </b><i>heap</i>) is the heap empty?  â› #t or #f</h4>
<h4 id='heap->list'>(<b>heap->list </b><i>heap</i>)  â› list of heap elements, in unspecified order</h4>
<h4 id='list->heap'>(<b>list->heap </b><i>list heap</i>) orders elements of list according to compare-proc, and make them replace the contents of heap  â›  heap</h4>
<pre>
Example : <a href="http://rosettacode.org/wiki/Taxicab_numbers#EchoLisp">taxicab</a> numbers
</pre>


<h2 id="graph.lib"> â™º Graph.lib - Directed and undirected graphs</h2>
<p> Notations & definitions
<ul>
<li> G : a graph = set of vertices + set of arcs  </li>
<li> label : any lisp object</li>
<li> u,v,u<sub>0</sub>,u<sub>1</sub> : vertices. Each vertex has an unique label L(u) </li>
<li> uâ›v, u<sub>0</sub>â›u<sub>1</sub>, .. : directed arc between u and v ,...v is adjacent from u </li>
<li> u-v, u<sub>0</sub>-u<sub>1</sub>, .. :  edge = undirected arc between u,v. u is adjacent with v.</li> 
<li> cycle : list of vertices (u<sub>0</sub> u<sub>1</sub> .. u<sub>n</sub>) such as u<sub>i</sub>â›u<sub>i+1</sub> âˆˆ G and u<sub>n</sub>â›u<sub>0</sub> âˆˆ G  and u<sub>i</sub> != u<sub>k</sub></li>
</ul>

<h4 id='graph?'>(<b>graph? </b><i>obj</i>) â› is obj a graph ? â› #t or #f</h4>
<h4 id='make-graph'>(<b>make-graph </b><i>graph-label</i>) â› new empty graph</h4>
<h4 id='graph-make-vertex'>(<b>graph-make-vertex </b><i>G label</i>) â› new vertex u of G, or already existing such as (eq? L(u) label).</h4>
<h4 id='graph-delete-vertex'>(<b>graph-delete-vertex </b><i>G u</i>) removes u and all arcs uâ›v , vâ›u from G; â› #t or #f if u not in G</h4>
<h4 id='vertex-set-label'>(<b>vertex-set-label </b><i>u label</i>) set label for vertex u â›  label
<h4 id='vertex-label'>(<b>vertex-label </b><i>u </i>)  â›  label of vertex u 
<h4 id='graph-vertex-ref'>(<b>graph-vertex-ref </b><i>G label</i>) â› first vertex u such as (eq? L(u) label), or null </h4>
<p>Hint : to mark/unmark vertices, use (<a href="#mark">mark</a> u value) (mark? u) (unmark u)</p>

<br>
<h4 id='graph-make-arc'>(<b>graph-make-arc </b><i>G u v</i>) add new arc uâ›v to G; â› (L(u) . L(v)) </h4>
<h4 id='graph-delete-arc'>(<b>graph-delete-arc </b><i>G u v</i>) delete  uâ›v. return #t if found, #f if not found</h4>
<h4 id='graph-make-edge'>(<b>graph-make-edge </b><i>G u v</i>) add new edge u-v to G; â› (L(u) . L(v))</h4>
<h4 id='graph-delete-edge'>(<b>graph-delete-edge </b><i>G u v</i>) delete  u-v; â›  #t if found, #f if not found</h4>
<br>
<h4 id='graph-order'>(<b>graph-order </b><i>G</i>) â› number of vertices</h4>
<h4 id='graph-size'>(<b>graph-size </b><i>G</i>) â› number of arcs</h4>
<h4 id='graph-vertex-out'>(<b>graph-vertex-out </b><i>G u</i>) â› list of vertices v such as uâ›v âˆˆ G  , or null</h4>
<h4 id='graph-vertex-in'>(<b>graph-vertex-in </b><i>G u</i>) â› list of vertices v such as vâ›u âˆˆ G , or null</h4>
<h4 id='graph-vertex-outdegree'>(<b>graph-vertex-outdegree </b><i>G u</i>) â› number of vertices v such as uâ›v âˆˆ G , or 0</h4>
<h4 id='graph-vertex-indegree'>(<b>graph-vertex-indegree </b><i>G u</i>) â› number of vertices v such as vâ›u âˆˆ G , or 0</h4>
<br>
<h4 id='for'>(<b>for </b>((<i>u graph</i>) ... ) expr<sub>1</sub> â€¦ expr<sub>n</sub></i>) iterates on u values = all vertices of graph. <small>Use with for, and any for*, for/... form.</small></h4>
<h4 id='graph-for-each'>(<b>graph-for-each </b><i>proc:1 G</i>) â› call (proc u) for each vertex u - undefined order - </h4>
<br>
<h4 id='graph-cycle'>(<b>graph-cycle </b><i>G u<sub>0</sub> </i>) â› a cycle (u<sub>0</sub> u<sub>1</sub> ... u<sub>n</sub>) or null if no cycle exists including u<sub>0</sub>. </h4>
<h4 id='graph-cycle'>(<b>graph-cycle </b><i>G</sub> </i>) â› find a cycle (u<sub>0</sub> u<sub>1</sub> ... u<sub>n</sub>) or null if no cycle exists in G. </h4>
<h4 id='graph-min-path'>(<b>graph-min-path </b><i>G u v</i>) â› a minimal path (u u<sub>1</sub> ... u<sub>n</sub> v) or null if no path exists; u and v are distinct vertices. </h4>
<h4 id='graph-dag-sort'>(<b>graph-dag-sort </b><i>G </i>) topological sort â› an ordering  (u<sub>1</sub> ... u<sub>n</sub>)  such as there is no arc u<sub>i+k</sub>â›u<sub>i</sub> or null if no ordering exists i.e G is not a direct acyclic graph -  </h4>
<br>
<h4 id='graph-print'>(<b>graph-print </b><i>G</i>) â› G in human readable form. <small>vertex : adjacency list from each vertex.</small> </h4>
<h4 id='graph-print-vertex'>(<b>graph-print-vertex </b><i>G u</i>) â› u in human readable form <small> Label:in-degree:out-degree</small></h4>
<h4 id='graph-sort'>(<b>graph-sort </b><i>G</i>) sort adjacency lists according to label â› G. <small>does not modify the graph structure</small> </h4>

<pre>
Complete sample code in <a href="http://rosettacode.org/wiki/Topological_sort#EchoLisp">Rosetta</a> code.
</pre>

<h2 id = "interface.lib" >UI - Interface.lib</h2>
<center><img src ="./images/interface.png"></center>
<h3>UI Elements</h3>
<p>An user interface (UI) is a set of HTML DOM Nodes (buttons, sliders, text input, links, ..) which are programmatically added to a given cell, in order to build an application requiring user interaction.  Elements are created using ui-create-element, and added to the UI with ui-add. UI functions closely mimic the javascript DOM Nodes functions.
<p>In the following <i>attribute</i> is a string or symbol denoting a Node attribue or property name. Reference :  <a href="http://www.w3schools.com/jsref/dom_obj_all.asp">Element Objects</a> and <a href="http://www.w3schools.com/jsref/dom_obj_style.asp">style Object properties</a>. Note that attributes/properties names use the JavaScript syntax : fontSize, backgroundColor, and <b>not</b> the CSS syntax : font-size, background-color. </a> 
</p>
<h4 id='ui-create-element'>(<b>ui-create-element </b><i>tag attr-value-list</i>) â†’ elem. Creates a new element of type "<a href="http://www.w3schools.com/tags/">tag</a>", and sets initial attribute values. attr-value-list is null or a list ((attr<sub>1</sub> value<sub>1</sub>) ...)</h4>
<h4 id='ui-set-attribute'>(<b>ui-set-attribute </b><i>elem attribute value</i>) â†’ sets value string for attribute <i>attribute</i> of elem.</h4>
<h4 id='ui-get-attribute'>(<b>ui-get-attribute </b><i>elem attribute</i>) â†’ attribute value for elem.</h4>
<h4 id='ui-attributes'>(<b>ui-attributes </b><i>elem </i>) â†’ list of (attribute value).</h4>
<h4 id='ui-set-value'>(<b>ui-set-value </b><i>input-elem value</i>) â†’ sets and returns elem.value</h4>
<h4 id='ui-get-value'>(<b>ui-get-value </b><i>input-elem</i>) â†’ returns elem.value</h4>
<h4 id='ui-get-numvalue'>(<b>ui-get-numvalue </b><i>input-elem</i>) â†’ returns (integer or float) the numerical value of elem.value or #f if error.</h4>
<br>
<h4 id='ui-set-style'>(<b>ui-set-style </b><i>elem property value</i>) â†’ sets a property style value</h4>
<h4 id='ui-get-style'>(<b>ui-get-style </b><i>elem property</i>) â†’ gets a property style value</h4>
<h4 id='ui-set-html'>(<b>ui-set-html </b><i>elem html-string</i>) â†’ sets element.innerHTML</h4>
<br>
<h4 id='ui-set-name'>(<b>ui-set-name </b><i>elem name</i>) â†’ sets the element name. <small>Internal name, not HTML attribute. Useful for referencing elements in error messages.</small></h4>
<h4 id='ui-get-name'>(<b>ui-get-name </b><i>elem</i>) â†’ returns the element name or  "[object HTML&lt;tag&gt;Element]" if none.</h4>
<br>
<h4 id='ui-disable'>(<b>ui-disable </b><i>elem</i>[#t|#f]) â†’ disable/enable element</h4>
<h4 id='ui-focus'>(<b>ui-focus </b><i>elem</i>) â†’ sets the focus onto element</h4>


<h3>UI construction</h3>
<h4 id='ui-add'>(<b>ui-add </b><i>elem</i>) â†’ elem. Adds an element to the current cell UI. Elements are added in-line. Tip : insert a new &lt;div&gt;  or &lt;br&gt; element to vertically arrange the following element.</h4>
<h4 id='ui-insert-after'>(<b>ui-insert-after </b><i>elem reference</i>) â†’ adds element after <i>reference</i> element.
<h4 id='ui-insert-before'>(<b>ui-insert-before </b><i>elem reference</i>) â†’ adds element before <i>reference</i> element.
<h4 id='ui-clone'>(<b>ui-clone </b><i>elem</i>) â†’ new deep clone of elem.
<h4 id='ui-hide'>(<b>ui-hide </b><i>elem</i> [#t|#f]) â†’ hides/shows element.
<h4 id='ui-remove'>(<b>ui-remove </b><i>elem</i>) â†’ removes elem and all possible children.
<h4 id='ui-clear'>(<b>ui-clear </b>) â†’ removes all UI elements.

<h3>UI events</h3>
<h4 id='ui-on-change'>(<b>ui-on-change </b><i>elem h:2:2</i>) â†’ Adds and event handler to an input element : slider, text area, ... (h elem newvalue) is a two-arguments procedure which will be called on change events.</h4>
<h4 id='ui-on-click'>(<b>ui-on-click </b><i>elem h:1:1</i>) â†’ Adds and event handler to a clickable element : button. (h elem ) is a one-argument procedure which will be called on click events.</h4>
<h4 id='ui-on-focus'>(<b>ui-on-focus </b><i>elem h:1:1</i>) â†’ Adds and event handler. (h elem) is a one-argument procedure which will be called on focus events.</h4>
<h4 id='ui-on-blur'>(<b>ui-on-blur </b><i>elem h:1:1</i>) â†’ Adds and event handler. (h elem) is a one-argument procedure which will be called on  blur - leave focus - events.</h4>

<pre><small>
;; The above panel
(define (ds elem value) (stdout-clear) (writeln elem value) value) ; slider action
(define (db elem) (stdout-clear) (writeln elem "clicked")) ;; button action

;; returns a slider which displays its value
(define (ui-add-active-range (rmin  0)(rmax 1)) 
    (define t (ui-create-element "span" '((style "font-weight:bold"))))
    (define s (ui-create-element "input" '((type range))))
    (define (lnk elem value) (ui-set-html t value))
    (ui-set-attribute s  'min rmin)
    (ui-set-attribute  s 'max rmax)
    (ui-set-attribute  s 'step 0.01)
    (ui-set-style  s 'width "300px")
    (ui-on-change s lnk) 
    (ui-add t)
    (ui-add s))

;; returns a button with text
(define (ui-add-button text)
    (define b (ui-create-element "button" '((type "button"))))
    (ui-set-html b text)
    (ui-add b))
    
;;main panel function
(define (panel )
(ui-clear) ;; remove all elements (if any)
(stdout-clear)

;; input field which checks its content type
(define innum (ui-create-element "input" '((type number) (placeholder "a number") (value "666"))))
(ui-add innum)
(ui-on-change innum ds)

(define intext (ui-create-element "input" '((type text)  (style "color:red") (value "Your text here please SVP"))))
(ui-add intext)
(ui-on-change intext ds)

(define br (ui-create-element "br" null))
(ui-add br)

(define t (ui-create-element "span" '((style "font-weight:bold"))))
(ui-add t)
(ui-set-html t " temperature [ğŸ… 0 .. 100 ğŸ”†]")

(define s (ui-create-element "input" '((type range)  ("style" "border :1px solid red"))))
(ui-set-style s "margin-bottom" "-6px")
(ui-on-change s ds)
(ui-add s)

(ui-on-click (ui-add-button "myButton") db)

(define t (ui-create-element "div" null))
(ui-add t)
(ui-set-style t 'backgroundColor "lightgreen")
(ui-set-html t "Division")
(ui-set-style t "marginTop" "10px")

(define ar (ui-add-active-range))
(ui-on-change ar ds)

(define hr (ui-create-element "hr" null)) ;; horizontal line
(ui-add hr)

(define lnk (ui-create-element "a" null)) ;; an html link
(ui-set-html lnk "Echolalie")
(ui-set-attribute lnk "href" "http://www.echolalie.com")
(ui-add lnk)

(stdin-hide #t)) ;; end panel
(panel) ;; show panel
</small></pre>

<h3>Cell elements</h3>
<h4 id = "stdin">(<b>stdin</b>) â†’ stdin element = the cell input area</h4>
<h4 id = "stdout">(<b>stdout</b>) â†’ stdout element = the cell output area</h4>
<h4 id = "ui">(<b>ui</b>) â†’ UI element = the cell ui element</h4>

<pre>
(ui-set-style (ui) ' backgroundColor "orange")
</pre>

<h2 id="words.lib">Words.lib</h2>
<p>Uses a <a href = #sql.lib">Table</a> to implements a data base of words (strings) which may be tagged. One can create tags, words, add tags to words, search - select - words. The words tables may be loaded as a library - dico.lib - .
<br>
The words and tag tables are referenced by the symbols *words* and *tags* .
</p>


<h4 id='word-new'>(<b>word-new </b><i>word</i>) â› new word, with no tags</h4>
<h4 id='word?'>(<b>word? </b><i>word</i>)  is word a known word ? â› #f or record (word tag tag ..) </h4>
<h4 id='word-index'>(<b>word-index </b><i>word</i>) â› num index for word or -1</h4>
<h4 id='word-ref'>(<b>word-ref </b><i>num</i>) â› num-th word or #f</h4>
<br>
<h4 id='word-tag'>(<b>word-tag </b><i>word tag</i>) â› add tag for word</h4>
<h4 id='word-set-tags!'>(<b>word-set-tags! </b><i>word (tag<sub>i</sub> .. tag<sub>i</sub> </i>)) â› add tagS for word</h4>
<h4 id='word-remove-tag'>(<b>word-remove-tag </b><i>word tag</i>)</h4>

<h4 id='word-tags'>(<b>word-tags </b><i>word</i>) â› list of tags for word</h4>
<h4 id='word-tag?'>(<b>word-tag? </b><i>word tag</i>) â› has word this tag ? #t or #f</h4>
<h4 id='word-tags?'>(<b>word-tags? </b><i>word (tag<sub>i</sub> .. tag<sub>j</sub> ..</i>)) â› has word tag<sub>i</sub> AND tag<sub>j</sub> and .. ? #t or #f</h4>
<br>
<h4 id='words-select'>(<b>words-select </b><i>pattern tags limit</i>) â› list of matching words or null</h4>
<h4 id='word-random'>(<b>word-random </b><i>pattern tags</i>) â› one random matching word or #f</h4>
<br>
<ul>
<li>pattern := #:any | substring to match | "/regexp/" </li>
<li>tags := null or list (tag<sub>1</sub> .. -tag<sub>i</sub> ..) of matching tags. '-tag' must be absent.</li>
<li>limit := max number of records to select</li>
</ul>

<pre>
(<i>lib 'struct)</i>
(<i>lib 'sql)</i>
(<i>lib 'words)</i>
<span style="color:green">Lib: words.lib loaded.</span>

;; <img src="https://abs.twimg.com/emoji/v1/72x72/1f1eb-1f1f7.png" width="18" height="18" /> a data base of 209315 french words. Tags are lexical types (noun, verb, â€¦), genre (sing, plural), etc.

<i>(lib 'dico.fr)</i> ;; alternate is (lib 'dico.fr.no-accent) : no accentued characters
*words* â†’ #table:#struct:word [name tags]:[209315]
*tags*  â†’ #table:#struct:tag [name]:[26]

<i>(table->list *tags*)</i>  â†’ ((#TAGS) (nom) (verbe) (adj) (masc) (fem) (sing) (pluriel) (p3) (det) (pat) (adv) (prep) (pronom) (conj) (int!) (vpronom) (vintran) (inf) (ppas) (imp) (futur) (present) (psimple) (p1) (p2))

<i>(word? 'gallubert)</i>  â†’   #f
<i>(word-index 'zythum)</i>  â†’   201856
<i>(word? 'zythum)</i>  â†’   (zythum nom masc sing)
<i>(word-ref 205000)</i>  â†’   Ã©liminÃ¢mes

<i>(word-random "chinch" null)</i> â†’ cochinchinoise
<i>(word? 'chinchard)</i> â†’ (chinchard nom masc sing)
<i>(word? 'brougnard)</i> â†’ (brougnard masc pat)

(words-select "zoo" null)
 â†’ (zoo zoogamÃ¨te zooglÃ©e zoogÃ©ographie zoolite zoolithe zoologie zoologique zoologiquement ... zootechniciennes zootechnie zoothÃ©rapeutique zoothÃ©rapie zooÃ¯de)
 
(words-select "/.*zoo.*/" null 40)
  â†’ (azoospermie bazooka bazookas enzootie zoo zoogamÃ¨te zooglÃ©e zoogÃ©ographie zoolite zoolithe zoologie zoologique zoologiquement zoologiques zoologiste zoologistes  ... Ã©pizootiques)

<i>(words-select "chinch" '(nom masc sing) 10)</i>  â†’ (chinchard chinchilla)

<i>(define (a-bon-chat-bon-rat) 
	(let [
	(bon (word-random ".*on$" '(adj)))
	(chat (word-random ".*at$" '(nom masc -verbe)))
	(rat (word-random   ".*at$" '(nom masc -verbe)))]
(printf  "Ã  %s %s %s %s." bon chat bon rat)))</i>

<i>(for ((i 100)) (a-bon-chat-bon-rat))</i> â› 

    Ã  tatillon goujat tatillon doctorat.
    Ã  mignon homÃ©ostat mignon Ã©conomat.
    Ã  bon entrechat bon sÃ©nat.
    Ã  ronchon avocat ronchon gyrostat.
    Ã  con corbillat con mÃ©cÃ©nat.
    Ã  fanfaron Ã©phorat fanfaron mÃ©at.
    Ã  laideron alcoolat laideron crachat.
    Ã  ronchon exsudat ronchon internat.
    Ã  glouton commissariat glouton quinquennat.
    Ã  tatillon khalifat tatillon combinat.
    Ã  ronchon crouillat ronchon sousdiaconat.
    Ã  folichon format folichon anastigmat.
</pre>

<pre>
 ;; a data base of about 235000 english words (no tags)
 
<i>(lib 'dico.en)</i>
*words* â†’ #table:#struct:word [name tags]:[235886]

(words-select "zoo" null 30)
  â†’ (zoo zoobenthos zooblast... zooecia zooecial zooecium zooerastia zooerythrin zoofulvin zoogamete zoogamous zoogamy zoogene)

(words-select "/.*zoo.*/" null 30)
  â†’ (actinozoon adzooks Aizoon  bazoo bazooka blastozooid bryozoon calycozoon cenozoology cyathozooid cytozoon <mark>dactylozooid</mark> dermatozoon dermatozoonosis deuterozooid diphyozooid ... entozoologically entozoologist entozoology)

<i>(word-random "chinch" null)</i> â†’ "chinching"
(word? 'chinchard)  â†’ #f
</pre>

<h2 id="audio.lib"> ğŸ’¿ Audio.lib ğŸ“€ </h2>
<p>Uses an audio control to play .mp3 files, either from the ./sounds library or any accessible URL. The provided audios are : "ring0", "ring1", "ring2"  - default -, and "dalida".
</p>

<h4 id='audio-src'>(<b>audio-src </b><i>[file|url]</i>)  â†’ gets or sets the audio source file/url, and preloads it..</h4>
<h4 id='audio-play'>(<b>audio-play </b>)  â†’ plays the audio file.</h4>
<h4 id='audio-pause'>(<b>audio-pause </b>)  â†’ pause.</h4>
<h4 id='audio-volume'>(<b>audio-volume </b><i>[volume]</i>)  â†’ gets or sets the audio volume, a number in [0..1].</h4>
<br>
<h4 id='audio-show'>(<b>audio-show </b>)  â†’ shows the audio control.</h4>
<h4 id='audio-hide'>(<b>audio-hide </b>)  â†’ hides the audio control.</h4>

<pre>
(lib 'audio)
	(audio-src "./sounds/dalida")
	(audio-play)
	(audio-volume 0.8)
	(audio-show)
</pre>


<h2 id = "alpha"> Alphabetical list of system symbols and functions</h2>
<p> The following give all native symbols and functions names with min:max arity, libraries excluded. Special forms do not necessarily evaluate all their arguments.<br>
Notations :
<ul>
<li> ğŸ“– :  library</li>
<li> ğŸ“Œ : new </li>
<li> ğŸ‘€  : special form</li>
<li> ğŸ†˜ : help tool</li>
<li> ğŸ’¾ : source file</li>
<li> ğŸ‘“ : read me</li>
<li> ğŸ”‘ : glossary </li>
<li> ğŸ”— : external link</li>
<li> âœ’ï¸: signature of a function : âœ’ï¸ (define (...) ..) </li>
</ul>
</p>
<p>
ğŸ‘“ <small>Usage in this document: Click onto the &alpha; -alpha- letter in the left margin, or hit (keyboard) the first letter you want to go to.
<br>Usage in EchoLisp : (help function-id) to get help about a function</small>.
</p>
<pre>
    <span id ="#" class = "alpha" >#</span>
    <a href="#boolean">#f</a>
    <a href="#boolean">#t</a>
    <a href="#special">#| comment |#</a>
    
    <a href="#sequences.lib">#:all</a> keyword
    <a href="#words.lib">#:any</a> keyword
    <a href="#key-value">#:auto</a> keyword
    <a href="#for">#:break</a> keyword
    <a href="#for">#:continue</a> keyword
    <a href="#infix.lib">#:infix</a> keyword
    <a href="#struct.lib">#:onchange</a> keyword
    <a href="#packages">#:package</a> keyword
    <a href="#vector">#( a b c ...)</a> vector
    <a href="#make-set">#{ a b c ...}</a> set
    <a href="#struct.lib">#:tostring</a> keyword
    <a href="#for">#:when</a> keyword
    <a href="#strings">#' .... '#</a> string input
    <a href="#strings">#<< .... >>#</a> here-string input
    
Printed forms : not readable
    #|environment-id| : environment
    <span style="color:blue">#function-id</span>  : internal function
    #:g1001 : internal symbol

    <span class = "alpha"  ><a href="#operators">Operators</a></span>
    <a href="#operators">*</a> :0:n  
    +  :0:n  
    -  :1:n  
    <a href="#+=">+=</a> :2
    <a href="#-=">-=</a> :2
    <a href="#++">++</a> :1
    <a href="#--">-- :1
    <a href="#*=">*=</a> :2
    <a href="#/=">/=</a> :2
    <a href="#%=">%=</a> :2
    <a href="#//=">//=</a> :2
    <a href="#operators">//</a> :1:n  
    /  :1:n 
    1+ :1 
    1- :1 
    <  :2 
    <= :2 
    =  :2 
    >  :2 
    >= :2 
    =  :2
    <a href="#expt">^</a>  :2
    <a href="#factorial">!</a>  :1
    <a href='#approx'>~=</a> :2
    
    <a href='#pipeline'>-></a> :1:n
    <a href='#pipeline'>->></a> :1:n
    
    <span class = "alpha" >Constants</span>
    <a href="#constant">-PI</a>
    <a href="#constant">E</a>
    <a href="#constant">I</a>
    <a href="#constant">PI</a>
    <a href="#constant">PI/2</a>
    <a href="#constant">LOG2</a>
    <a href="#constant">DAY</a>
    <a href="#constant">JOUR</a>
    <a href="#sets">âˆ…</a>
    
    <span class = "alpha" id = "!">!</span>
    <a href="#=">!=</a>:1
    <a href="#eq?">!eq?</a>:1
    <a href="#equal?">!equal?</a>:1
    <a href="#!null?">!null?</a>:1
    <a href="#!empty?">!empty?</a>:1
    <a href="#!zero?">!zero?</a>:1 
    
    <span class = "alpha" id = "a">A</span>
    ğŸ“–  <a href="#amb.lib">amb operator</a> 
    <a href="#Anp">Anp</a>:2 
    <a href="#abs">abs</a>:1 
    <a href="#acos">acos</a>:1 
    <a href="#add1">add1</a>:1 
    <a href="#alert">alert</a>:1 
    <a href="#alist?">alist?</a>:1 
    <a href="#angle">angle</a>:1
    ğŸ‘€ <a href="#and">and</a>:1:n 
    <a href="#any">any</a>:2:3 
    ğŸ‘€ <a href="#ap">ap</a>:1 ğŸ†˜
    ğŸ‘€ <a href="#apropos">apropos</a>:1 
     
    <a href="#append">append</a>:1:n 
    <a href="#apply-compose">apply-compose</a>:2 
    <a href="#apply-iterate">apply-iterate</a>:2 
    <a href="#apply">apply</a>:2 
    ğŸ”‘  <a href="#arithmetic">arithmetic functions</a>
    <a href="#arithmetic-shift">arithmetic-shift</a>:2 
    ğŸ”‘  <a href="#vector">array</a>
    <a href="#asin">asin</a>:1
    ğŸ‘€ <a href="#assert">assert</a>:1:2 
    <a href="#assoc-proc-call">assoc-proc-call</a>:4
    <a href="#assoc">assoc</a>:2 
    <a href="#association-procedure">association-procedure</a>:2 
    <a href="#assq">assq</a>:2 
    <a href="#assv">assv</a>:2 
    ğŸ“– <a href="#timer.lib">at</a> (timer.lib)
    <a href="#atan2">atan2</a>:2 
    <a href="#atan">atan</a>:1 
    ğŸ“– <a href="audio.lib">audio functions</a> ğŸ“ ğŸ¶ ğŸ¼
    <a href="#autocomplete-delay">autocomplete-delay</a>:0:1 
    
    <span class = "alpha" id = "b">B</span>
    ğŸ‘€ <a href="#begin">begin</a>:1:n
    ğŸ‘€ <a href="#begin0">begin0</a>:1:n
    ğŸ“– <a href="#bigint.lib">bigint.lib</a> 
    ğŸ“– <a href="#tree.lib">binary tree</a>
    ğŸ“– <a href="#bit-map">bit-map</a>
    ğŸ“– <a href="#bit-vectors">bit vectors</a>
    <a href="#bit-count">bit-count</a>:1
    <a href="#bit-right">bit-right</a>:1
    <a href="#bitwise-and">bitwise-and</a>:2
    <a href="#bitwise-ior">bitwise-ior</a>:2 
    <a href="#bitwise-bit-set?">bitwise-bit-set?</a>:2 
    <a href="#bitwise-not">bitwise-not</a>:2 
    <a href="#bitwise-xor">bitwise-xor</a>:2  
    <a href="#boolean?">boolean?</a>:1
    <a href="#bound?">bound?</a>:1  
    <a href="#box">box</a>:1 
    <a href="#box?">box?</a>:1 
    <a href="#iterations">#:break</a> 
    <a href="#build-vector">build-vector</a>:2 
    
    <span class = "alpha" id = "c">C</span>
    <a href="#cache">cache</a>:1
    <a href="#cache-size">cache-size</a>:0:1
    <a href="#timer.lib">*calendar*</a>
    ğŸ‘€ <a href="#call-with-current-continuation">call-with-current-continuation</a>:0:n 
    ğŸ‘€ <a href="#call/cc">call/cc</a>:0:n 
    
    <a href="#car">caaar</a>:1 
    <a href="#car">caadr</a>:1 
    <a href="#car">caar</a>:1 
    <a href="#car">cadar</a>:1 
    <a href="#cdr">caddr</a>:1 
    <a href="#cdr">cadr</a>:1 
    <a href="#car">car</a>:1  <small>aka first</small>
    <a href="#cdr">cdaar</a>:1 
    <a href="#cdr">cdadr</a>:1 
    <a href="#car">cdar</a>:1 
    <a href="#cdr">cddar</a>:1 
    <a href="#cdr">cdddr</a>:1 
    <a href="#cddr">cddr</a>:1 
    <a href="#cdr">cdr</a>:1 <small>aka rest</small>
    
    ğŸ‘€ <a href="#case">case</a>:2:n 
    ğŸ‘€ <a href="#catch">catch</a>:2
    <a href="#cbrt">cbrt</a>:1 âˆ›
    ğŸ“– <a href="#cdot-product">cdot-product</a>:2 
    ğŸ‘€ <a href="#check-expect">check-expect</a>:2 
    <a href="#ceil">ceil</a>:1 
    ğŸ“– <a href="#crt-solve">crt-solve</a>:2  <small>chinese remainder theorem</small>
    <a href="#circular-list">circular-list</a>:1:n
    <a href="#circular?">circular?</a>:1
    ğŸ”‘ <a href="#closure">closure</a>
    <a href="#Cnp">Cnp</a>:2  
    ğŸ“– <a href="#combinations">combinations</a>:2
    ğŸ“– <a href="#combinator">Combinators</a>
    <a href="#special">#|comment  |#</a>
    <a href="#special">; comment</a>
    <a href="#complex">complex</a>:2 
    <a href="#complex?">complex?</a>:1 
    ğŸ“– <a href="#compile.lib">compile</a>1:2 
    ğŸ‘€ <a href="#compose">compose</a>:1:n 
    <a href="#confirm">confirm</a>:1 
    <a href="#conjugate">conjugate</a>:1
    ğŸ‘€ <a href="#cond">cond</a>:1:n 
    <a href="#cons">cons</a>:2 
    <a href="#console-dir">console-dir</a>:1
    <a href="#console-log">console-log</a>:2
    <a href="#console-trace">console-trace</a>:2 
    <a href="#copy">copy</a>:1 
    <a href="#cos">cos</a>:1 
    ğŸ“– <a href="#contfract">continued fraction</a>
    <a href="#current-date">current-date</a>:0 
    <a href="#current-time-milliseconds">current-time-milliseconds</a>:0 
    <a href="#current-time">current-time</a>:0 
     ğŸ‘€ <a href="#curry">curry</a>:2:n 
    
    <span class = "alpha" id = "d">D</span>
    ğŸ“– <a href="#data-series">data-series</a>:1
    ğŸ“– <a href="#dalida">Dalida</a>
    
    <a href="#date">date</a>:0:7
    <a href="#date?">date?</a>:1:1
    <a href="#date->seconds">date->seconds</a>:1
    <a href="#date->string">date->string</a>:1 
    <a href="#date->date-string">date->date-string</a>:1 
    <a href="#date->time-string">date->time-string</a>:1 
    <a href="#date-add!">date-add!</a>:2 
    <a href="#date-diff">date-diff</a>:2 
    <a href="#date-format">date-format</a>:3 
     
    <a href="#decimals">decimals</a>:0:1 
    <a href="#debug">debug</a>:1 
    ğŸ‘€ <a href="#define-constant">define-constant</a>:2 
    <a href="#meta">define-modifier-key</a>:1 
    ğŸ‘€ <a href="#define-macro">define-macro</a>:3 
    ğŸ‘€ <a href="#define-syntax-rule">define-syntax-rule</a>:2 
    ğŸ‘€ <a href="#define-syntax-id">define-syntax-id</a>:2 
    ğŸ‘€ <a href="#define-syntax">define-syntax</a>:2:n 
    ğŸ‘€ <a href="#define-values">define-values</a>:2 
    ğŸ‘€ <a href="#definitions">define</a>:2:2 a variable
    ğŸ‘€ <a href="#define">define</a>:2:n a function 
    <a href="#define-global">define-global</a>:2:2
    ğŸ”‘  <a href="#definitions">definitions</a>
    ğŸ‘€ <a href="#delay">delay</a>:1   
    <a href="#den">den</a>:1 
    <a href="#dir">dir</a>:0 
    <a href="#display">display</a>:1:2
    ğŸ“– <a href="#distance">distance</a>:4
    ğŸ‘€ <a href="#do">do</a>:2:n 
    <a href="#fundef">docstring</a> 
    ğŸ“– <a href="#dot-product">dot-product</a>:2 ğŸ“Œ
    <a href="#drop">drop</a>:2 
    
    <span class = "alpha" id = "e">E</span>
    <a href="#edit">edit</a>:1 
    <a href="#cond">else</a> keyword 
    <a href="#stream?">empty-stream</a>
    <a href="#empty?">empty?</a>:1
    <a href="#every">every</a>:2:3 
    ğŸ‘€ <a href="#environment-current">environment-current</a>:0 
    <a href="#environment-of">environment-of</a>:1 
    <a href="#environment-bindings">environment-bindings</a>:1 
    <a href="#environment-new">environment-new</a>:1 
    <a href="#environment-parent">environment-parent</a>:1 
    <a href="#environment?">environment?</a>:1
    
    <span id="examples">Examples</span>
    ğŸ’¾ <a href="./lib/bench.glisp">benchmarking</a>
    ğŸ’¾ <a href="./lib/curves.glisp">curves</a>
    ğŸ’¾ <a href="./lib/combinations.glisp">combinations</a>
    ğŸ’¾ <a href="./lib/plot-xy.glisp">f(x,y) curves</a>
    ğŸ’¾ <a href="./lib/regression.glisp">regression</a>
    ğŸ’¾ <a href="./lib/sets.glisp">{sets}</a>
    ğŸ’¾ <a href="./lib/snippets.glisp">snippets</a>
    ğŸ’¾ <a href="./lib/todo.glisp">todo list</a>
     
    ğŸ“– <a href="#approx"> &epsilon;, epsilon</a>
    <a href="#eq?">eq?</a>:2 
    <a href="#equal?">equal?</a>:2 
    <a href="#eqv?">eqv?</a>:2 
    <a href="#error">error</a>:2 
    <a href="#eval">eval</a>:1:2 
    <a href="#even?">even?</a>:1 
    ğŸ“– <a href="#timer.lib">every</a>2 (timer.lib)
    <a href="#exact->inexact">exact->inexact</a>:1 
    <a href="#exact?">exact?</a>:1 
    <a href="#exp">exp</a>:1 
    <a href="#expt">expt</a>:2 
    
    <span class = "alpha" id = "f">F</span>
    <a href="#factor">factor</a>:1 
    <a href="#factorial">factorial</a>:1 
    <a href="#file->string">file->string</a>:1:2
    <a href="#file?">file?</a>:1 
    <a href="#filter-count">filter-count</a>:2 
    <a href="#filter">filter</a>:2 
    <a href="#first">first</a>:1 <small>aka car</small>
    ğŸ‘€ <a href="#flambda">flambda</a>:2:n 
    <a href="#flatten">flatten</a>:1 
    <a href="#floor">floor</a>:1 
    <a href="#foldl">foldl</a>:3:n 
    <a href="#foldr">foldr</a>:3:n 
    <a href="#for-each">for-each</a>:2:n 
    
    ğŸ‘€ <a href="#for*/and">for*/and</a>:2:n 
    ğŸ‘€ <a href="#for*/fold">for*/fold</a>:2:n 
    ğŸ‘€ <a href="#for*/list">for*/list</a>:2:n 
    ğŸ‘€ <a href="#for*/product">for*/product</a>:2:n 
    ğŸ‘€ <a href="#for*/sum">for*/sum</a>:2:n
    ğŸ‘€ <a href="#for*/string">for*/string</a>:2:n 
    ğŸ‘€ <a href="#for*/vector">for*/vector</a>:2:n 
    ğŸ‘€ <a href="#for*">for*</a>:2:n 
    ğŸ‘€ <a href="#for/and">for/and</a>:2:n 
    ğŸ‘€ <a href="#for/fold">for/fold</a>:2:n 
    ğŸ‘€ <a href="#for/list">for/list</a>:2:n
    ğŸ‘€ <a href="#for/max">for/max</a>:2:n 
    ğŸ‘€ <a href="#for/or">for/or</a>:2:n 
    ğŸ‘€ <a href="#for/product">for/product</a>:2:n 
    ğŸ‘€ <a href="#for/sum">for/sum</a>:2:n 
    ğŸ‘€ <a href="#for/string">for/string</a>:2:n 
    ğŸ‘€ <a href="#for/vector">for/vector</a>:2:n 
    ğŸ‘€ <a href="#for">for</a>:2:n 
    
    <a href="#force">force</a>:1
    <a href="#forget">forget</a>:1 
    <a href="#format">format</a>:1:n 
    <a href="#fract">fract</a>:1 
    ğŸ“– <a href="#fractal">fractal</a>
    <a href="#fundef">function definition</a>
    
    <span class = "alpha" id = "g">G</span>
    ğŸ“–  <a href="#gamma">&Gamma;(x)</a>:1
    <a href="#gcd">gcd</a>:2 
    <a href="#gcd">gcd</a>:3:n 
    ğŸ“–  <a href="#sequences.lib">generator</a>
    <a href="#gensym">gensym</a>:0 
    <a href="#get">get</a>:2 
    <a href="#getprop">getprop</a>:2
    ğŸ“– <a href="#gloops.lib">gloops.lib</a>
    ğŸ“– <a href="#graph.lib">graph.lib</a> ğŸ“ŒğŸ“Œ
    <a href="#group">group</a>:1:2
    <a href="#group">group*</a>:1:2
    
    <span class = "alpha" id = "h">H</span>
    ğŸ“– <a href="#hash.lib">hash tables</a>
    ğŸ“– <a href="#heap.lib">heaps</a> ğŸ“ŒğŸ“Œ 
    ğŸ‘€ <a href="#help">help</a>:1 ğŸ†˜
    ğŸ‘€ <a href="#help">?</a>:1 
    <a href="#html-print">html-print</a>:1 
    
    <span class = "alpha" id = "i">I</span>
    ğŸ“– <a href="#idb.lib">Indexed Data Base</a> ğŸ“Œ
    <a href="#identity">identity</a>:1
    ğŸ‘€ <a href="#if">if</a>:3 
    <a href="#imag-part">imag-part</a>:1 
    <a href="#imag">imag</a>:1 
    <a href="#in-cycle">in-cycle</a>:0:1 
    <a href="#in-naturals">in-naturals</a>:0:1 
    <a href="#in-permutations">in-permutations</a>:1 
    <a href="#in-primes">in-primes</a>:1 
    <a href="#for">in-producer</a>:1:n
    <a href="#in-range">in-range</a>:1:3 
    <a href="#in-range+">in-range+</a>:1:3 
    
    <a href="#inexact->exact">inexact->exact</a>:1 
    <a href="#inexact?">inexact?</a>:1 
    ğŸ“–  <a href="#infix.lib">infix library</a> 
    <a href="#info">info</a>:1:2 
    <a href="#inline">inline</a>:2:2 
    <a href="#input-expr">input-expr</a>:2 
    <a href="#input-string">input-string</a>:2 
    <a href="#integer?">integer?</a>:1 
    ğŸ“–  <a href="#interface.lib">interface library</a>
    <a href="#iota">iota</a>:1:3 
    <a href="#iterate">iterate</a>:2 
    ğŸ“–  <a href="#sequences.lib">iterators</a>
    
    <span class = "alpha" id = "j">J</span>
    <a href="#js-eval">js-eval</a>:1
    <a href="#jsonify">jsonify</a>:1
    ğŸ“– <a href="#json.lib">JSON</a>
    <a href="#json?">json?</a>:1
    <a href="#make-json">make-json</a>:1
    <a href="#export-json">export-json</a>:1
    <a href="#json-get">json-get</a>:2
    <a href="#json-import">json-import</a>:1
    <a href="#json-keys">json-keys</a>:1
    <a href="#json-put">json-put</a>:3
    <a href="#json-types">json-types</a>:1
    <a href="#json->plist">json->plist</a>:1
   
    <a href="#json->lisp">json->lisp</a>:1
    <a href="#lisp->json">lisp->json</a>:1
    <a href="#json->string">json->string</a>:1
    <a href="#string->json">string->json</a>:1
    
     ğŸ“– <a href="#julia">Julia set</a>
       
    <span class = "alpha" id = "k">K</span>
    
    <span class = "alpha" id = "l">L</span>
    ğŸ‘€ <a href="#lambda-tail-call">lambda-tail-call</a>:2:n 
    ğŸ‘€ <a href="#lambda">lambda</a>:2:n
    ğŸ‘€ Î»:2:n 
    <a href="#last">last</a>:1 
    ğŸ“– <a href="#kons">lazy lists</a>
    <a href="#lcm">lcm</a>:2 
    <a href="#length">length</a>:1
    ğŸ‘€ <a href="#let*">let*</a>:2:n 
    ğŸ‘€ <a href="#let">let</a>:2:n 
    ğŸ‘€ <a href="#letrec">letrec</a>:2:n  
    <a href="#lib-functions">lib-functions</a>:1 
    <a href="#lib">lib</a>:1 
    ğŸ“– <a href="#list.lib">list library</a>
    ğŸ“– <a href="#list->number">list->number</a>:1
    <a href="#list->stack">list->stack</a>:2:2
    <a href="#list->string">list->string</a>:1
    <a href="#list->vector">list->vector</a>:1 
    <a href="#list-index">list-index</a>:2 
    <a href="#flatten">flatten</a>:1 
    <a href="#group">group</a>:1:2 
    <a href="#list-ref">list-ref</a>:2 
    <a href="#list-sort">list-sort</a>:2 
    <a href="#list-sort/fields">list-sort/fields</a>:2 
    <a href="#list-swap!">list-swap!</a>:3 
    <a href="#list-swap-ref!">list-swap-ref!</a>:3 
    <a href="#list-tail">list-tail</a>:2 
    <a href="#list">list</a>:1:n 
    <a href="#list?">list?</a>:1 
    <a href="#load-reader-dict">load-reader-dict</a>:1 
    <a href="#load-package">load-package</a>:1 
    <a href="#load">load</a>:0:1 
    <a href="#log10">log10</a>:1 
    <a href="#log2">log2</a>:1 
    <a href="#log">log</a>:1 
    <a href="#bit-count">logical/bit operations
    
    <a href="#local-verbose">local-verbose</a>:1 
    <a href="#local-stores">local-stores</a>:0:1 
    <a href="#local-make-store">local-make-store</a>:1 
    <a href="#local-delete-store!">local-delete-store!</a>:1
    <a href="#local-symbol?">local-symbol?</a>:1
    <a href="#local-add">local-add</a>:1
    <a href="#local-put">local-put</a>:1
    <a href="#local-get">local-get</a>:1
    <a href="#local-add-value">local-add-value</a>:2:3 
    <a href="#local-get-value">local-get-value</a>:1:2 
    <a href="#local-put-value">local-put-value</a>:2:3 
    <a href="#local-delete">local-delete</a>:2:2 

    <span class = "alpha" id = "m">M</span>
    ğŸ“–  <a href="#macros">macros</a> (reader) 
    ğŸ“¬  <a href="#send-mail">mail</a>:3  
    <a href="#magnitude">magnitude</a>:1 
    <a href="#make-initialized-vector">make-initialized-vector</a>:2 
    <a href="#make-list">make-list</a>:2 
    <a href="#make-polar">make-polar</a>:2 
    <a href="#make-rect">make-rect</a>:2 
    <a href="#make-regexp">make-regexp</a>:1 
    <a href="#make-set">make-set</a>:1
    <a href="#make-stream">make-stream</a>:2 
    <a href="#make-symbol">make-symbol</a>:1 
    <a href="#make-vector">make-vector</a>:1:2 
    <a href="#map">map</a>:2:n 
    <a href="#maplist">maplist</a>:2 
    <a href="#mark">mark</a>:2 
    <a href="#mark?">mark?</a>:1
    <a href="#mark-filter">mark-filter</a>:1:2
    <a href="#mark-print">mark-print</a>:0:1
    ğŸ“–  ğŸ‘€  <a href="#match">match</a>:2:n  ğŸ“ŒğŸ“ŒğŸ“Œ 
    ğŸ“– <a href="#math.lib">math.lib</a> 
    ğŸ“– <a href="#matrix.lib">matrix.lib</a> 
    <a href="#max">max</a>:1:n 
    <a href="#max">max</a>:2 
    <a href="#member">member</a>:2 
    <a href="#member*">member*</a>:2 
    <a href="#memq">memq</a>:2 
    <a href="#memv">memv</a>:2 
    <a href="#meta">meta-key</a>:2
    <a href="#meta">meta-keys</a>:0  
    <a href="#min">min</a>:1:n 
    <a href="#min">min</a>:2 
    <a href="#modulo">modulo</a>:2 
    ğŸ“–  <a href="#tasks.lib">mutex</a>
    
    <span class = "alpha" id = "n">N</span>
    <a href="#nconc">nconc</a>:1:n 
    <a href="#negative?">negative?</a>:1 
    <a href="#newline">newline</a>:0 
    ğŸ“–  <a href="#sequences.lib">next</a>:1 
    <a href="#next-prime">next-prime</a>:1 
    <a href="#not">not</a>:1 
    <a href="#notebook">notebook</a>:0 
    <a href="#null?">null?</a>:1 
    <a href="#!null?">!null?</a>:1 
    <a href="#num">num</a>:1
    ğŸ“– <a href="#num-divisors">num-divisors</a>:1
    <a href="#number-length">number-length</a>:1:2 
    <a href="#number->string">number->string</a>:1:2 
    ğŸ“– <a href="#number->list">number->list</a>:1
    <a href="#number?">number?</a>:1 
    
    <span class = "alpha" id = "o">O</span>
    <a href="#odd?">odd?</a>:1
    ğŸ“– <a href="#web.lib">oeis</a> ğŸ“š
    <a href="#struct">#:onchange</a> keyword
    ğŸ‘€ <a href="#or">or</a>:1:n 
    ğŸ‘€ <a href="#or">or*</a>:2:2 
    
    <span class = "alpha" id = "p">P</span>
    <a href="#pair?">pair?</a>:1 
     ğŸ”‘  <a href="#match">pattern</a>
    ğŸ“– <a href="#list.lib">permutations</a>
    <a href="#pipeline">pipeline operator</a>:1:n 
    <a href="#plist-keys">plist-keys</a>:1 
    ğŸ“– <a href="#plot.lib">plot.lib</a> 
    ğŸ“– <a href="#plot-3d.lib">plot-3d.lib</a> ğŸ“ŒğŸ“ŒğŸ“Œ 
    <a href="#polar">polar</a>:2 
    ğŸ“– <a href="#poly">polynomial in math.lib</a>
    <a href="#positive?">positive?</a>:1
    <a href="#positive*?">positive*?</a>:1
    <a href="#packages">preferences</a>:0 user defined 
    ğŸ“– <a href="#pretty-print">pretty-print</a>:1:2
    <a href="#prime-factors">prime-factors</a>:1 
    <a href="#prime?">prime?</a>:1 
    <a href="#primes">primes</a>:1 
    <a href="#printf">printf</a>:1:n 
    <a href="#procedure?">procedure?</a>:1
    ğŸ“– <a href="#sequences.lib">procrastinator</a>
    ğŸ“– <a href="#product">product</a>:3 
    ğŸ“– <a href="#product">Î </a>:3 
    <a href="#promise?">promise?</a>:1 
    <a href="#plist">property lists, aka plists</a>
    ğŸ“–  <a href="#poly">polynomials</a>
    <a href="#pop">pop</a>:1
    <a href="#powmod">powmod</a>:3
    <a href="#push">push</a>:2
    <a href="#putprop">putprop</a>:3 
    
    <span class = "alpha" id = "q">Q</span>
    ğŸ‘€ <a href="#quasiquote">quasiquote</a>:1
    ğŸ“– <a href="#queues">queues</a> (tree.lib)
    ğŸ‘€ <a href="#quote">quote</a>:1 
    <a href="#quotient">quotient</a>:2 
    
    <span class = "alpha" id = "r">R</span>
    <a href="#random-prime">random-prime</a>:1 
    <a href="#random-seed">random-seed</a>:1 
    <a href="#random">random</a>:0:1 
    <a href="#range">range</a>:1:3 
    <a href="#rational">rational</a>:2 
    <a href="#rational?">rational?</a>:1 
    <a href="#rationalize">rationalize</a>:1:2 
    ğŸ‘€ <a href="#rcurry">rcurry</a>:2:n 
    <a href="#read">read</a>:0:2
    <a href="#read-from-string">read-from-string</a>:1
    <a href="#read-list">read-list</a>:0:2
    <a href="#read-number">read-number</a>:0:2
    <a href="#read-string">read-string</a>:0:2
      
    <a href="#reader">lisp reader
    <a href="#reader-dict-new">reader-dict-new</a>:1 
    <a href="#reader-dict-set!">reader-dict-set!</a>:2 
    <a href="#reader-dict">reader-dict</a>:0 
    <a href="#reader-rem-proc">reader-rem-proc</a>:0 
    <a href="#reader-set-proc!">reader-set-proc!</a>:2 
    <a href="#reader-set-prompt!">reader-set-prompt!</a>:1 
    <a href="#reader-translate">reader-translate</a>:2
    
    <a href="#real-part">real-part</a>:1 
    <a href="#real">real</a>:1 

    ğŸ”‘ <a href="#recursion">recursion</a>
    ğŸ”‘ <a href="#regexp">regular expressions</a> 
    <a href="#regexp-exec">regexp-exec</a>:2 
    <a href="#regexp-match">regexp-match</a>:2 
    <a href="#regexp-match*">regexp-match*</a>:2 
    <a href="#remember">remember</a>:1:2 
    <a href="#remove-local">remove-local</a>:1
    <a href="#remprop">remprop</a>:2 
    <a href="#require">require</a>:1 
    <a href="#rest">rest</a>:1 <small>aka cdr</small>
    <a href="#reverse">reverse</a>:1 
    ğŸ”—  ğŸ’¾  <a href="http://rosettacode.org/wiki/EchoLisp">Rosetta Code</a> 
    <a href="#round">round</a>:1 
    
    <span class = "alpha" id = "s">S</span>
    
    { set operations }
    <a href="#set?">set?</a>:1 
    <a href="#set-equal?">set-equal?</a>:2 
    <a href="#set-intersect">set-intersect</a>:2 
    <a href="#set-intersect?">set-intersect?</a>:2
    <a href="#set-product">set-product</a>:2
    <a href="#set-subset?">set-subset?</a>:2
    <a href="#set-substract">set-substract</a>:2 
    <a href="#set-sym-diff">set-sym-diff</a>:2
    <a href="#set-union">set-union</a>:2 
   
    <a href="#save-as">save-as</a>:2  ğŸ“Œ
    <a href="#save-reader-dict">save-reader-dict</a>:1 
    <a href="#save-package">save-package</a>:1
    <a href="#cadr">second</a>:1
    <a href="#seconds->date">seconds->date</a>:1
    ğŸ“–  <a href="#tasks.lib">semaphore</a>
    ğŸ“–  <a href="#sequences.lib">sequences</a> ğŸ“Œ ğŸ“Œ ğŸ“Œ  
    <a href="#set-box!">set-box!</a>:2 
    <a href="#set-car!">set-car!</a>:2 
    <a href="#set-cdr!">set-cdr!</a>:2 
    ğŸ‘€ <a href="#set!">set!</a>:2 
    ğŸ‘€ <a href="#setv!">setv!</a>:2 
    ğŸ‘€ <a href="#set!-values">set!-values</a>:2  
    <a href="#set-plist!">set-plist!</a>:2 
    <a href="#shuffle">shuffle</a>:1 
    ğŸ“– <a href="#sigma">sigma</a>:3 
    ğŸ“– <a href="#sigma">Î£</a>:3 
    ğŸ“– <a href="#sigma">Î£Î£</a>:3 
    <a href="#sin">sin</a>:1 
    ğŸ“– <a href="#timer.lib">sound</a>
    <a href="#sqrt">sqrt</a>:1 
    <a href="#square?">square?</a>:1 
    ğŸ“– <a href="#sql.lib">sql.lib</a>
    <a href="#srange">srange</a>:1:3 
    
    <a href="#stack">stack</a>:1
    <a href="#stack-empty?">stack-empty?</a>:1
    <a href="#stack-top">stack-top</a>:1
    <a href="#stack->list">stack->list</a>:1
    <a href="#stack-length">stack-length</a>:1
    <a href="#stack-swap">stack-swap</a>:1
    
    <a href="#stdin-background">stdin-background</a>:1
    <a href="#stdin-color">stdin-color</a>:1 
    <a href="#stdin-font-size">stdin-font-size</a>:0:1 
    <a href="#stdin-font">stdin-font</a>:0:1 
    <a href="#stdin-hide">stdin-hide</a>:1
    
    <a href="#stdout-background">stdout-background</a>:1
    <a href="#stdout-clear">stdout-clear</a>:0 
    <a href="#stdout-color">stdout-color</a>:1 
    <a href="#stdout-font-size">stdout-font-size</a>:0:1 
    <a href="#stdout-font">stdout-font</a>:0:1 
    <a href="#stdout-hide">stdout-hide</a>:1
    
     ğŸ‘€ <a href="#stream-cons">stream-cons</a>:2
    <a href="#make-stream">make-stream</a>:2 
    <a href="#stream->list">stream->list</a>:1:2 
    <a href="#stream-add">stream-add</a>:2 
    <a href="#stream-empty?">stream-empty?</a>:1 
    <a href="#stream-iterate">stream-iterate</a>:1 
    <a href="#stream-filter">stream-filter</a>:2 
    <a href="#stream-first">stream-first</a>:1 
    <a href="#stream-map">stream-map</a>:3 
    <a href="#stream-mul">stream-mul</a>:2 
    <a href="#stream-ref">stream-ref</a>:2 
    <a href="#stream-rest">stream-rest</a>:1 
    <a href="#stream?">stream?</a>:1 
    
    <a href="#string?">string?</a>:1
    <a href="#string">string</a>:1
    <a href="#string->date">string->date</a>:1
    <a href="#string->html">string->html</a>:1 
    <a href="#string->list">string->list</a>:1 
    <a href="#string->number">string->number</a>:1 
    <a href="#string->unicode">string->unicode</a>:1 
    <a href="#string-alphabetic?">string-alphabetic?</a>:1
    <a href="#string-append">string-append</a>:1:n 
    <a href="#string-ci=?">string-ci&lt;=?</a>:2 
    <a href="#string-ci=?">string-ci&lt;?</a>:2 
    <a href="#string-ci=?">string-ci=?</a>:2 
    <a href="#string-ci=?">string-ci&gt;=?</a>:2 
    <a href="#string-ci=?">string-ci&gt;?</a>:2 
    <a href="#string-delimiter">string-delimiter</a>:0:1
    <a href="#string-diacritics">string-diacritics</a>:1
    <a href="#string-downcase">string-downcase</a>:1 
    <a href="#string-empty?">string-empty?</a>:1
    <a href="#string-first">string-first</a>:1 
    <a href="#string-index">string-index</a>:2 
    <a href="#string-join">string-join</a>:1:2 
    <a href="#string-last">string-last</a>:1 
    <a href="#string-length">string-length</a>:1 
    <a href="#string-match">string-match</a>:2:3 
    <a href="#string-pad-left">string-pad-left</a>:2 
    <a href="#string-pad-right">string-pad-right</a>:2 
    <a href="#string-prefix?">string-prefix?</a>:2 
    <a href="#string-randcase">string-randcase</a>:1
    <a href="#string-ref">string-ref</a>:2 
    <a href="#string-remove">string-remove</a>:2:2
    <a href="#string-replace">string-replace</a>:3:4 
    <a href="#string-rest">string-rest</a>:1 
    <a href="#string-split">string-split</a>:1:2
    <a href="#string-suffix?">string-suffix?</a>:2 
    <a href="#string-titlecase">string-titlecase</a>:1
    <a href="#string-trim">string-trim</a>:1
    <a href="#string-trim-left">string-trim-left</a>:1
    <a href="#string-trim-right">string-trim-right</a>:1 
    <a href="#string-upcase">string-upcase</a>:1 
    <a href="#string<=?">string&lt;=?</a>:2 
    <a href="#string=?">string&lt;?</a>:2
    <a href="#string=?">string=?</a>:2 
    <a href="#string=?">string&gt;=?</a>:2 
    <a href="#string=?">string&gt;?</a>:2 
   
    ğŸ“– <a href="#struct.lib">struct.lib</a>
    ğŸ‘€ <a href="#struct">struct</a>:2:5 

    <a href="#style">style</a>:0:2
    <a href="#sub1">sub1</a>:1 
    <a href="#sublist">sublist</a>:3 
    <a href="#substring">substring</a>:2:3 
    <a href="#subvector">subvector</a>:2:3 
    <a href="#symbol->string">symbol->string</a>:1 
    <a href="#symbol-plist">symbol-plist</a>:1 
    <a href="#symbol?">symbol?</a>:1
    <a href="#symset!">symset!</a>:1
    ğŸ‘€ <a href="#syntax">syntax</a> rules  
    system-global-environment
    
    <span class = "alpha" id = "t">T</span>
    ğŸ“– <a href="#sql.lib">tables - sql.lib<a>
    <a href="#take">take</a>:2 
    <a href="#tan">tan</a>:1 
    ğŸ“–  <a href="#tasks.lib">task</a>
    <a href="#text-parse">text-parse</a>:1:2 
    <a href="#caddr">third</a>:1
    <a href="#throw">throw</a>:2
    ğŸ“– <a href="#data-series">time-series</a>:1
    ğŸ‘€ <a href="#time">time</a>:1 
    ğŸ“– <a href="#timer.lib">timer.lib</a>
    ğŸ“– <a href="#tree.lib">tree.lib</a>
    <a href="#trace">trace</a>:1 
    ğŸ‘€ <a href="#try">try</a>:2:n 
    <a href="#tree-fold">tree-fold</a>:3 
    <a href="#tree-for-each">tree-for-each</a>:2 
    ğŸ“– <a href="#vlib.lib"> ğŸš² typed vectors : vlib </a>
    ğŸ“– <a href="#types.lib">Types</a>
    
    <span class = "alpha" id = "u">U</span>
    ğŸ“– <a href="#interface.lib">User Interface</a>
    <a href="#unbox">unbox</a>:1
    ğŸ‘€ <a href="#undefine">undefine</a>:1 
    ğŸ‘€ <a href="#unless">unless</a>:2:n  
    <a href="#unicode->string">unicode->string</a>:1 
    <a href="#unmark">unmark</a>:1
    ğŸ‘€ <a href="#unquote-splicing">unquote-splicing</a>:1 
    ğŸ‘€ <a href="#unquote">unquote</a>:1  
    <a href="#untrace">untrace</a>:1 
     ğŸ‘€ <a href="#help">usage</a>:1  ğŸ†˜
    <a href="#use-infix">use-infix</a>:1 
    <a href="#environment">user-initial-environment</a>
    
    
    <span class = "alpha" id = "v">V</span>
    ğŸ‘€ <a href="#values">values</a>:1:n 
    <a href="#vector-append">vector-append</a>:2
    <a href="#vector-dup">vector-dup</a>:1 
    <a href="#vector-empty?">vector-empty?</a>:1 
    <a href="#vector-index">vector-index</a>:2:3 
    <a href="#vector->list">vector->list</a>:1 
    <a href="#vector-fill!">vector-fill!</a>:2 
    <a href="#vector-filter">vector-filter</a>:2 
    <a href="#vector-insert">vector-insert*</a>:2
    <a href="#vector-length">vector-length</a>:1 
    <a href="#vector-map">vector-map</a>:2:n 
    <a href="#vector-permute!">vector-permute!</a>:2 
    <a href="#vector-pop">vector-pop</a>:1 
    <a href="#vector-push">vector-push</a>:2 
    <a href="#vector-ref">vector-ref</a>:2
    <a href="#vector-remove">vector-remove*</a>:2
    <a href="#vector-remove-ref">vector-remove-ref!</a>:2
    <a href="#vector-rotate!">vector-rotate!</a>:2
    <a href="#vector-search">vector-search</a>:2:3 
    <a href="#vector-search">vector-search*</a>:2 
    <a href="#vector-set!">vector-set!</a>:3 
    <a href="#vector+=">vector+=</a>:3 
    <a href="#vector*=">vector*=</a>:3 
    <a href="#vector-shift">vector-shift</a>:1 
    <a href="#vector-sort!">vector-sort!</a>:2
    <a href="#vector-swap!">vector-swap!</a>:3 
    <a href="#vector">vector</a>:0:n 
    <a href="#vector?">vector?</a>:1 
    ğŸ“–  <a href="#matrix">math.lib</a> - vector products 
    <a href="#version">version</a>:1 
    ğŸ“– <a href="#vlib.lib"> ğŸš² typed vectors : vlib </a>
    <a href="#void">void</a>:0 
    <a href="#void">void?</a>:1 
    
    <span class = "alpha" id = "w">W</span>
    ğŸ“– <a href="#timer.lib">wait</a>:2
    ğŸ“– <a href="#web.lib">web.lib</a>
    ğŸ‘€ <a href="#when">when</a>:2:n 
    ğŸ‘€ <a href="#while">while</a>:2:n 
    <a href="#lists">Wittgenstein</a> philosopher
    ğŸ“– <a href="#words.lib">words.lib</a>
    <a href="#write">write</a>:1:n 
    <a href="#writeln">writeln</a>:0:n 
    
    <a href="#worksheet-open">worksheet-open</a>:1
    <a href="#worksheet-remove">worksheet-remove</a>:1
    <a href="#worksheet-save">worksheet-save</a>:1
    
    <span class = "alpha" id = "x">X</span>
    <a href="#xor">xor</a>:2 
    
    <span class = "alpha" id = "y">Y</span>
    ğŸ“–  <a href="#sequences.lib">yield</a>
    
    <span class = "alpha" id = "z">Z</span>
    <a href="#zero?">zero?</a>:1
    <a href="#!zero?">!zero?</a>:1 
</pre>

<hr>
<p><small>
Â«  [...] les parenthÃ¨ses sont l'instrument privilÃ©giÃ© de ce lent et difficile Ã©claircissement pour traverser les apparences qui est au cÅ“ur de l'esthÃ©tique proustienne; elles expliquent, au sens Ã©tymologiqueâ€”ex-plicare: - dÃ©plier, dÃ©rouler - ce qui, sans cet effort d'analyse, resterait confus; ce sont autant d'auxiliaires prÃ©cieux d'un Narrateur qui se veut avant tout un traducteurÂ»
<br>
Isabelle SerÃ§a  - <a href="http://www.theses.fr/1998TOU20011">La parenthÃ¨se chez Proust</a> -
</small></p>
<hr>

<br>
<div id = "footer"  class="footer">
EchoLisp - Ref : V4.0 - Â© G. Brougnard, J. Tramu & Echolalie, 2014,2016 - 
&nbsp;<a href="mailto:echolalie@echolalie.com?subject=EchoLisp" title = "Ecrire"> ğŸ“« [Mail] ğŸ“­ </a>
</div>


<script>
document.onkeypress = codeKeyPress;
</script>
</body>
</html>
